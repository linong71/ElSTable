(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"));
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["elstable"] = factory(require("vue"));
	else
		root["elstable"] = factory(root["Vue"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__203__) {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 933:
/***/ (function(module) {

"use strict";


var isMergeableObject = function isMergeableObject(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === 'object';
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneIfNecessary(value, optionsArgument) {
  var clone = optionsArgument && optionsArgument.clone === true;
  return clone && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
}
function defaultArrayMerge(target, source, optionsArgument) {
  var destination = target.slice();
  source.forEach(function (e, i) {
    if (typeof destination[i] === 'undefined') {
      destination[i] = cloneIfNecessary(e, optionsArgument);
    } else if (isMergeableObject(e)) {
      destination[i] = deepmerge(target[i], e, optionsArgument);
    } else if (target.indexOf(e) === -1) {
      destination.push(cloneIfNecessary(e, optionsArgument));
    }
  });
  return destination;
}
function mergeObject(target, source, optionsArgument) {
  var destination = {};
  if (isMergeableObject(target)) {
    Object.keys(target).forEach(function (key) {
      destination[key] = cloneIfNecessary(target[key], optionsArgument);
    });
  }
  Object.keys(source).forEach(function (key) {
    if (!isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneIfNecessary(source[key], optionsArgument);
    } else {
      destination[key] = deepmerge(target[key], source[key], optionsArgument);
    }
  });
  return destination;
}
function deepmerge(target, source, optionsArgument) {
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var options = optionsArgument || {
    arrayMerge: defaultArrayMerge
  };
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneIfNecessary(source, optionsArgument);
  } else if (sourceIsArray) {
    var arrayMerge = options.arrayMerge || defaultArrayMerge;
    return arrayMerge(target, source, optionsArgument);
  } else {
    return mergeObject(target, source, optionsArgument);
  }
}
deepmerge.all = function deepmergeAll(array, optionsArgument) {
  if (!Array.isArray(array) || array.length < 2) {
    throw new Error('first argument should be an array with at least two elements');
  }

  // we are sure there are at least 2 values, so it is safe to have no initial value
  return array.reduce(function (prev, next) {
    return deepmerge(prev, next, optionsArgument);
  });
};
var deepmerge_1 = deepmerge;
module.exports = deepmerge_1;

/***/ }),

/***/ 132:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = /******/function (modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/
  var installedModules = {};
  /******/
  /******/ // The require function
  /******/
  function __nested_webpack_require_198__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/if (installedModules[moduleId]) {
      /******/return installedModules[moduleId].exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/
    var module = installedModules[moduleId] = {
      /******/i: moduleId,
      /******/l: false,
      /******/exports: {}
      /******/
    };
    /******/
    /******/ // Execute the module function
    /******/
    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_198__);
    /******/
    /******/ // Flag the module as loaded
    /******/
    module.l = true;
    /******/
    /******/ // Return the exports of the module
    /******/
    return module.exports;
    /******/
  }
  /******/
  /******/
  /******/ // expose the modules object (__webpack_modules__)
  /******/
  __nested_webpack_require_198__.m = modules;
  /******/
  /******/ // expose the module cache
  /******/
  __nested_webpack_require_198__.c = installedModules;
  /******/
  /******/ // define getter function for harmony exports
  /******/
  __nested_webpack_require_198__.d = function (exports, name, getter) {
    /******/if (!__nested_webpack_require_198__.o(exports, name)) {
      /******/Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/
  };
  /******/
  /******/ // define __esModule on exports
  /******/
  __nested_webpack_require_198__.r = function (exports) {
    /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/
  /******/ // create a fake namespace object
  /******/ // mode & 1: value is a module id, require it
  /******/ // mode & 2: merge all properties of value into the ns
  /******/ // mode & 4: return value when already ns object
  /******/ // mode & 8|1: behave like require
  /******/
  __nested_webpack_require_198__.t = function (value, mode) {
    /******/if (mode & 1) value = __nested_webpack_require_198__(value);
    /******/
    if (mode & 8) return value;
    /******/
    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
    /******/
    var ns = Object.create(null);
    /******/
    __nested_webpack_require_198__.r(ns);
    /******/
    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/
    if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_198__.d(ns, key, function (key) {
      return value[key];
    }.bind(null, key));
    /******/
    return ns;
    /******/
  };
  /******/
  /******/ // getDefaultExport function for compatibility with non-harmony modules
  /******/
  __nested_webpack_require_198__.n = function (module) {
    /******/var getter = module && module.__esModule ? /******/function getDefault() {
      return module['default'];
    } : /******/function getModuleExports() {
      return module;
    };
    /******/
    __nested_webpack_require_198__.d(getter, 'a', getter);
    /******/
    return getter;
    /******/
  };
  /******/
  /******/ // Object.prototype.hasOwnProperty.call
  /******/
  __nested_webpack_require_198__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/
  /******/ // __webpack_public_path__
  /******/
  __nested_webpack_require_198__.p = "/dist/";
  /******/
  /******/
  /******/ // Load entry module and return exports
  /******/
  return __nested_webpack_require_198__(__nested_webpack_require_198__.s = 93);
  /******/
}
/************************************************************************/
/******/({
  /***/0: /***/function (module, __nested_webpack_exports__, __nested_webpack_require_4030__) {
    "use strict";

    /* harmony export (binding) */
    __nested_webpack_require_4030__.d(__nested_webpack_exports__, "a", function () {
      return normalizeComponent;
    });
    /* globals __VUE_SSR_CONTEXT__ */

    // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
    // This module is a runtime utility for cleaner component module output and will
    // be included in the final webpack user bundle.

    function normalizeComponent(scriptExports, render, staticRenderFns, functionalTemplate, injectStyles, scopeId, moduleIdentifier, /* server only */
    shadowMode /* vue-cli only */) {
      // Vue.extend constructor export interop
      var options = typeof scriptExports === 'function' ? scriptExports.options : scriptExports;

      // render functions
      if (render) {
        options.render = render;
        options.staticRenderFns = staticRenderFns;
        options._compiled = true;
      }

      // functional template
      if (functionalTemplate) {
        options.functional = true;
      }

      // scopedId
      if (scopeId) {
        options._scopeId = 'data-v-' + scopeId;
      }
      var hook;
      if (moduleIdentifier) {
        // server build
        hook = function (context) {
          // 2.3 injection
          context = context ||
          // cached call
          this.$vnode && this.$vnode.ssrContext ||
          // stateful
          this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
          // 2.2 with runInNewContext: true
          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
            context = __VUE_SSR_CONTEXT__;
          }
          // inject component styles
          if (injectStyles) {
            injectStyles.call(this, context);
          }
          // register component module identifier for async chunk inferrence
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
      } else if (injectStyles) {
        hook = shadowMode ? function () {
          injectStyles.call(this, this.$root.$options.shadowRoot);
        } : injectStyles;
      }
      if (hook) {
        if (options.functional) {
          // for template-only hot-reload because in that case the render fn doesn't
          // go through the normalizer
          options._injectStyles = hook;
          // register for functioal component in vue file
          var originalRender = options.render;
          options.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = options.beforeCreate;
          options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
      return {
        exports: scriptExports,
        options: options
      };
    }

    /***/
  },

  /***/4: /***/function (module, exports) {
    module.exports = __webpack_require__(969);

    /***/
  },

  /***/93: /***/function (module, __nested_webpack_exports__, __nested_webpack_require_7358__) {
    "use strict";

    __nested_webpack_require_7358__.r(__nested_webpack_exports__);

    // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-group.vue?vue&type=template&id=7289a290&
    var render = function () {
      var _vm = this;
      var _h = _vm.$createElement;
      var _c = _vm._self._c || _h;
      return _c("div", {
        staticClass: "el-checkbox-group",
        attrs: {
          role: "group",
          "aria-label": "checkbox-group"
        }
      }, [_vm._t("default")], 2);
    };
    var staticRenderFns = [];
    render._withStripped = true;

    // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue?vue&type=template&id=7289a290&

    // EXTERNAL MODULE: external "element-ui/lib/mixins/emitter"
    var emitter_ = __nested_webpack_require_7358__(4);
    var emitter_default = /*#__PURE__*/__nested_webpack_require_7358__.n(emitter_);

    // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-group.vue?vue&type=script&lang=js&

    /* harmony default export */
    var checkbox_groupvue_type_script_lang_js_ = {
      name: 'ElCheckboxGroup',
      componentName: 'ElCheckboxGroup',
      mixins: [emitter_default.a],
      inject: {
        elFormItem: {
          default: ''
        }
      },
      props: {
        value: {},
        disabled: Boolean,
        min: Number,
        max: Number,
        size: String,
        fill: String,
        textColor: String
      },
      computed: {
        _elFormItemSize: function _elFormItemSize() {
          return (this.elFormItem || {}).elFormItemSize;
        },
        checkboxGroupSize: function checkboxGroupSize() {
          return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
        }
      },
      watch: {
        value: function value(_value) {
          this.dispatch('ElFormItem', 'el.form.change', [_value]);
        }
      }
    };
    // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue?vue&type=script&lang=js&
    /* harmony default export */
    var src_checkbox_groupvue_type_script_lang_js_ = checkbox_groupvue_type_script_lang_js_;
    // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
    var componentNormalizer = __nested_webpack_require_7358__(0);

    // CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue

    /* normalize component */

    var component = Object(componentNormalizer["a" /* default */])(src_checkbox_groupvue_type_script_lang_js_, render, staticRenderFns, false, null, null, null);

    /* hot reload */
    if (false) { var api; }
    component.options.__file = "packages/checkbox/src/checkbox-group.vue";
    /* harmony default export */
    var checkbox_group = component.exports;
    // CONCATENATED MODULE: ./packages/checkbox-group/index.js

    /* istanbul ignore next */
    checkbox_group.install = function (Vue) {
      Vue.component(checkbox_group.name, checkbox_group);
    };

    /* harmony default export */
    var packages_checkbox_group = __nested_webpack_exports__["default"] = checkbox_group;

    /***/
  }

  /******/
});

/***/ }),

/***/ 284:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = /******/function (modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/
  var installedModules = {};
  /******/
  /******/ // The require function
  /******/
  function __nested_webpack_require_198__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/if (installedModules[moduleId]) {
      /******/return installedModules[moduleId].exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/
    var module = installedModules[moduleId] = {
      /******/i: moduleId,
      /******/l: false,
      /******/exports: {}
      /******/
    };
    /******/
    /******/ // Execute the module function
    /******/
    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_198__);
    /******/
    /******/ // Flag the module as loaded
    /******/
    module.l = true;
    /******/
    /******/ // Return the exports of the module
    /******/
    return module.exports;
    /******/
  }
  /******/
  /******/
  /******/ // expose the modules object (__webpack_modules__)
  /******/
  __nested_webpack_require_198__.m = modules;
  /******/
  /******/ // expose the module cache
  /******/
  __nested_webpack_require_198__.c = installedModules;
  /******/
  /******/ // define getter function for harmony exports
  /******/
  __nested_webpack_require_198__.d = function (exports, name, getter) {
    /******/if (!__nested_webpack_require_198__.o(exports, name)) {
      /******/Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/
  };
  /******/
  /******/ // define __esModule on exports
  /******/
  __nested_webpack_require_198__.r = function (exports) {
    /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/
  /******/ // create a fake namespace object
  /******/ // mode & 1: value is a module id, require it
  /******/ // mode & 2: merge all properties of value into the ns
  /******/ // mode & 4: return value when already ns object
  /******/ // mode & 8|1: behave like require
  /******/
  __nested_webpack_require_198__.t = function (value, mode) {
    /******/if (mode & 1) value = __nested_webpack_require_198__(value);
    /******/
    if (mode & 8) return value;
    /******/
    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
    /******/
    var ns = Object.create(null);
    /******/
    __nested_webpack_require_198__.r(ns);
    /******/
    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/
    if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_198__.d(ns, key, function (key) {
      return value[key];
    }.bind(null, key));
    /******/
    return ns;
    /******/
  };
  /******/
  /******/ // getDefaultExport function for compatibility with non-harmony modules
  /******/
  __nested_webpack_require_198__.n = function (module) {
    /******/var getter = module && module.__esModule ? /******/function getDefault() {
      return module['default'];
    } : /******/function getModuleExports() {
      return module;
    };
    /******/
    __nested_webpack_require_198__.d(getter, 'a', getter);
    /******/
    return getter;
    /******/
  };
  /******/
  /******/ // Object.prototype.hasOwnProperty.call
  /******/
  __nested_webpack_require_198__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/
  /******/ // __webpack_public_path__
  /******/
  __nested_webpack_require_198__.p = "/dist/";
  /******/
  /******/
  /******/ // Load entry module and return exports
  /******/
  return __nested_webpack_require_198__(__nested_webpack_require_198__.s = 91);
  /******/
}
/************************************************************************/
/******/({
  /***/0: /***/function (module, __nested_webpack_exports__, __nested_webpack_require_4030__) {
    "use strict";

    /* harmony export (binding) */
    __nested_webpack_require_4030__.d(__nested_webpack_exports__, "a", function () {
      return normalizeComponent;
    });
    /* globals __VUE_SSR_CONTEXT__ */

    // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
    // This module is a runtime utility for cleaner component module output and will
    // be included in the final webpack user bundle.

    function normalizeComponent(scriptExports, render, staticRenderFns, functionalTemplate, injectStyles, scopeId, moduleIdentifier, /* server only */
    shadowMode /* vue-cli only */) {
      // Vue.extend constructor export interop
      var options = typeof scriptExports === 'function' ? scriptExports.options : scriptExports;

      // render functions
      if (render) {
        options.render = render;
        options.staticRenderFns = staticRenderFns;
        options._compiled = true;
      }

      // functional template
      if (functionalTemplate) {
        options.functional = true;
      }

      // scopedId
      if (scopeId) {
        options._scopeId = 'data-v-' + scopeId;
      }
      var hook;
      if (moduleIdentifier) {
        // server build
        hook = function (context) {
          // 2.3 injection
          context = context ||
          // cached call
          this.$vnode && this.$vnode.ssrContext ||
          // stateful
          this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
          // 2.2 with runInNewContext: true
          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
            context = __VUE_SSR_CONTEXT__;
          }
          // inject component styles
          if (injectStyles) {
            injectStyles.call(this, context);
          }
          // register component module identifier for async chunk inferrence
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
      } else if (injectStyles) {
        hook = shadowMode ? function () {
          injectStyles.call(this, this.$root.$options.shadowRoot);
        } : injectStyles;
      }
      if (hook) {
        if (options.functional) {
          // for template-only hot-reload because in that case the render fn doesn't
          // go through the normalizer
          options._injectStyles = hook;
          // register for functioal component in vue file
          var originalRender = options.render;
          options.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = options.beforeCreate;
          options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
      return {
        exports: scriptExports,
        options: options
      };
    }

    /***/
  },

  /***/4: /***/function (module, exports) {
    module.exports = __webpack_require__(969);

    /***/
  },

  /***/91: /***/function (module, __nested_webpack_exports__, __nested_webpack_require_7358__) {
    "use strict";

    __nested_webpack_require_7358__.r(__nested_webpack_exports__);

    // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox.vue?vue&type=template&id=d0387074&
    var render = function () {
      var _vm = this;
      var _h = _vm.$createElement;
      var _c = _vm._self._c || _h;
      return _c("label", {
        staticClass: "el-checkbox",
        class: [_vm.border && _vm.checkboxSize ? "el-checkbox--" + _vm.checkboxSize : "", {
          "is-disabled": _vm.isDisabled
        }, {
          "is-bordered": _vm.border
        }, {
          "is-checked": _vm.isChecked
        }],
        attrs: {
          id: _vm.id
        }
      }, [_c("span", {
        staticClass: "el-checkbox__input",
        class: {
          "is-disabled": _vm.isDisabled,
          "is-checked": _vm.isChecked,
          "is-indeterminate": _vm.indeterminate,
          "is-focus": _vm.focus
        },
        attrs: {
          tabindex: _vm.indeterminate ? 0 : false,
          role: _vm.indeterminate ? "checkbox" : false,
          "aria-checked": _vm.indeterminate ? "mixed" : false
        }
      }, [_c("span", {
        staticClass: "el-checkbox__inner"
      }), _vm.trueLabel || _vm.falseLabel ? _c("input", {
        directives: [{
          name: "model",
          rawName: "v-model",
          value: _vm.model,
          expression: "model"
        }],
        staticClass: "el-checkbox__original",
        attrs: {
          type: "checkbox",
          "aria-hidden": _vm.indeterminate ? "true" : "false",
          name: _vm.name,
          disabled: _vm.isDisabled,
          "true-value": _vm.trueLabel,
          "false-value": _vm.falseLabel
        },
        domProps: {
          checked: Array.isArray(_vm.model) ? _vm._i(_vm.model, null) > -1 : _vm._q(_vm.model, _vm.trueLabel)
        },
        on: {
          change: [function ($event) {
            var $$a = _vm.model,
              $$el = $event.target,
              $$c = $$el.checked ? _vm.trueLabel : _vm.falseLabel;
            if (Array.isArray($$a)) {
              var $$v = null,
                $$i = _vm._i($$a, $$v);
              if ($$el.checked) {
                $$i < 0 && (_vm.model = $$a.concat([$$v]));
              } else {
                $$i > -1 && (_vm.model = $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
              }
            } else {
              _vm.model = $$c;
            }
          }, _vm.handleChange],
          focus: function ($event) {
            _vm.focus = true;
          },
          blur: function ($event) {
            _vm.focus = false;
          }
        }
      }) : _c("input", {
        directives: [{
          name: "model",
          rawName: "v-model",
          value: _vm.model,
          expression: "model"
        }],
        staticClass: "el-checkbox__original",
        attrs: {
          type: "checkbox",
          "aria-hidden": _vm.indeterminate ? "true" : "false",
          disabled: _vm.isDisabled,
          name: _vm.name
        },
        domProps: {
          value: _vm.label,
          checked: Array.isArray(_vm.model) ? _vm._i(_vm.model, _vm.label) > -1 : _vm.model
        },
        on: {
          change: [function ($event) {
            var $$a = _vm.model,
              $$el = $event.target,
              $$c = $$el.checked ? true : false;
            if (Array.isArray($$a)) {
              var $$v = _vm.label,
                $$i = _vm._i($$a, $$v);
              if ($$el.checked) {
                $$i < 0 && (_vm.model = $$a.concat([$$v]));
              } else {
                $$i > -1 && (_vm.model = $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
              }
            } else {
              _vm.model = $$c;
            }
          }, _vm.handleChange],
          focus: function ($event) {
            _vm.focus = true;
          },
          blur: function ($event) {
            _vm.focus = false;
          }
        }
      })]), _vm.$slots.default || _vm.label ? _c("span", {
        staticClass: "el-checkbox__label"
      }, [_vm._t("default"), !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e()], 2) : _vm._e()]);
    };
    var staticRenderFns = [];
    render._withStripped = true;

    // CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue?vue&type=template&id=d0387074&

    // EXTERNAL MODULE: external "element-ui/lib/mixins/emitter"
    var emitter_ = __nested_webpack_require_7358__(4);
    var emitter_default = /*#__PURE__*/__nested_webpack_require_7358__.n(emitter_);

    // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox.vue?vue&type=script&lang=js&
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //

    /* harmony default export */
    var checkboxvue_type_script_lang_js_ = {
      name: 'ElCheckbox',
      mixins: [emitter_default.a],
      inject: {
        elForm: {
          default: ''
        },
        elFormItem: {
          default: ''
        }
      },
      componentName: 'ElCheckbox',
      data: function data() {
        return {
          selfModel: false,
          focus: false,
          isLimitExceeded: false
        };
      },
      computed: {
        model: {
          get: function get() {
            return this.isGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
          },
          set: function set(val) {
            if (this.isGroup) {
              this.isLimitExceeded = false;
              this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (this.isLimitExceeded = true);
              this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (this.isLimitExceeded = true);
              this.isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
            } else {
              this.$emit('input', val);
              this.selfModel = val;
            }
          }
        },
        isChecked: function isChecked() {
          if ({}.toString.call(this.model) === '[object Boolean]') {
            return this.model;
          } else if (Array.isArray(this.model)) {
            return this.model.indexOf(this.label) > -1;
          } else if (this.model !== null && this.model !== undefined) {
            return this.model === this.trueLabel;
          }
        },
        isGroup: function isGroup() {
          var parent = this.$parent;
          while (parent) {
            if (parent.$options.componentName !== 'ElCheckboxGroup') {
              parent = parent.$parent;
            } else {
              this._checkboxGroup = parent;
              return true;
            }
          }
          return false;
        },
        store: function store() {
          return this._checkboxGroup ? this._checkboxGroup.value : this.value;
        },
        /* used to make the isDisabled judgment under max/min props */
        isLimitDisabled: function isLimitDisabled() {
          var _checkboxGroup = this._checkboxGroup,
            max = _checkboxGroup.max,
            min = _checkboxGroup.min;
          return !!(max || min) && this.model.length >= max && !this.isChecked || this.model.length <= min && this.isChecked;
        },
        isDisabled: function isDisabled() {
          return this.isGroup ? this._checkboxGroup.disabled || this.disabled || (this.elForm || {}).disabled || this.isLimitDisabled : this.disabled || (this.elForm || {}).disabled;
        },
        _elFormItemSize: function _elFormItemSize() {
          return (this.elFormItem || {}).elFormItemSize;
        },
        checkboxSize: function checkboxSize() {
          var temCheckboxSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
          return this.isGroup ? this._checkboxGroup.checkboxGroupSize || temCheckboxSize : temCheckboxSize;
        }
      },
      props: {
        value: {},
        label: {},
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: String,
        trueLabel: [String, Number],
        falseLabel: [String, Number],
        id: String,
        /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*/
        controls: String,
        /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*/
        border: Boolean,
        size: String
      },
      methods: {
        addToStore: function addToStore() {
          if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
            this.model.push(this.label);
          } else {
            this.model = this.trueLabel || true;
          }
        },
        handleChange: function handleChange(ev) {
          var _this = this;
          if (this.isLimitExceeded) return;
          var value = void 0;
          if (ev.target.checked) {
            value = this.trueLabel === undefined ? true : this.trueLabel;
          } else {
            value = this.falseLabel === undefined ? false : this.falseLabel;
          }
          this.$emit('change', value, ev);
          this.$nextTick(function () {
            if (_this.isGroup) {
              _this.dispatch('ElCheckboxGroup', 'change', [_this._checkboxGroup.value]);
            }
          });
        }
      },
      created: function created() {
        this.checked && this.addToStore();
      },
      mounted: function mounted() {
        // 为indeterminate元素 添加aria-controls 属性
        if (this.indeterminate) {
          this.$el.setAttribute('aria-controls', this.controls);
        }
      },
      watch: {
        value: function value(_value) {
          this.dispatch('ElFormItem', 'el.form.change', _value);
        }
      }
    };
    // CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue?vue&type=script&lang=js&
    /* harmony default export */
    var src_checkboxvue_type_script_lang_js_ = checkboxvue_type_script_lang_js_;
    // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
    var componentNormalizer = __nested_webpack_require_7358__(0);

    // CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue

    /* normalize component */

    var component = Object(componentNormalizer["a" /* default */])(src_checkboxvue_type_script_lang_js_, render, staticRenderFns, false, null, null, null);

    /* hot reload */
    if (false) { var api; }
    component.options.__file = "packages/checkbox/src/checkbox.vue";
    /* harmony default export */
    var src_checkbox = component.exports;
    // CONCATENATED MODULE: ./packages/checkbox/index.js

    /* istanbul ignore next */
    src_checkbox.install = function (Vue) {
      Vue.component(src_checkbox.name, src_checkbox);
    };

    /* harmony default export */
    var packages_checkbox = __nested_webpack_exports__["default"] = src_checkbox;

    /***/
  }

  /******/
});

/***/ }),

/***/ 221:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
exports["default"] = function (Vue) {
  /**
   * template
   *
   * @param {String} string
   * @param {Array} ...args
   * @return {String}
   */

  function template(string) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (args.length === 1 && _typeof(args[0]) === 'object') {
      args = args[0];
    }
    if (!args || !args.hasOwnProperty) {
      args = {};
    }
    return string.replace(RE_NARGS, function (match, prefix, i, index) {
      var result = void 0;
      if (string[index - 1] === '{' && string[index + match.length] === '}') {
        return i;
      } else {
        result = (0, _util.hasOwn)(args, i) ? args[i] : null;
        if (result === null || result === undefined) {
          return '';
        }
        return result;
      }
    });
  }
  return template;
};
var _util = __webpack_require__(125);
var RE_NARGS = /(%|)\{([0-9a-zA-Z_]+)\}/g;
/**
 *  String format template
 *  - Inspired:
 *    https://github.com/Matt-Esch/string-template/index.js
 */

/***/ }),

/***/ 45:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.i18n = exports.use = exports.t = undefined;
var _zhCN = __webpack_require__(610);
var _zhCN2 = _interopRequireDefault(_zhCN);
var _vue = __webpack_require__(203);
var _vue2 = _interopRequireDefault(_vue);
var _deepmerge = __webpack_require__(933);
var _deepmerge2 = _interopRequireDefault(_deepmerge);
var _format = __webpack_require__(221);
var _format2 = _interopRequireDefault(_format);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var format = (0, _format2.default)(_vue2.default);
var lang = _zhCN2.default;
var merged = false;
var i18nHandler = function i18nHandler() {
  var vuei18n = Object.getPrototypeOf(this || _vue2.default).$t;
  if (typeof vuei18n === 'function' && !!_vue2.default.locale) {
    if (!merged) {
      merged = true;
      _vue2.default.locale(_vue2.default.config.lang, (0, _deepmerge2.default)(lang, _vue2.default.locale(_vue2.default.config.lang) || {}, {
        clone: true
      }));
    }
    return vuei18n.apply(this, arguments);
  }
};
var t = exports.t = function t(path, options) {
  var value = i18nHandler.apply(this, arguments);
  if (value !== null && value !== undefined) return value;
  var array = path.split('.');
  var current = lang;
  for (var i = 0, j = array.length; i < j; i++) {
    var property = array[i];
    value = current[property];
    if (i === j - 1) return format(value, options);
    if (!value) return '';
    current = value;
  }
  return '';
};
var use = exports.use = function use(l) {
  lang = l || lang;
};
var i18n = exports.i18n = function i18n(fn) {
  i18nHandler = fn || i18nHandler;
};
exports["default"] = {
  use: use,
  t: t,
  i18n: i18n
};

/***/ }),

/***/ 610:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.__esModule = true;
exports["default"] = {
  el: {
    colorpicker: {
      confirm: '确定',
      clear: '清空'
    },
    datepicker: {
      now: '此刻',
      today: '今天',
      cancel: '取消',
      clear: '清空',
      confirm: '确定',
      selectDate: '选择日期',
      selectTime: '选择时间',
      startDate: '开始日期',
      startTime: '开始时间',
      endDate: '结束日期',
      endTime: '结束时间',
      prevYear: '前一年',
      nextYear: '后一年',
      prevMonth: '上个月',
      nextMonth: '下个月',
      year: '年',
      month1: '1 月',
      month2: '2 月',
      month3: '3 月',
      month4: '4 月',
      month5: '5 月',
      month6: '6 月',
      month7: '7 月',
      month8: '8 月',
      month9: '9 月',
      month10: '10 月',
      month11: '11 月',
      month12: '12 月',
      // week: '周次',
      weeks: {
        sun: '日',
        mon: '一',
        tue: '二',
        wed: '三',
        thu: '四',
        fri: '五',
        sat: '六'
      },
      months: {
        jan: '一月',
        feb: '二月',
        mar: '三月',
        apr: '四月',
        may: '五月',
        jun: '六月',
        jul: '七月',
        aug: '八月',
        sep: '九月',
        oct: '十月',
        nov: '十一月',
        dec: '十二月'
      }
    },
    select: {
      loading: '加载中',
      noMatch: '无匹配数据',
      noData: '无数据',
      placeholder: '请选择'
    },
    cascader: {
      noMatch: '无匹配数据',
      loading: '加载中',
      placeholder: '请选择',
      noData: '暂无数据'
    },
    pagination: {
      goto: '前往',
      pagesize: '条/页',
      total: '共 {total} 条',
      pageClassifier: '页'
    },
    messagebox: {
      title: '提示',
      confirm: '确定',
      cancel: '取消',
      error: '输入的数据不合法!'
    },
    upload: {
      deleteTip: '按 delete 键可删除',
      delete: '删除',
      preview: '查看图片',
      continue: '继续上传'
    },
    table: {
      emptyText: '暂无数据',
      confirmFilter: '筛选',
      resetFilter: '重置',
      clearFilter: '全部',
      sumText: '合计'
    },
    tree: {
      emptyText: '暂无数据'
    },
    transfer: {
      noMatch: '无匹配数据',
      noData: '无数据',
      titles: ['列表 1', '列表 2'],
      filterPlaceholder: '请输入搜索内容',
      noCheckedFormat: '共 {total} 项',
      hasCheckedFormat: '已选 {checked}/{total} 项'
    },
    image: {
      error: '加载失败'
    },
    pageHeader: {
      title: '返回'
    },
    popconfirm: {
      confirmButtonText: '确定',
      cancelButtonText: '取消'
    },
    empty: {
      description: '暂无数据'
    }
  }
};

/***/ }),

/***/ 969:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.__esModule = true;
function _broadcast(componentName, eventName, params) {
  this.$children.forEach(function (child) {
    var name = child.$options.componentName;
    if (name === componentName) {
      child.$emit.apply(child, [eventName].concat(params));
    } else {
      _broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}
exports["default"] = {
  methods: {
    dispatch: function dispatch(componentName, eventName, params) {
      var parent = this.$parent || this.$root;
      var name = parent.$options.componentName;
      while (parent && (!name || name !== componentName)) {
        parent = parent.$parent;
        if (parent) {
          name = parent.$options.componentName;
        }
      }
      if (parent) {
        parent.$emit.apply(parent, [eventName].concat(params));
      }
    },
    broadcast: function broadcast(componentName, eventName, params) {
      _broadcast.call(this, componentName, eventName, params);
    }
  }
};

/***/ }),

/***/ 694:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var _locale = __webpack_require__(45);
exports["default"] = {
  methods: {
    t: function t() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _locale.t.apply(this, args);
    }
  }
};

/***/ }),

/***/ 63:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var _util = __webpack_require__(125);

/**
 * Show migrating guide in browser console.
 *
 * Usage:
 * import Migrating from 'element-ui/src/mixins/migrating';
 *
 * mixins: [Migrating]
 *
 * add getMigratingConfig method for your component.
 *  getMigratingConfig() {
 *    return {
 *      props: {
 *        'allow-no-selection': 'allow-no-selection is removed.',
 *        'selection-mode': 'selection-mode is removed.'
 *      },
 *      events: {
 *        selectionchange: 'selectionchange is renamed to selection-change.'
 *      }
 *    };
 *  },
 */
exports["default"] = {
  mounted: function mounted() {
    if (true) return;
    if (!this.$vnode) return;
    var _getMigratingConfig = this.getMigratingConfig(),
      _getMigratingConfig$p = _getMigratingConfig.props,
      props = _getMigratingConfig$p === undefined ? {} : _getMigratingConfig$p,
      _getMigratingConfig$e = _getMigratingConfig.events,
      events = _getMigratingConfig$e === undefined ? {} : _getMigratingConfig$e;
    var _$vnode = this.$vnode,
      data = _$vnode.data,
      componentOptions = _$vnode.componentOptions;
    var definedProps = data.attrs || {};
    var definedEvents = componentOptions.listeners || {};
    for (var propName in definedProps) {
      propName = (0, _util.kebabCase)(propName); // compatible with camel case
      if (props[propName]) {
        console.warn('[Element Migrating][' + this.$options.name + '][Attribute]: ' + props[propName]);
      }
    }
    for (var eventName in definedEvents) {
      eventName = (0, _util.kebabCase)(eventName); // compatible with camel case
      if (events[eventName]) {
        console.warn('[Element Migrating][' + this.$options.name + '][Event]: ' + events[eventName]);
      }
    }
  },
  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {},
        events: {}
      };
    }
  }
};

/***/ }),

/***/ 146:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = /******/function (modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/
  var installedModules = {};
  /******/
  /******/ // The require function
  /******/
  function __nested_webpack_require_198__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/if (installedModules[moduleId]) {
      /******/return installedModules[moduleId].exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/
    var module = installedModules[moduleId] = {
      /******/i: moduleId,
      /******/l: false,
      /******/exports: {}
      /******/
    };
    /******/
    /******/ // Execute the module function
    /******/
    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_198__);
    /******/
    /******/ // Flag the module as loaded
    /******/
    module.l = true;
    /******/
    /******/ // Return the exports of the module
    /******/
    return module.exports;
    /******/
  }
  /******/
  /******/
  /******/ // expose the modules object (__webpack_modules__)
  /******/
  __nested_webpack_require_198__.m = modules;
  /******/
  /******/ // expose the module cache
  /******/
  __nested_webpack_require_198__.c = installedModules;
  /******/
  /******/ // define getter function for harmony exports
  /******/
  __nested_webpack_require_198__.d = function (exports, name, getter) {
    /******/if (!__nested_webpack_require_198__.o(exports, name)) {
      /******/Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/
  };
  /******/
  /******/ // define __esModule on exports
  /******/
  __nested_webpack_require_198__.r = function (exports) {
    /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/
  /******/ // create a fake namespace object
  /******/ // mode & 1: value is a module id, require it
  /******/ // mode & 2: merge all properties of value into the ns
  /******/ // mode & 4: return value when already ns object
  /******/ // mode & 8|1: behave like require
  /******/
  __nested_webpack_require_198__.t = function (value, mode) {
    /******/if (mode & 1) value = __nested_webpack_require_198__(value);
    /******/
    if (mode & 8) return value;
    /******/
    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
    /******/
    var ns = Object.create(null);
    /******/
    __nested_webpack_require_198__.r(ns);
    /******/
    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/
    if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_198__.d(ns, key, function (key) {
      return value[key];
    }.bind(null, key));
    /******/
    return ns;
    /******/
  };
  /******/
  /******/ // getDefaultExport function for compatibility with non-harmony modules
  /******/
  __nested_webpack_require_198__.n = function (module) {
    /******/var getter = module && module.__esModule ? /******/function getDefault() {
      return module['default'];
    } : /******/function getModuleExports() {
      return module;
    };
    /******/
    __nested_webpack_require_198__.d(getter, 'a', getter);
    /******/
    return getter;
    /******/
  };
  /******/
  /******/ // Object.prototype.hasOwnProperty.call
  /******/
  __nested_webpack_require_198__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/
  /******/ // __webpack_public_path__
  /******/
  __nested_webpack_require_198__.p = "/dist/";
  /******/
  /******/
  /******/ // Load entry module and return exports
  /******/
  return __nested_webpack_require_198__(__nested_webpack_require_198__.s = 133);
  /******/
}
/************************************************************************/
/******/({
  /***/133: /***/function (module, __nested_webpack_exports__, __nested_webpack_require_4033__) {
    "use strict";

    __nested_webpack_require_4033__.r(__nested_webpack_exports__);

    // EXTERNAL MODULE: external "element-ui/lib/utils/resize-event"
    var resize_event_ = __nested_webpack_require_4033__(16);

    // EXTERNAL MODULE: external "element-ui/lib/utils/scrollbar-width"
    var scrollbar_width_ = __nested_webpack_require_4033__(39);
    var scrollbar_width_default = /*#__PURE__*/__nested_webpack_require_4033__.n(scrollbar_width_);

    // EXTERNAL MODULE: external "element-ui/lib/utils/util"
    var util_ = __nested_webpack_require_4033__(3);

    // EXTERNAL MODULE: external "element-ui/lib/utils/dom"
    var dom_ = __nested_webpack_require_4033__(2);

    // CONCATENATED MODULE: ./packages/scrollbar/src/util.js
    var BAR_MAP = {
      vertical: {
        offset: 'offsetHeight',
        scroll: 'scrollTop',
        scrollSize: 'scrollHeight',
        size: 'height',
        key: 'vertical',
        axis: 'Y',
        client: 'clientY',
        direction: 'top'
      },
      horizontal: {
        offset: 'offsetWidth',
        scroll: 'scrollLeft',
        scrollSize: 'scrollWidth',
        size: 'width',
        key: 'horizontal',
        axis: 'X',
        client: 'clientX',
        direction: 'left'
      }
    };
    function renderThumbStyle(_ref) {
      var move = _ref.move,
        size = _ref.size,
        bar = _ref.bar;
      var style = {};
      var translate = 'translate' + bar.axis + '(' + move + '%)';
      style[bar.size] = size;
      style.transform = translate;
      style.msTransform = translate;
      style.webkitTransform = translate;
      return style;
    }
    ;
    // CONCATENATED MODULE: ./packages/scrollbar/src/bar.js

    /* istanbul ignore next */
    /* harmony default export */
    var src_bar = {
      name: 'Bar',
      props: {
        vertical: Boolean,
        size: String,
        move: Number
      },
      computed: {
        bar: function bar() {
          return BAR_MAP[this.vertical ? 'vertical' : 'horizontal'];
        },
        wrap: function wrap() {
          return this.$parent.wrap;
        }
      },
      render: function render(h) {
        var size = this.size,
          move = this.move,
          bar = this.bar;
        return h('div', {
          'class': ['el-scrollbar__bar', 'is-' + bar.key],
          on: {
            'mousedown': this.clickTrackHandler
          }
        }, [h('div', {
          ref: 'thumb',
          'class': 'el-scrollbar__thumb',
          on: {
            'mousedown': this.clickThumbHandler
          },
          style: renderThumbStyle({
            size: size,
            move: move,
            bar: bar
          })
        })]);
      },
      methods: {
        clickThumbHandler: function clickThumbHandler(e) {
          // prevent click event of right button
          if (e.ctrlKey || e.button === 2) {
            return;
          }
          this.startDrag(e);
          this[this.bar.axis] = e.currentTarget[this.bar.offset] - (e[this.bar.client] - e.currentTarget.getBoundingClientRect()[this.bar.direction]);
        },
        clickTrackHandler: function clickTrackHandler(e) {
          var offset = Math.abs(e.target.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]);
          var thumbHalf = this.$refs.thumb[this.bar.offset] / 2;
          var thumbPositionPercentage = (offset - thumbHalf) * 100 / this.$el[this.bar.offset];
          this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
        },
        startDrag: function startDrag(e) {
          e.stopImmediatePropagation();
          this.cursorDown = true;
          Object(dom_["on"])(document, 'mousemove', this.mouseMoveDocumentHandler);
          Object(dom_["on"])(document, 'mouseup', this.mouseUpDocumentHandler);
          document.onselectstart = function () {
            return false;
          };
        },
        mouseMoveDocumentHandler: function mouseMoveDocumentHandler(e) {
          if (this.cursorDown === false) return;
          var prevPage = this[this.bar.axis];
          if (!prevPage) return;
          var offset = (this.$el.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]) * -1;
          var thumbClickPosition = this.$refs.thumb[this.bar.offset] - prevPage;
          var thumbPositionPercentage = (offset - thumbClickPosition) * 100 / this.$el[this.bar.offset];
          this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
        },
        mouseUpDocumentHandler: function mouseUpDocumentHandler(e) {
          this.cursorDown = false;
          this[this.bar.axis] = 0;
          Object(dom_["off"])(document, 'mousemove', this.mouseMoveDocumentHandler);
          document.onselectstart = null;
        }
      },
      destroyed: function destroyed() {
        Object(dom_["off"])(document, 'mouseup', this.mouseUpDocumentHandler);
      }
    };
    // CONCATENATED MODULE: ./packages/scrollbar/src/main.js
    // reference https://github.com/noeldelgado/gemini-scrollbar/blob/master/index.js

    /* istanbul ignore next */
    /* harmony default export */
    var main = {
      name: 'ElScrollbar',
      components: {
        Bar: src_bar
      },
      props: {
        native: Boolean,
        wrapStyle: {},
        wrapClass: {},
        viewClass: {},
        viewStyle: {},
        noresize: Boolean,
        // 如果 container 尺寸不会发生变化，最好设置它可以优化性能
        tag: {
          type: String,
          default: 'div'
        }
      },
      data: function data() {
        return {
          sizeWidth: '0',
          sizeHeight: '0',
          moveX: 0,
          moveY: 0
        };
      },
      computed: {
        wrap: function wrap() {
          return this.$refs.wrap;
        }
      },
      render: function render(h) {
        var gutter = scrollbar_width_default()();
        var style = this.wrapStyle;
        if (gutter) {
          var gutterWith = '-' + gutter + 'px';
          var gutterStyle = 'margin-bottom: ' + gutterWith + '; margin-right: ' + gutterWith + ';';
          if (Array.isArray(this.wrapStyle)) {
            style = Object(util_["toObject"])(this.wrapStyle);
            style.marginRight = style.marginBottom = gutterWith;
          } else if (typeof this.wrapStyle === 'string') {
            style += gutterStyle;
          } else {
            style = gutterStyle;
          }
        }
        var view = h(this.tag, {
          class: ['el-scrollbar__view', this.viewClass],
          style: this.viewStyle,
          ref: 'resize'
        }, this.$slots.default);
        var wrap = h('div', {
          ref: 'wrap',
          style: style,
          on: {
            'scroll': this.handleScroll
          },
          'class': [this.wrapClass, 'el-scrollbar__wrap', gutter ? '' : 'el-scrollbar__wrap--hidden-default']
        }, [[view]]);
        var nodes = void 0;
        if (!this.native) {
          nodes = [wrap, h(src_bar, {
            attrs: {
              move: this.moveX,
              size: this.sizeWidth
            }
          }), h(src_bar, {
            attrs: {
              vertical: true,
              move: this.moveY,
              size: this.sizeHeight
            }
          })];
        } else {
          nodes = [h('div', {
            ref: 'wrap',
            'class': [this.wrapClass, 'el-scrollbar__wrap'],
            style: style
          }, [[view]])];
        }
        return h('div', {
          class: 'el-scrollbar'
        }, nodes);
      },
      methods: {
        handleScroll: function handleScroll() {
          var wrap = this.wrap;
          this.moveY = wrap.scrollTop * 100 / wrap.clientHeight;
          this.moveX = wrap.scrollLeft * 100 / wrap.clientWidth;
        },
        update: function update() {
          var heightPercentage = void 0,
            widthPercentage = void 0;
          var wrap = this.wrap;
          if (!wrap) return;
          heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
          widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;
          this.sizeHeight = heightPercentage < 100 ? heightPercentage + '%' : '';
          this.sizeWidth = widthPercentage < 100 ? widthPercentage + '%' : '';
        }
      },
      mounted: function mounted() {
        if (this.native) return;
        this.$nextTick(this.update);
        !this.noresize && Object(resize_event_["addResizeListener"])(this.$refs.resize, this.update);
      },
      beforeDestroy: function beforeDestroy() {
        if (this.native) return;
        !this.noresize && Object(resize_event_["removeResizeListener"])(this.$refs.resize, this.update);
      }
    };
    // CONCATENATED MODULE: ./packages/scrollbar/index.js

    /* istanbul ignore next */
    main.install = function (Vue) {
      Vue.component(main.name, main);
    };

    /* harmony default export */
    var scrollbar = __nested_webpack_exports__["default"] = main;

    /***/
  },

  /***/16: /***/function (module, exports) {
    module.exports = __webpack_require__(268);

    /***/
  },

  /***/2: /***/function (module, exports) {
    module.exports = __webpack_require__(597);

    /***/
  },

  /***/3: /***/function (module, exports) {
    module.exports = __webpack_require__(125);

    /***/
  },

  /***/39: /***/function (module, exports) {
    module.exports = __webpack_require__(190);

    /***/
  }

  /******/
});

/***/ }),

/***/ 14:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = /******/function (modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/
  var installedModules = {};
  /******/
  /******/ // The require function
  /******/
  function __nested_webpack_require_198__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/if (installedModules[moduleId]) {
      /******/return installedModules[moduleId].exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/
    var module = installedModules[moduleId] = {
      /******/i: moduleId,
      /******/l: false,
      /******/exports: {}
      /******/
    };
    /******/
    /******/ // Execute the module function
    /******/
    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_198__);
    /******/
    /******/ // Flag the module as loaded
    /******/
    module.l = true;
    /******/
    /******/ // Return the exports of the module
    /******/
    return module.exports;
    /******/
  }
  /******/
  /******/
  /******/ // expose the modules object (__webpack_modules__)
  /******/
  __nested_webpack_require_198__.m = modules;
  /******/
  /******/ // expose the module cache
  /******/
  __nested_webpack_require_198__.c = installedModules;
  /******/
  /******/ // define getter function for harmony exports
  /******/
  __nested_webpack_require_198__.d = function (exports, name, getter) {
    /******/if (!__nested_webpack_require_198__.o(exports, name)) {
      /******/Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/
  };
  /******/
  /******/ // define __esModule on exports
  /******/
  __nested_webpack_require_198__.r = function (exports) {
    /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/
  /******/ // create a fake namespace object
  /******/ // mode & 1: value is a module id, require it
  /******/ // mode & 2: merge all properties of value into the ns
  /******/ // mode & 4: return value when already ns object
  /******/ // mode & 8|1: behave like require
  /******/
  __nested_webpack_require_198__.t = function (value, mode) {
    /******/if (mode & 1) value = __nested_webpack_require_198__(value);
    /******/
    if (mode & 8) return value;
    /******/
    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
    /******/
    var ns = Object.create(null);
    /******/
    __nested_webpack_require_198__.r(ns);
    /******/
    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/
    if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_198__.d(ns, key, function (key) {
      return value[key];
    }.bind(null, key));
    /******/
    return ns;
    /******/
  };
  /******/
  /******/ // getDefaultExport function for compatibility with non-harmony modules
  /******/
  __nested_webpack_require_198__.n = function (module) {
    /******/var getter = module && module.__esModule ? /******/function getDefault() {
      return module['default'];
    } : /******/function getModuleExports() {
      return module;
    };
    /******/
    __nested_webpack_require_198__.d(getter, 'a', getter);
    /******/
    return getter;
    /******/
  };
  /******/
  /******/ // Object.prototype.hasOwnProperty.call
  /******/
  __nested_webpack_require_198__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/
  /******/ // __webpack_public_path__
  /******/
  __nested_webpack_require_198__.p = "/dist/";
  /******/
  /******/
  /******/ // Load entry module and return exports
  /******/
  return __nested_webpack_require_198__(__nested_webpack_require_198__.s = 136);
  /******/
}
/************************************************************************/
/******/({
  /***/136: /***/function (module, __nested_webpack_exports__, __nested_webpack_require_4033__) {
    "use strict";

    __nested_webpack_require_4033__.r(__nested_webpack_exports__);

    // EXTERNAL MODULE: external "element-ui/lib/utils/util"
    var util_ = __nested_webpack_require_4033__(3);

    // CONCATENATED MODULE: ./packages/table/src/config.js

    var cellStarts = {
      default: {
        order: ''
      },
      selection: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: '',
        className: 'el-table-column--selection'
      },
      expand: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: ''
      },
      index: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: ''
      }
    };

    // 这些选项不应该被覆盖
    var cellForced = {
      selection: {
        renderHeader: function renderHeader(h, _ref) {
          var store = _ref.store;
          return h('el-checkbox', {
            attrs: {
              disabled: store.states.data && store.states.data.length === 0,
              indeterminate: store.states.selection.length > 0 && !this.isAllSelected,
              value: this.isAllSelected
            },
            on: {
              'input': this.toggleAllSelection
            }
          });
        },
        renderCell: function renderCell(h, _ref2) {
          var row = _ref2.row,
            column = _ref2.column,
            isSelected = _ref2.isSelected,
            store = _ref2.store,
            $index = _ref2.$index;
          return h('el-checkbox', {
            nativeOn: {
              'click': function click(event) {
                return event.stopPropagation();
              }
            },
            attrs: {
              value: isSelected,
              disabled: column.selectable ? !column.selectable.call(null, row, $index) : false
            },
            on: {
              'input': function input() {
                store.commit('rowSelectedChanged', row);
              }
            }
          });
        },
        sortable: false,
        resizable: false
      },
      index: {
        renderHeader: function renderHeader(h, _ref3) {
          var column = _ref3.column;
          return column.label || '#';
        },
        renderCell: function renderCell(h, _ref4) {
          var $index = _ref4.$index,
            column = _ref4.column;
          var i = $index + 1;
          var index = column.index;
          if (typeof index === 'number') {
            i = $index + index;
          } else if (typeof index === 'function') {
            i = index($index);
          }
          return h('div', [i]);
        },
        sortable: false
      },
      expand: {
        renderHeader: function renderHeader(h, _ref5) {
          var column = _ref5.column;
          return column.label || '';
        },
        renderCell: function renderCell(h, _ref6) {
          var row = _ref6.row,
            store = _ref6.store,
            isExpanded = _ref6.isExpanded;
          var classes = ['el-table__expand-icon'];
          if (isExpanded) {
            classes.push('el-table__expand-icon--expanded');
          }
          var callback = function callback(e) {
            e.stopPropagation();
            store.toggleRowExpansion(row);
          };
          return h('div', {
            'class': classes,
            on: {
              'click': callback
            }
          }, [h('i', {
            'class': 'el-icon el-icon-arrow-right'
          })]);
        },
        sortable: false,
        resizable: false,
        className: 'el-table__expand-column'
      }
    };
    function defaultRenderCell(h, _ref7) {
      var row = _ref7.row,
        column = _ref7.column,
        $index = _ref7.$index;
      var property = column.property;
      var value = property && Object(util_["getPropByPath"])(row, property).v;
      if (column && column.formatter) {
        return column.formatter(row, column, value, $index);
      }
      return value;
    }
    function treeCellPrefix(h, _ref8) {
      var row = _ref8.row,
        treeNode = _ref8.treeNode,
        store = _ref8.store;
      if (!treeNode) return null;
      var ele = [];
      var callback = function callback(e) {
        e.stopPropagation();
        store.loadOrToggle(row);
      };
      if (treeNode.indent) {
        ele.push(h('span', {
          'class': 'el-table__indent',
          style: {
            'padding-left': treeNode.indent + 'px'
          }
        }));
      }
      if (typeof treeNode.expanded === 'boolean' && !treeNode.noLazyChildren) {
        var expandClasses = ['el-table__expand-icon', treeNode.expanded ? 'el-table__expand-icon--expanded' : ''];
        var iconClasses = ['el-icon-arrow-right'];
        if (treeNode.loading) {
          iconClasses = ['el-icon-loading'];
        }
        ele.push(h('div', {
          'class': expandClasses,
          on: {
            'click': callback
          }
        }, [h('i', {
          'class': iconClasses
        })]));
      } else {
        ele.push(h('span', {
          'class': 'el-table__placeholder'
        }));
      }
      return ele;
    }
    // EXTERNAL MODULE: ./packages/table/src/util.js
    var util = __nested_webpack_require_4033__(8);

    // EXTERNAL MODULE: external "element-ui/lib/checkbox"
    var checkbox_ = __nested_webpack_require_4033__(18);
    var checkbox_default = /*#__PURE__*/__nested_webpack_require_4033__.n(checkbox_);

    // CONCATENATED MODULE: ./packages/table/src/table-column.js
    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var columnIdSeed = 1;

    /* harmony default export */
    var table_column = {
      name: 'ElTableColumn',
      props: {
        type: {
          type: String,
          default: 'default'
        },
        label: String,
        className: String,
        labelClassName: String,
        property: String,
        prop: String,
        width: {},
        minWidth: {},
        renderHeader: Function,
        sortable: {
          type: [Boolean, String],
          default: false
        },
        sortMethod: Function,
        sortBy: [String, Function, Array],
        resizable: {
          type: Boolean,
          default: true
        },
        columnKey: String,
        align: String,
        headerAlign: String,
        showTooltipWhenOverflow: Boolean,
        showOverflowTooltip: Boolean,
        fixed: [Boolean, String],
        formatter: Function,
        selectable: Function,
        reserveSelection: Boolean,
        filterMethod: Function,
        filteredValue: Array,
        filters: Array,
        filterPlacement: String,
        filterMultiple: {
          type: Boolean,
          default: true
        },
        index: [Number, Function],
        sortOrders: {
          type: Array,
          default: function _default() {
            return ['ascending', 'descending', null];
          },
          validator: function validator(val) {
            return val.every(function (order) {
              return ['ascending', 'descending', null].indexOf(order) > -1;
            });
          }
        }
      },
      data: function data() {
        return {
          isSubColumn: false,
          columns: []
        };
      },
      computed: {
        owner: function owner() {
          var parent = this.$parent;
          while (parent && !parent.tableId) {
            parent = parent.$parent;
          }
          return parent;
        },
        columnOrTableParent: function columnOrTableParent() {
          var parent = this.$parent;
          while (parent && !parent.tableId && !parent.columnId) {
            parent = parent.$parent;
          }
          return parent;
        },
        realWidth: function realWidth() {
          return Object(util["l" /* parseWidth */])(this.width);
        },
        realMinWidth: function realMinWidth() {
          return Object(util["k" /* parseMinWidth */])(this.minWidth);
        },
        realAlign: function realAlign() {
          return this.align ? 'is-' + this.align : null;
        },
        realHeaderAlign: function realHeaderAlign() {
          return this.headerAlign ? 'is-' + this.headerAlign : this.realAlign;
        }
      },
      methods: {
        getPropsData: function getPropsData() {
          var _this = this;
          for (var _len = arguments.length, props = Array(_len), _key = 0; _key < _len; _key++) {
            props[_key] = arguments[_key];
          }
          return props.reduce(function (prev, cur) {
            if (Array.isArray(cur)) {
              cur.forEach(function (key) {
                prev[key] = _this[key];
              });
            }
            return prev;
          }, {});
        },
        getColumnElIndex: function getColumnElIndex(children, child) {
          return [].indexOf.call(children, child);
        },
        setColumnWidth: function setColumnWidth(column) {
          if (this.realWidth) {
            column.width = this.realWidth;
          }
          if (this.realMinWidth) {
            column.minWidth = this.realMinWidth;
          }
          if (!column.minWidth) {
            column.minWidth = 80;
          }
          column.realWidth = column.width === undefined ? column.minWidth : column.width;
          return column;
        },
        setColumnForcedProps: function setColumnForcedProps(column) {
          // 对于特定类型的 column，某些属性不允许设置
          var type = column.type;
          var source = cellForced[type] || {};
          Object.keys(source).forEach(function (prop) {
            var value = source[prop];
            if (value !== undefined) {
              column[prop] = prop === 'className' ? column[prop] + ' ' + value : value;
            }
          });
          return column;
        },
        setColumnRenders: function setColumnRenders(column) {
          var _this2 = this;
          var h = this.$createElement;

          // renderHeader 属性不推荐使用。
          if (this.renderHeader) {
            console.warn('[Element Warn][TableColumn]Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.');
          } else if (column.type !== 'selection') {
            column.renderHeader = function (h, scope) {
              var renderHeader = _this2.$scopedSlots.header;
              return renderHeader ? renderHeader(scope) : column.label;
            };
          }
          var originRenderCell = column.renderCell;
          // TODO: 这里的实现调整
          if (column.type === 'expand') {
            // 对于展开行，renderCell 不允许配置的。在上一步中已经设置过，这里需要简单封装一下。
            column.renderCell = function (h, data) {
              return h('div', {
                'class': 'cell'
              }, [originRenderCell(h, data)]);
            };
            this.owner.renderExpanded = function (h, data) {
              return _this2.$scopedSlots.default ? _this2.$scopedSlots.default(data) : _this2.$slots.default;
            };
          } else {
            originRenderCell = originRenderCell || defaultRenderCell;
            // 对 renderCell 进行包装
            column.renderCell = function (h, data) {
              var children = null;
              if (_this2.$scopedSlots.default) {
                children = _this2.$scopedSlots.default(data);
              } else {
                children = originRenderCell(h, data);
              }
              var prefix = treeCellPrefix(h, data);
              var props = {
                class: 'cell',
                style: {}
              };
              if (column.showOverflowTooltip) {
                props.class += ' el-tooltip';
                props.style = {
                  width: (data.column.realWidth || data.column.width) - 1 + 'px'
                };
              }
              return h('div', props, [prefix, children]);
            };
          }
          return column;
        },
        registerNormalWatchers: function registerNormalWatchers() {
          var _this3 = this;
          var props = ['label', 'property', 'filters', 'filterMultiple', 'sortable', 'index', 'formatter', 'className', 'labelClassName', 'showOverflowTooltip'];
          // 一些属性具有别名
          var aliases = {
            prop: 'property',
            realAlign: 'align',
            realHeaderAlign: 'headerAlign',
            realWidth: 'width'
          };
          var allAliases = props.reduce(function (prev, cur) {
            prev[cur] = cur;
            return prev;
          }, aliases);
          Object.keys(allAliases).forEach(function (key) {
            var columnKey = aliases[key];
            _this3.$watch(key, function (newVal) {
              _this3.columnConfig[columnKey] = newVal;
            });
          });
        },
        registerComplexWatchers: function registerComplexWatchers() {
          var _this4 = this;
          var props = ['fixed'];
          var aliases = {
            realWidth: 'width',
            realMinWidth: 'minWidth'
          };
          var allAliases = props.reduce(function (prev, cur) {
            prev[cur] = cur;
            return prev;
          }, aliases);
          Object.keys(allAliases).forEach(function (key) {
            var columnKey = aliases[key];
            _this4.$watch(key, function (newVal) {
              _this4.columnConfig[columnKey] = newVal;
              var updateColumns = columnKey === 'fixed';
              _this4.owner.store.scheduleLayout(updateColumns);
            });
          });
        }
      },
      components: {
        ElCheckbox: checkbox_default.a
      },
      beforeCreate: function beforeCreate() {
        this.row = {};
        this.column = {};
        this.$index = 0;
        this.columnId = '';
      },
      created: function created() {
        var parent = this.columnOrTableParent;
        this.isSubColumn = this.owner !== parent;
        this.columnId = (parent.tableId || parent.columnId) + '_column_' + columnIdSeed++;
        var type = this.type || 'default';
        var sortable = this.sortable === '' ? true : this.sortable;
        var defaults = _extends({}, cellStarts[type], {
          id: this.columnId,
          type: type,
          property: this.prop || this.property,
          align: this.realAlign,
          headerAlign: this.realHeaderAlign,
          showOverflowTooltip: this.showOverflowTooltip || this.showTooltipWhenOverflow,
          // filter 相关属性
          filterable: this.filters || this.filterMethod,
          filteredValue: [],
          filterPlacement: '',
          isColumnGroup: false,
          filterOpened: false,
          // sort 相关属性
          sortable: sortable,
          // index 列
          index: this.index
        });
        var basicProps = ['columnKey', 'label', 'className', 'labelClassName', 'type', 'renderHeader', 'formatter', 'fixed', 'resizable'];
        var sortProps = ['sortMethod', 'sortBy', 'sortOrders'];
        var selectProps = ['selectable', 'reserveSelection'];
        var filterProps = ['filterMethod', 'filters', 'filterMultiple', 'filterOpened', 'filteredValue', 'filterPlacement'];
        var column = this.getPropsData(basicProps, sortProps, selectProps, filterProps);
        column = Object(util["h" /* mergeOptions */])(defaults, column);

        // 注意 compose 中函数执行的顺序是从右到左
        var chains = Object(util["a" /* compose */])(this.setColumnRenders, this.setColumnWidth, this.setColumnForcedProps);
        column = chains(column);
        this.columnConfig = column;

        // 注册 watcher
        this.registerNormalWatchers();
        this.registerComplexWatchers();
      },
      mounted: function mounted() {
        var owner = this.owner;
        var parent = this.columnOrTableParent;
        var children = this.isSubColumn ? parent.$el.children : parent.$refs.hiddenColumns.children;
        var columnIndex = this.getColumnElIndex(children, this.$el);
        owner.store.commit('insertColumn', this.columnConfig, columnIndex, this.isSubColumn ? parent.columnConfig : null);
      },
      destroyed: function destroyed() {
        if (!this.$parent) return;
        var parent = this.$parent;
        this.owner.store.commit('removeColumn', this.columnConfig, this.isSubColumn ? parent.columnConfig : null);
      },
      render: function render(h) {
        // slots 也要渲染，需要计算合并表头
        return h('div', this.$slots.default);
      }
    };
    // CONCATENATED MODULE: ./packages/table-column/index.js

    /* istanbul ignore next */
    table_column.install = function (Vue) {
      Vue.component(table_column.name, table_column);
    };

    /* harmony default export */
    var packages_table_column = __nested_webpack_exports__["default"] = table_column;

    /***/
  },

  /***/18: /***/function (module, exports) {
    module.exports = __webpack_require__(284);

    /***/
  },

  /***/3: /***/function (module, exports) {
    module.exports = __webpack_require__(125);

    /***/
  },

  /***/8: /***/function (module, __nested_webpack_exports__, __nested_webpack_require_21241__) {
    "use strict";

    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "b", function () {
      return getCell;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "i", function () {
      return orderBy;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "d", function () {
      return getColumnById;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "e", function () {
      return getColumnByKey;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "c", function () {
      return getColumnByCell;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "g", function () {
      return getRowIdentity;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "f", function () {
      return getKeysMap;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "h", function () {
      return mergeOptions;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "l", function () {
      return parseWidth;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "k", function () {
      return parseMinWidth;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "j", function () {
      return parseHeight;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "a", function () {
      return compose;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "m", function () {
      return toggleRowStatus;
    });
    /* harmony export (binding) */
    __nested_webpack_require_21241__.d(__nested_webpack_exports__, "n", function () {
      return walkTreeNode;
    });
    /* harmony import */
    var element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_21241__(3);
    /* harmony import */
    var element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_21241__.n(element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__);
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var getCell = function getCell(event) {
      var cell = event.target;
      while (cell && cell.tagName.toUpperCase() !== 'HTML') {
        if (cell.tagName.toUpperCase() === 'TD') {
          return cell;
        }
        cell = cell.parentNode;
      }
      return null;
    };
    var isObject = function isObject(obj) {
      return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
    };
    var orderBy = function orderBy(array, sortKey, reverse, sortMethod, sortBy) {
      if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
        return array;
      }
      if (typeof reverse === 'string') {
        reverse = reverse === 'descending' ? -1 : 1;
      } else {
        reverse = reverse && reverse < 0 ? -1 : 1;
      }
      var getKey = sortMethod ? null : function (value, index) {
        if (sortBy) {
          if (!Array.isArray(sortBy)) {
            sortBy = [sortBy];
          }
          return sortBy.map(function (by) {
            if (typeof by === 'string') {
              return Object(element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__["getValueByPath"])(value, by);
            } else {
              return by(value, index, array);
            }
          });
        }
        if (sortKey !== '$key') {
          if (isObject(value) && '$value' in value) value = value.$value;
        }
        return [isObject(value) ? Object(element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__["getValueByPath"])(value, sortKey) : value];
      };
      var compare = function compare(a, b) {
        if (sortMethod) {
          return sortMethod(a.value, b.value);
        }
        for (var i = 0, len = a.key.length; i < len; i++) {
          if (a.key[i] < b.key[i]) {
            return -1;
          }
          if (a.key[i] > b.key[i]) {
            return 1;
          }
        }
        return 0;
      };
      return array.map(function (value, index) {
        return {
          value: value,
          index: index,
          key: getKey ? getKey(value, index) : null
        };
      }).sort(function (a, b) {
        var order = compare(a, b);
        if (!order) {
          // make stable https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
          order = a.index - b.index;
        }
        return order * reverse;
      }).map(function (item) {
        return item.value;
      });
    };
    var getColumnById = function getColumnById(table, columnId) {
      var column = null;
      table.columns.forEach(function (item) {
        if (item.id === columnId) {
          column = item;
        }
      });
      return column;
    };
    var getColumnByKey = function getColumnByKey(table, columnKey) {
      var column = null;
      for (var i = 0; i < table.columns.length; i++) {
        var item = table.columns[i];
        if (item.columnKey === columnKey) {
          column = item;
          break;
        }
      }
      return column;
    };
    var getColumnByCell = function getColumnByCell(table, cell) {
      var matches = (cell.className || '').match(/el-table_[^\s]+/gm);
      if (matches) {
        return getColumnById(table, matches[0]);
      }
      return null;
    };
    var getRowIdentity = function getRowIdentity(row, rowKey) {
      if (!row) throw new Error('row is required when get row identity');
      if (typeof rowKey === 'string') {
        if (rowKey.indexOf('.') < 0) {
          return row[rowKey];
        }
        var key = rowKey.split('.');
        var current = row;
        for (var i = 0; i < key.length; i++) {
          current = current[key[i]];
        }
        return current;
      } else if (typeof rowKey === 'function') {
        return rowKey.call(null, row);
      }
    };
    var getKeysMap = function getKeysMap(array, rowKey) {
      var arrayMap = {};
      (array || []).forEach(function (row, index) {
        arrayMap[getRowIdentity(row, rowKey)] = {
          row: row,
          index: index
        };
      });
      return arrayMap;
    };
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    function mergeOptions(defaults, config) {
      var options = {};
      var key = void 0;
      for (key in defaults) {
        options[key] = defaults[key];
      }
      for (key in config) {
        if (hasOwn(config, key)) {
          var value = config[key];
          if (typeof value !== 'undefined') {
            options[key] = value;
          }
        }
      }
      return options;
    }
    function parseWidth(width) {
      if (width !== undefined) {
        width = parseInt(width, 10);
        if (isNaN(width)) {
          width = null;
        }
      }
      return width;
    }
    function parseMinWidth(minWidth) {
      if (typeof minWidth !== 'undefined') {
        minWidth = parseWidth(minWidth);
        if (isNaN(minWidth)) {
          minWidth = 80;
        }
      }
      return minWidth;
    }
    ;
    function parseHeight(height) {
      if (typeof height === 'number') {
        return height;
      }
      if (typeof height === 'string') {
        if (/^\d+(?:px)?$/.test(height)) {
          return parseInt(height, 10);
        } else {
          return height;
        }
      }
      return null;
    }

    // https://github.com/reduxjs/redux/blob/master/src/compose.js
    function compose() {
      for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
        funcs[_key] = arguments[_key];
      }
      if (funcs.length === 0) {
        return function (arg) {
          return arg;
        };
      }
      if (funcs.length === 1) {
        return funcs[0];
      }
      return funcs.reduce(function (a, b) {
        return function () {
          return a(b.apply(undefined, arguments));
        };
      });
    }
    function toggleRowStatus(statusArr, row, newVal) {
      var changed = false;
      var index = statusArr.indexOf(row);
      var included = index !== -1;
      var addRow = function addRow() {
        statusArr.push(row);
        changed = true;
      };
      var removeRow = function removeRow() {
        statusArr.splice(index, 1);
        changed = true;
      };
      if (typeof newVal === 'boolean') {
        if (newVal && !included) {
          addRow();
        } else if (!newVal && included) {
          removeRow();
        }
      } else {
        if (included) {
          removeRow();
        } else {
          addRow();
        }
      }
      return changed;
    }
    function walkTreeNode(root, cb) {
      var childrenKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'children';
      var lazyKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'hasChildren';
      var isNil = function isNil(array) {
        return !(Array.isArray(array) && array.length);
      };
      function _walker(parent, children, level) {
        cb(parent, children, level);
        children.forEach(function (item) {
          if (item[lazyKey]) {
            cb(item, null, level + 1);
            return;
          }
          var children = item[childrenKey];
          if (!isNil(children)) {
            _walker(item, children, level + 1);
          }
        });
      }
      root.forEach(function (item) {
        if (item[lazyKey]) {
          cb(item, null, 0);
          return;
        }
        var children = item[childrenKey];
        if (!isNil(children)) {
          _walker(item, children, 0);
        }
      });
    }

    /***/
  }

  /******/
});

/***/ }),

/***/ 562:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = /******/function (modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/
  var installedModules = {};
  /******/
  /******/ // The require function
  /******/
  function __nested_webpack_require_198__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/if (installedModules[moduleId]) {
      /******/return installedModules[moduleId].exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/
    var module = installedModules[moduleId] = {
      /******/i: moduleId,
      /******/l: false,
      /******/exports: {}
      /******/
    };
    /******/
    /******/ // Execute the module function
    /******/
    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_198__);
    /******/
    /******/ // Flag the module as loaded
    /******/
    module.l = true;
    /******/
    /******/ // Return the exports of the module
    /******/
    return module.exports;
    /******/
  }
  /******/
  /******/
  /******/ // expose the modules object (__webpack_modules__)
  /******/
  __nested_webpack_require_198__.m = modules;
  /******/
  /******/ // expose the module cache
  /******/
  __nested_webpack_require_198__.c = installedModules;
  /******/
  /******/ // define getter function for harmony exports
  /******/
  __nested_webpack_require_198__.d = function (exports, name, getter) {
    /******/if (!__nested_webpack_require_198__.o(exports, name)) {
      /******/Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/
  };
  /******/
  /******/ // define __esModule on exports
  /******/
  __nested_webpack_require_198__.r = function (exports) {
    /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/
  /******/ // create a fake namespace object
  /******/ // mode & 1: value is a module id, require it
  /******/ // mode & 2: merge all properties of value into the ns
  /******/ // mode & 4: return value when already ns object
  /******/ // mode & 8|1: behave like require
  /******/
  __nested_webpack_require_198__.t = function (value, mode) {
    /******/if (mode & 1) value = __nested_webpack_require_198__(value);
    /******/
    if (mode & 8) return value;
    /******/
    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
    /******/
    var ns = Object.create(null);
    /******/
    __nested_webpack_require_198__.r(ns);
    /******/
    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/
    if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_198__.d(ns, key, function (key) {
      return value[key];
    }.bind(null, key));
    /******/
    return ns;
    /******/
  };
  /******/
  /******/ // getDefaultExport function for compatibility with non-harmony modules
  /******/
  __nested_webpack_require_198__.n = function (module) {
    /******/var getter = module && module.__esModule ? /******/function getDefault() {
      return module['default'];
    } : /******/function getModuleExports() {
      return module;
    };
    /******/
    __nested_webpack_require_198__.d(getter, 'a', getter);
    /******/
    return getter;
    /******/
  };
  /******/
  /******/ // Object.prototype.hasOwnProperty.call
  /******/
  __nested_webpack_require_198__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/
  /******/ // __webpack_public_path__
  /******/
  __nested_webpack_require_198__.p = "/dist/";
  /******/
  /******/
  /******/ // Load entry module and return exports
  /******/
  return __nested_webpack_require_198__(__nested_webpack_require_198__.s = 58);
  /******/
}
/************************************************************************/
/******/([/* 0 */
/***/function (module, __nested_webpack_exports__, __nested_webpack_require_4027__) {
  "use strict";

  /* harmony export (binding) */
  __nested_webpack_require_4027__.d(__nested_webpack_exports__, "a", function () {
    return normalizeComponent;
  });
  /* globals __VUE_SSR_CONTEXT__ */

  // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
  // This module is a runtime utility for cleaner component module output and will
  // be included in the final webpack user bundle.

  function normalizeComponent(scriptExports, render, staticRenderFns, functionalTemplate, injectStyles, scopeId, moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */) {
    // Vue.extend constructor export interop
    var options = typeof scriptExports === 'function' ? scriptExports.options : scriptExports;

    // render functions
    if (render) {
      options.render = render;
      options.staticRenderFns = staticRenderFns;
      options._compiled = true;
    }

    // functional template
    if (functionalTemplate) {
      options.functional = true;
    }

    // scopedId
    if (scopeId) {
      options._scopeId = 'data-v-' + scopeId;
    }
    var hook;
    if (moduleIdentifier) {
      // server build
      hook = function (context) {
        // 2.3 injection
        context = context ||
        // cached call
        this.$vnode && this.$vnode.ssrContext ||
        // stateful
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
        // 2.2 with runInNewContext: true
        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        }
        // inject component styles
        if (injectStyles) {
          injectStyles.call(this, context);
        }
        // register component module identifier for async chunk inferrence
        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      };
      // used by ssr in case component is cached and beforeCreate
      // never gets called
      options._ssrRegister = hook;
    } else if (injectStyles) {
      hook = shadowMode ? function () {
        injectStyles.call(this, this.$root.$options.shadowRoot);
      } : injectStyles;
    }
    if (hook) {
      if (options.functional) {
        // for template-only hot-reload because in that case the render fn doesn't
        // go through the normalizer
        options._injectStyles = hook;
        // register for functioal component in vue file
        var originalRender = options.render;
        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        // inject component registration as beforeCreate hook
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
    return {
      exports: scriptExports,
      options: options
    };
  }

  /***/
},

  /* 1 */

  /* 4 */

  /* 10 */

  /* 14 */

  /* 17 */

  /* 20 */
  /* 21 */
  /* 22 */
  /* 23 */
  /* 24 */
  /* 25 */
  /* 26 */
  /* 27 */
  /* 28 */

  /* 30 */
  /* 31 */
  /* 32 */
  /* 33 */
  /* 34 */
  /* 35 */
  /* 36 */
  /* 37 */
  /* 38 */

  /* 41 */
  /* 42 */
  /* 43 */

  /* 45 */
  /* 46 */

  /* 48 */
  /* 49 */
  /* 50 */
  /* 51 */
  /* 52 */
  /* 53 */
  /* 54 */
  /* 55 */
  /* 56 */
  /* 57 */
, /* 2 */
/***/function (module, exports) {
  module.exports = __webpack_require__(597);

  /***/
}, /* 3 */
/***/function (module, exports) {
  module.exports = __webpack_require__(125);

  /***/
},, /* 5 */
/***/function (module, exports) {
  module.exports = __webpack_require__(617);

  /***/
}, /* 6 */
/***/function (module, exports) {
  module.exports = __webpack_require__(694);

  /***/
}, /* 7 */
/***/function (module, exports) {
  module.exports = __webpack_require__(203);

  /***/
}, /* 8 */
/***/function (module, __nested_webpack_exports__, __nested_webpack_require_8033__) {
  "use strict";

  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "b", function () {
    return getCell;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "i", function () {
    return orderBy;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "d", function () {
    return getColumnById;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "e", function () {
    return getColumnByKey;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "c", function () {
    return getColumnByCell;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "g", function () {
    return getRowIdentity;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "f", function () {
    return getKeysMap;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "h", function () {
    return mergeOptions;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "l", function () {
    return parseWidth;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "k", function () {
    return parseMinWidth;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "j", function () {
    return parseHeight;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "a", function () {
    return compose;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "m", function () {
    return toggleRowStatus;
  });
  /* harmony export (binding) */
  __nested_webpack_require_8033__.d(__nested_webpack_exports__, "n", function () {
    return walkTreeNode;
  });
  /* harmony import */
  var element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_8033__(3);
  /* harmony import */
  var element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_8033__.n(element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__);
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var getCell = function getCell(event) {
    var cell = event.target;
    while (cell && cell.tagName.toUpperCase() !== 'HTML') {
      if (cell.tagName.toUpperCase() === 'TD') {
        return cell;
      }
      cell = cell.parentNode;
    }
    return null;
  };
  var isObject = function isObject(obj) {
    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
  };
  var orderBy = function orderBy(array, sortKey, reverse, sortMethod, sortBy) {
    if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
      return array;
    }
    if (typeof reverse === 'string') {
      reverse = reverse === 'descending' ? -1 : 1;
    } else {
      reverse = reverse && reverse < 0 ? -1 : 1;
    }
    var getKey = sortMethod ? null : function (value, index) {
      if (sortBy) {
        if (!Array.isArray(sortBy)) {
          sortBy = [sortBy];
        }
        return sortBy.map(function (by) {
          if (typeof by === 'string') {
            return Object(element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__["getValueByPath"])(value, by);
          } else {
            return by(value, index, array);
          }
        });
      }
      if (sortKey !== '$key') {
        if (isObject(value) && '$value' in value) value = value.$value;
      }
      return [isObject(value) ? Object(element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__["getValueByPath"])(value, sortKey) : value];
    };
    var compare = function compare(a, b) {
      if (sortMethod) {
        return sortMethod(a.value, b.value);
      }
      for (var i = 0, len = a.key.length; i < len; i++) {
        if (a.key[i] < b.key[i]) {
          return -1;
        }
        if (a.key[i] > b.key[i]) {
          return 1;
        }
      }
      return 0;
    };
    return array.map(function (value, index) {
      return {
        value: value,
        index: index,
        key: getKey ? getKey(value, index) : null
      };
    }).sort(function (a, b) {
      var order = compare(a, b);
      if (!order) {
        // make stable https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
        order = a.index - b.index;
      }
      return order * reverse;
    }).map(function (item) {
      return item.value;
    });
  };
  var getColumnById = function getColumnById(table, columnId) {
    var column = null;
    table.columns.forEach(function (item) {
      if (item.id === columnId) {
        column = item;
      }
    });
    return column;
  };
  var getColumnByKey = function getColumnByKey(table, columnKey) {
    var column = null;
    for (var i = 0; i < table.columns.length; i++) {
      var item = table.columns[i];
      if (item.columnKey === columnKey) {
        column = item;
        break;
      }
    }
    return column;
  };
  var getColumnByCell = function getColumnByCell(table, cell) {
    var matches = (cell.className || '').match(/el-table_[^\s]+/gm);
    if (matches) {
      return getColumnById(table, matches[0]);
    }
    return null;
  };
  var getRowIdentity = function getRowIdentity(row, rowKey) {
    if (!row) throw new Error('row is required when get row identity');
    if (typeof rowKey === 'string') {
      if (rowKey.indexOf('.') < 0) {
        return row[rowKey];
      }
      var key = rowKey.split('.');
      var current = row;
      for (var i = 0; i < key.length; i++) {
        current = current[key[i]];
      }
      return current;
    } else if (typeof rowKey === 'function') {
      return rowKey.call(null, row);
    }
  };
  var getKeysMap = function getKeysMap(array, rowKey) {
    var arrayMap = {};
    (array || []).forEach(function (row, index) {
      arrayMap[getRowIdentity(row, rowKey)] = {
        row: row,
        index: index
      };
    });
    return arrayMap;
  };
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function mergeOptions(defaults, config) {
    var options = {};
    var key = void 0;
    for (key in defaults) {
      options[key] = defaults[key];
    }
    for (key in config) {
      if (hasOwn(config, key)) {
        var value = config[key];
        if (typeof value !== 'undefined') {
          options[key] = value;
        }
      }
    }
    return options;
  }
  function parseWidth(width) {
    if (width !== undefined) {
      width = parseInt(width, 10);
      if (isNaN(width)) {
        width = null;
      }
    }
    return width;
  }
  function parseMinWidth(minWidth) {
    if (typeof minWidth !== 'undefined') {
      minWidth = parseWidth(minWidth);
      if (isNaN(minWidth)) {
        minWidth = 80;
      }
    }
    return minWidth;
  }
  ;
  function parseHeight(height) {
    if (typeof height === 'number') {
      return height;
    }
    if (typeof height === 'string') {
      if (/^\d+(?:px)?$/.test(height)) {
        return parseInt(height, 10);
      } else {
        return height;
      }
    }
    return null;
  }

  // https://github.com/reduxjs/redux/blob/master/src/compose.js
  function compose() {
    for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }
    if (funcs.length === 0) {
      return function (arg) {
        return arg;
      };
    }
    if (funcs.length === 1) {
      return funcs[0];
    }
    return funcs.reduce(function (a, b) {
      return function () {
        return a(b.apply(undefined, arguments));
      };
    });
  }
  function toggleRowStatus(statusArr, row, newVal) {
    var changed = false;
    var index = statusArr.indexOf(row);
    var included = index !== -1;
    var addRow = function addRow() {
      statusArr.push(row);
      changed = true;
    };
    var removeRow = function removeRow() {
      statusArr.splice(index, 1);
      changed = true;
    };
    if (typeof newVal === 'boolean') {
      if (newVal && !included) {
        addRow();
      } else if (!newVal && included) {
        removeRow();
      }
    } else {
      if (included) {
        removeRow();
      } else {
        addRow();
      }
    }
    return changed;
  }
  function walkTreeNode(root, cb) {
    var childrenKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'children';
    var lazyKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'hasChildren';
    var isNil = function isNil(array) {
      return !(Array.isArray(array) && array.length);
    };
    function _walker(parent, children, level) {
      cb(parent, children, level);
      children.forEach(function (item) {
        if (item[lazyKey]) {
          cb(item, null, level + 1);
          return;
        }
        var children = item[childrenKey];
        if (!isNil(children)) {
          _walker(item, children, level + 1);
        }
      });
    }
    root.forEach(function (item) {
      if (item[lazyKey]) {
        cb(item, null, 0);
        return;
      }
      var children = item[childrenKey];
      if (!isNil(children)) {
        _walker(item, children, 0);
      }
    });
  }

  /***/
}, /* 9 */
/***/function (module, exports) {
  module.exports = __webpack_require__(186);

  /***/
},, /* 11 */
/***/function (module, exports) {
  module.exports = __webpack_require__(63);

  /***/
}, /* 12 */
/***/function (module, exports) {
  module.exports = __webpack_require__(486);

  /***/
}, /* 13 */
/***/function (module, exports) {
  module.exports = __webpack_require__(711);

  /***/
},, /* 15 */
/***/function (module, exports) {
  module.exports = __webpack_require__(146);

  /***/
}, /* 16 */
/***/function (module, exports) {
  module.exports = __webpack_require__(268);

  /***/
},, /* 18 */
/***/function (module, exports) {
  module.exports = __webpack_require__(284);

  /***/
}, /* 19 */
/***/function (module, exports) {
  module.exports = __webpack_require__(492);

  /***/
},,,,,,,,,, /* 29 */
/***/function (module, exports) {
  module.exports = __webpack_require__(849);

  /***/
},,,,,,,,,, /* 39 */
/***/function (module, exports) {
  module.exports = __webpack_require__(190);

  /***/
}, /* 40 */
/***/function (module, exports) {
  module.exports = __webpack_require__(132);

  /***/
},,,, /* 44 */
/***/function (module, exports) {
  module.exports = __webpack_require__(658);

  /***/
},,, /* 47 */
/***/function (module, exports) {
  module.exports = __webpack_require__(26);

  /***/
},,,,,,,,,,, /* 58 */
/***/function (module, __nested_webpack_exports__, __nested_webpack_require_19058__) {
  "use strict";

  __nested_webpack_require_19058__.r(__nested_webpack_exports__);

  // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/table.vue?vue&type=template&id=493fe34e&
  var render = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      staticClass: "el-table",
      class: [{
        "el-table--fit": _vm.fit,
        "el-table--striped": _vm.stripe,
        "el-table--border": _vm.border || _vm.isGroup,
        "el-table--hidden": _vm.isHidden,
        "el-table--group": _vm.isGroup,
        "el-table--fluid-height": _vm.maxHeight,
        "el-table--scrollable-x": _vm.layout.scrollX,
        "el-table--scrollable-y": _vm.layout.scrollY,
        "el-table--enable-row-hover": !_vm.store.states.isComplex,
        "el-table--enable-row-transition": (_vm.store.states.data || []).length !== 0 && (_vm.store.states.data || []).length < 100
      }, _vm.tableSize ? "el-table--" + _vm.tableSize : ""],
      on: {
        mouseleave: function ($event) {
          _vm.handleMouseLeave($event);
        }
      }
    }, [_c("div", {
      ref: "hiddenColumns",
      staticClass: "hidden-columns"
    }, [_vm._t("default")], 2), _vm.showHeader ? _c("div", {
      directives: [{
        name: "mousewheel",
        rawName: "v-mousewheel",
        value: _vm.handleHeaderFooterMousewheel,
        expression: "handleHeaderFooterMousewheel"
      }],
      ref: "headerWrapper",
      staticClass: "el-table__header-wrapper"
    }, [_c("table-header", {
      ref: "tableHeader",
      style: {
        width: _vm.layout.bodyWidth ? _vm.layout.bodyWidth + "px" : ""
      },
      attrs: {
        store: _vm.store,
        border: _vm.border,
        "default-sort": _vm.defaultSort
      }
    })], 1) : _vm._e(), _c("div", {
      ref: "bodyWrapper",
      staticClass: "el-table__body-wrapper",
      class: [_vm.layout.scrollX ? "is-scrolling-" + _vm.scrollPosition : "is-scrolling-none"],
      style: [_vm.bodyHeight]
    }, [_c("table-body", {
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        context: _vm.context,
        store: _vm.store,
        stripe: _vm.stripe,
        "row-class-name": _vm.rowClassName,
        "row-style": _vm.rowStyle,
        highlight: _vm.highlightCurrentRow
      }
    }), !_vm.data || _vm.data.length === 0 ? _c("div", {
      ref: "emptyBlock",
      staticClass: "el-table__empty-block",
      style: _vm.emptyBlockStyle
    }, [_c("span", {
      staticClass: "el-table__empty-text"
    }, [_vm._t("empty", [_vm._v(_vm._s(_vm.emptyText || _vm.t("el.table.emptyText")))])], 2)]) : _vm._e(), _vm.$slots.append ? _c("div", {
      ref: "appendWrapper",
      staticClass: "el-table__append-wrapper"
    }, [_vm._t("append")], 2) : _vm._e()], 1), _vm.showSummary ? _c("div", {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.data && _vm.data.length > 0,
        expression: "data && data.length > 0"
      }, {
        name: "mousewheel",
        rawName: "v-mousewheel",
        value: _vm.handleHeaderFooterMousewheel,
        expression: "handleHeaderFooterMousewheel"
      }],
      ref: "footerWrapper",
      staticClass: "el-table__footer-wrapper"
    }, [_c("table-footer", {
      style: {
        width: _vm.layout.bodyWidth ? _vm.layout.bodyWidth + "px" : ""
      },
      attrs: {
        store: _vm.store,
        border: _vm.border,
        "sum-text": _vm.sumText || _vm.t("el.table.sumText"),
        "summary-method": _vm.summaryMethod,
        "default-sort": _vm.defaultSort
      }
    })], 1) : _vm._e(), _vm.fixedColumns.length > 0 ? _c("div", {
      directives: [{
        name: "mousewheel",
        rawName: "v-mousewheel",
        value: _vm.handleFixedMousewheel,
        expression: "handleFixedMousewheel"
      }],
      ref: "fixedWrapper",
      staticClass: "el-table__fixed",
      style: [{
        width: _vm.layout.fixedWidth ? _vm.layout.fixedWidth + "px" : ""
      }, _vm.fixedHeight]
    }, [_vm.showHeader ? _c("div", {
      ref: "fixedHeaderWrapper",
      staticClass: "el-table__fixed-header-wrapper"
    }, [_c("table-header", {
      ref: "fixedTableHeader",
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        fixed: "left",
        border: _vm.border,
        store: _vm.store
      }
    })], 1) : _vm._e(), _c("div", {
      ref: "fixedBodyWrapper",
      staticClass: "el-table__fixed-body-wrapper",
      style: [{
        top: _vm.layout.headerHeight + "px"
      }, _vm.fixedBodyHeight]
    }, [_c("table-body", {
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        fixed: "left",
        store: _vm.store,
        stripe: _vm.stripe,
        highlight: _vm.highlightCurrentRow,
        "row-class-name": _vm.rowClassName,
        "row-style": _vm.rowStyle
      }
    }), _vm.$slots.append ? _c("div", {
      staticClass: "el-table__append-gutter",
      style: {
        height: _vm.layout.appendHeight + "px"
      }
    }) : _vm._e()], 1), _vm.showSummary ? _c("div", {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.data && _vm.data.length > 0,
        expression: "data && data.length > 0"
      }],
      ref: "fixedFooterWrapper",
      staticClass: "el-table__fixed-footer-wrapper"
    }, [_c("table-footer", {
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        fixed: "left",
        border: _vm.border,
        "sum-text": _vm.sumText || _vm.t("el.table.sumText"),
        "summary-method": _vm.summaryMethod,
        store: _vm.store
      }
    })], 1) : _vm._e()]) : _vm._e(), _vm.rightFixedColumns.length > 0 ? _c("div", {
      directives: [{
        name: "mousewheel",
        rawName: "v-mousewheel",
        value: _vm.handleFixedMousewheel,
        expression: "handleFixedMousewheel"
      }],
      ref: "rightFixedWrapper",
      staticClass: "el-table__fixed-right",
      style: [{
        width: _vm.layout.rightFixedWidth ? _vm.layout.rightFixedWidth + "px" : "",
        right: _vm.layout.scrollY ? (_vm.border ? _vm.layout.gutterWidth : _vm.layout.gutterWidth || 0) + "px" : ""
      }, _vm.fixedHeight]
    }, [_vm.showHeader ? _c("div", {
      ref: "rightFixedHeaderWrapper",
      staticClass: "el-table__fixed-header-wrapper"
    }, [_c("table-header", {
      ref: "rightFixedTableHeader",
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        fixed: "right",
        border: _vm.border,
        store: _vm.store
      }
    })], 1) : _vm._e(), _c("div", {
      ref: "rightFixedBodyWrapper",
      staticClass: "el-table__fixed-body-wrapper",
      style: [{
        top: _vm.layout.headerHeight + "px"
      }, _vm.fixedBodyHeight]
    }, [_c("table-body", {
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        fixed: "right",
        store: _vm.store,
        stripe: _vm.stripe,
        "row-class-name": _vm.rowClassName,
        "row-style": _vm.rowStyle,
        highlight: _vm.highlightCurrentRow
      }
    }), _vm.$slots.append ? _c("div", {
      staticClass: "el-table__append-gutter",
      style: {
        height: _vm.layout.appendHeight + "px"
      }
    }) : _vm._e()], 1), _vm.showSummary ? _c("div", {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.data && _vm.data.length > 0,
        expression: "data && data.length > 0"
      }],
      ref: "rightFixedFooterWrapper",
      staticClass: "el-table__fixed-footer-wrapper"
    }, [_c("table-footer", {
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        fixed: "right",
        border: _vm.border,
        "sum-text": _vm.sumText || _vm.t("el.table.sumText"),
        "summary-method": _vm.summaryMethod,
        store: _vm.store
      }
    })], 1) : _vm._e()]) : _vm._e(), _vm.rightFixedColumns.length > 0 ? _c("div", {
      ref: "rightFixedPatch",
      staticClass: "el-table__fixed-right-patch",
      style: {
        width: _vm.layout.scrollY ? _vm.layout.gutterWidth + "px" : "0",
        height: _vm.layout.headerHeight + "px"
      }
    }) : _vm._e(), _c("div", {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.resizeProxyVisible,
        expression: "resizeProxyVisible"
      }],
      ref: "resizeProxy",
      staticClass: "el-table__column-resize-proxy"
    })]);
  };
  var staticRenderFns = [];
  render._withStripped = true;

  // CONCATENATED MODULE: ./packages/table/src/table.vue?vue&type=template&id=493fe34e&

  // EXTERNAL MODULE: external "element-ui/lib/checkbox"
  var checkbox_ = __nested_webpack_require_19058__(18);
  var checkbox_default = /*#__PURE__*/__nested_webpack_require_19058__.n(checkbox_);

  // EXTERNAL MODULE: external "throttle-debounce"
  var external_throttle_debounce_ = __nested_webpack_require_19058__(44);

  // EXTERNAL MODULE: external "element-ui/lib/utils/resize-event"
  var resize_event_ = __nested_webpack_require_19058__(16);

  // EXTERNAL MODULE: external "normalize-wheel"
  var external_normalize_wheel_ = __nested_webpack_require_19058__(47);
  var external_normalize_wheel_default = /*#__PURE__*/__nested_webpack_require_19058__.n(external_normalize_wheel_);

  // CONCATENATED MODULE: ./src/directives/mousewheel.js

  var isFirefox = typeof navigator !== 'undefined' && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
  var mousewheel_mousewheel = function mousewheel(element, callback) {
    if (element && element.addEventListener) {
      element.addEventListener(isFirefox ? 'DOMMouseScroll' : 'mousewheel', function (event) {
        var normalized = external_normalize_wheel_default()(event);
        callback && callback.apply(this, [event, normalized]);
      });
    }
  };

  /* harmony default export */
  var directives_mousewheel = {
    bind: function bind(el, binding) {
      mousewheel_mousewheel(el, binding.value);
    }
  };
  // EXTERNAL MODULE: external "element-ui/lib/mixins/locale"
  var locale_ = __nested_webpack_require_19058__(6);
  var locale_default = /*#__PURE__*/__nested_webpack_require_19058__.n(locale_);

  // EXTERNAL MODULE: external "element-ui/lib/mixins/migrating"
  var migrating_ = __nested_webpack_require_19058__(11);
  var migrating_default = /*#__PURE__*/__nested_webpack_require_19058__.n(migrating_);

  // EXTERNAL MODULE: external "vue"
  var external_vue_ = __nested_webpack_require_19058__(7);
  var external_vue_default = /*#__PURE__*/__nested_webpack_require_19058__.n(external_vue_);

  // EXTERNAL MODULE: external "element-ui/lib/utils/merge"
  var merge_ = __nested_webpack_require_19058__(9);
  var merge_default = /*#__PURE__*/__nested_webpack_require_19058__.n(merge_);

  // EXTERNAL MODULE: ./packages/table/src/util.js
  var util = __nested_webpack_require_19058__(8);

  // CONCATENATED MODULE: ./packages/table/src/store/expand.js

  /* harmony default export */
  var expand = {
    data: function data() {
      return {
        states: {
          defaultExpandAll: false,
          expandRows: []
        }
      };
    },
    methods: {
      updateExpandRows: function updateExpandRows() {
        var _states = this.states,
          _states$data = _states.data,
          data = _states$data === undefined ? [] : _states$data,
          rowKey = _states.rowKey,
          defaultExpandAll = _states.defaultExpandAll,
          expandRows = _states.expandRows;
        if (defaultExpandAll) {
          this.states.expandRows = data.slice();
        } else if (rowKey) {
          // TODO：这里的代码可以优化
          var expandRowsMap = Object(util["f" /* getKeysMap */])(expandRows, rowKey);
          this.states.expandRows = data.reduce(function (prev, row) {
            var rowId = Object(util["g" /* getRowIdentity */])(row, rowKey);
            var rowInfo = expandRowsMap[rowId];
            if (rowInfo) {
              prev.push(row);
            }
            return prev;
          }, []);
        } else {
          this.states.expandRows = [];
        }
      },
      toggleRowExpansion: function toggleRowExpansion(row, expanded) {
        var changed = Object(util["m" /* toggleRowStatus */])(this.states.expandRows, row, expanded);
        if (changed) {
          this.table.$emit('expand-change', row, this.states.expandRows.slice());
          this.scheduleLayout();
        }
      },
      setExpandRowKeys: function setExpandRowKeys(rowKeys) {
        this.assertRowKey();
        // TODO：这里的代码可以优化
        var _states2 = this.states,
          data = _states2.data,
          rowKey = _states2.rowKey;
        var keysMap = Object(util["f" /* getKeysMap */])(data, rowKey);
        this.states.expandRows = rowKeys.reduce(function (prev, cur) {
          var info = keysMap[cur];
          if (info) {
            prev.push(info.row);
          }
          return prev;
        }, []);
      },
      isRowExpanded: function isRowExpanded(row) {
        var _states3 = this.states,
          _states3$expandRows = _states3.expandRows,
          expandRows = _states3$expandRows === undefined ? [] : _states3$expandRows,
          rowKey = _states3.rowKey;
        if (rowKey) {
          var expandMap = Object(util["f" /* getKeysMap */])(expandRows, rowKey);
          return !!expandMap[Object(util["g" /* getRowIdentity */])(row, rowKey)];
        }
        return expandRows.indexOf(row) !== -1;
      }
    }
  };
  // EXTERNAL MODULE: external "element-ui/lib/utils/util"
  var util_ = __nested_webpack_require_19058__(3);

  // CONCATENATED MODULE: ./packages/table/src/store/current.js

  /* harmony default export */
  var current = {
    data: function data() {
      return {
        states: {
          // 不可响应的，设置 currentRowKey 时，data 不一定存在，也许无法算出正确的 currentRow
          // 把该值缓存一下，当用户点击修改 currentRow 时，把该值重置为 null
          _currentRowKey: null,
          currentRow: null
        }
      };
    },
    methods: {
      setCurrentRowKey: function setCurrentRowKey(key) {
        this.assertRowKey();
        this.states._currentRowKey = key;
        this.setCurrentRowByKey(key);
      },
      restoreCurrentRowKey: function restoreCurrentRowKey() {
        this.states._currentRowKey = null;
      },
      setCurrentRowByKey: function setCurrentRowByKey(key) {
        var states = this.states;
        var _states$data = states.data,
          data = _states$data === undefined ? [] : _states$data,
          rowKey = states.rowKey;
        var currentRow = null;
        if (rowKey) {
          currentRow = Object(util_["arrayFind"])(data, function (item) {
            return Object(util["g" /* getRowIdentity */])(item, rowKey) === key;
          });
        }
        states.currentRow = currentRow;
      },
      updateCurrentRow: function updateCurrentRow(currentRow) {
        var states = this.states,
          table = this.table;
        var oldCurrentRow = states.currentRow;
        if (currentRow && currentRow !== oldCurrentRow) {
          states.currentRow = currentRow;
          table.$emit('current-change', currentRow, oldCurrentRow);
          return;
        }
        if (!currentRow && oldCurrentRow) {
          states.currentRow = null;
          table.$emit('current-change', null, oldCurrentRow);
        }
      },
      updateCurrentRowData: function updateCurrentRowData() {
        var states = this.states,
          table = this.table;
        var rowKey = states.rowKey,
          _currentRowKey = states._currentRowKey;
        // data 为 null 时，解构时的默认值会被忽略

        var data = states.data || [];
        var oldCurrentRow = states.currentRow;

        // 当 currentRow 不在 data 中时尝试更新数据
        if (data.indexOf(oldCurrentRow) === -1 && oldCurrentRow) {
          if (rowKey) {
            var currentRowKey = Object(util["g" /* getRowIdentity */])(oldCurrentRow, rowKey);
            this.setCurrentRowByKey(currentRowKey);
          } else {
            states.currentRow = null;
          }
          if (states.currentRow === null) {
            table.$emit('current-change', null, oldCurrentRow);
          }
        } else if (_currentRowKey) {
          // 把初始时下设置的 rowKey 转化成 rowData
          this.setCurrentRowByKey(_currentRowKey);
          this.restoreCurrentRowKey();
        }
      }
    }
  };
  // CONCATENATED MODULE: ./packages/table/src/store/tree.js
  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };

  /* harmony default export */
  var tree = {
    data: function data() {
      return {
        states: {
          // defaultExpandAll 存在于 expand.js 中，这里不重复添加
          // 在展开行中，expandRowKeys 会被转化成 expandRows，expandRowKeys 这个属性只是记录了 TreeTable 行的展开
          // TODO: 拆分为独立的 TreeTable，统一用法
          expandRowKeys: [],
          treeData: {},
          indent: 16,
          lazy: false,
          lazyTreeNodeMap: {},
          lazyColumnIdentifier: 'hasChildren',
          childrenColumnName: 'children'
        }
      };
    },
    computed: {
      // 嵌入型的数据，watch 无法是检测到变化 https://github.com/ElemeFE/element/issues/14998
      // TODO: 使用 computed 解决该问题，是否会造成性能问题？
      // @return { id: { level, children } }
      normalizedData: function normalizedData() {
        if (!this.states.rowKey) return {};
        var data = this.states.data || [];
        return this.normalize(data);
      },
      // @return { id: { children } }
      // 针对懒加载的情形，不处理嵌套数据
      normalizedLazyNode: function normalizedLazyNode() {
        var _states = this.states,
          rowKey = _states.rowKey,
          lazyTreeNodeMap = _states.lazyTreeNodeMap,
          lazyColumnIdentifier = _states.lazyColumnIdentifier;
        var keys = Object.keys(lazyTreeNodeMap);
        var res = {};
        if (!keys.length) return res;
        keys.forEach(function (key) {
          if (lazyTreeNodeMap[key].length) {
            var item = {
              children: []
            };
            lazyTreeNodeMap[key].forEach(function (row) {
              var currentRowKey = Object(util["g" /* getRowIdentity */])(row, rowKey);
              item.children.push(currentRowKey);
              if (row[lazyColumnIdentifier] && !res[currentRowKey]) {
                res[currentRowKey] = {
                  children: []
                };
              }
            });
            res[key] = item;
          }
        });
        return res;
      }
    },
    watch: {
      normalizedData: 'updateTreeData',
      normalizedLazyNode: 'updateTreeData'
    },
    methods: {
      normalize: function normalize(data) {
        var _states2 = this.states,
          childrenColumnName = _states2.childrenColumnName,
          lazyColumnIdentifier = _states2.lazyColumnIdentifier,
          rowKey = _states2.rowKey,
          lazy = _states2.lazy;
        var res = {};
        Object(util["n" /* walkTreeNode */])(data, function (parent, children, level) {
          var parentId = Object(util["g" /* getRowIdentity */])(parent, rowKey);
          if (Array.isArray(children)) {
            res[parentId] = {
              children: children.map(function (row) {
                return Object(util["g" /* getRowIdentity */])(row, rowKey);
              }),
              level: level
            };
          } else if (lazy) {
            // 当 children 不存在且 lazy 为 true，该节点即为懒加载的节点
            res[parentId] = {
              children: [],
              lazy: true,
              level: level
            };
          }
        }, childrenColumnName, lazyColumnIdentifier);
        return res;
      },
      updateTreeData: function updateTreeData() {
        var nested = this.normalizedData;
        var normalizedLazyNode = this.normalizedLazyNode;
        var keys = Object.keys(nested);
        var newTreeData = {};
        if (keys.length) {
          var _states3 = this.states,
            oldTreeData = _states3.treeData,
            defaultExpandAll = _states3.defaultExpandAll,
            expandRowKeys = _states3.expandRowKeys,
            lazy = _states3.lazy;
          var rootLazyRowKeys = [];
          var getExpanded = function getExpanded(oldValue, key) {
            var included = defaultExpandAll || expandRowKeys && expandRowKeys.indexOf(key) !== -1;
            return !!(oldValue && oldValue.expanded || included);
          };
          // 合并 expanded 与 display，确保数据刷新后，状态不变
          keys.forEach(function (key) {
            var oldValue = oldTreeData[key];
            var newValue = _extends({}, nested[key]);
            newValue.expanded = getExpanded(oldValue, key);
            if (newValue.lazy) {
              var _ref = oldValue || {},
                _ref$loaded = _ref.loaded,
                loaded = _ref$loaded === undefined ? false : _ref$loaded,
                _ref$loading = _ref.loading,
                loading = _ref$loading === undefined ? false : _ref$loading;
              newValue.loaded = !!loaded;
              newValue.loading = !!loading;
              rootLazyRowKeys.push(key);
            }
            newTreeData[key] = newValue;
          });
          // 根据懒加载数据更新 treeData
          var lazyKeys = Object.keys(normalizedLazyNode);
          if (lazy && lazyKeys.length && rootLazyRowKeys.length) {
            lazyKeys.forEach(function (key) {
              var oldValue = oldTreeData[key];
              var lazyNodeChildren = normalizedLazyNode[key].children;
              if (rootLazyRowKeys.indexOf(key) !== -1) {
                // 懒加载的 root 节点，更新一下原有的数据，原来的 children 一定是空数组
                if (newTreeData[key].children.length !== 0) {
                  throw new Error('[ElTable]children must be an empty array.');
                }
                newTreeData[key].children = lazyNodeChildren;
              } else {
                var _ref2 = oldValue || {},
                  _ref2$loaded = _ref2.loaded,
                  loaded = _ref2$loaded === undefined ? false : _ref2$loaded,
                  _ref2$loading = _ref2.loading,
                  loading = _ref2$loading === undefined ? false : _ref2$loading;
                newTreeData[key] = {
                  lazy: true,
                  loaded: !!loaded,
                  loading: !!loading,
                  expanded: getExpanded(oldValue, key),
                  children: lazyNodeChildren,
                  level: ''
                };
              }
            });
          }
        }
        this.states.treeData = newTreeData;
        this.updateTableScrollY();
      },
      updateTreeExpandKeys: function updateTreeExpandKeys(value) {
        this.states.expandRowKeys = value;
        this.updateTreeData();
      },
      toggleTreeExpansion: function toggleTreeExpansion(row, expanded) {
        this.assertRowKey();
        var _states4 = this.states,
          rowKey = _states4.rowKey,
          treeData = _states4.treeData;
        var id = Object(util["g" /* getRowIdentity */])(row, rowKey);
        var data = id && treeData[id];
        if (id && data && 'expanded' in data) {
          var oldExpanded = data.expanded;
          expanded = typeof expanded === 'undefined' ? !data.expanded : expanded;
          treeData[id].expanded = expanded;
          if (oldExpanded !== expanded) {
            this.table.$emit('expand-change', row, expanded);
          }
          this.updateTableScrollY();
        }
      },
      loadOrToggle: function loadOrToggle(row) {
        this.assertRowKey();
        var _states5 = this.states,
          lazy = _states5.lazy,
          treeData = _states5.treeData,
          rowKey = _states5.rowKey;
        var id = Object(util["g" /* getRowIdentity */])(row, rowKey);
        var data = treeData[id];
        if (lazy && data && 'loaded' in data && !data.loaded) {
          this.loadData(row, id, data);
        } else {
          this.toggleTreeExpansion(row);
        }
      },
      loadData: function loadData(row, key, treeNode) {
        var _this = this;
        var load = this.table.load;
        var rawTreeData = this.states.treeData;
        if (load && !rawTreeData[key].loaded) {
          rawTreeData[key].loading = true;
          load(row, treeNode, function (data) {
            if (!Array.isArray(data)) {
              throw new Error('[ElTable] data must be an array');
            }
            var _states6 = _this.states,
              lazyTreeNodeMap = _states6.lazyTreeNodeMap,
              treeData = _states6.treeData;
            treeData[key].loading = false;
            treeData[key].loaded = true;
            treeData[key].expanded = true;
            if (data.length) {
              _this.$set(lazyTreeNodeMap, key, data);
            }
            _this.table.$emit('expand-change', row, true);
          });
        }
      }
    }
  };
  // CONCATENATED MODULE: ./packages/table/src/store/watcher.js

  var watcher_sortData = function sortData(data, states) {
    var sortingColumn = states.sortingColumn;
    if (!sortingColumn || typeof sortingColumn.sortable === 'string') {
      return data;
    }
    return Object(util["i" /* orderBy */])(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
  };
  var doFlattenColumns = function doFlattenColumns(columns) {
    var result = [];
    columns.forEach(function (column) {
      if (column.children) {
        result.push.apply(result, doFlattenColumns(column.children));
      } else {
        result.push(column);
      }
    });
    return result;
  };

  /* harmony default export */
  var watcher = external_vue_default.a.extend({
    data: function data() {
      return {
        states: {
          // 3.0 版本后要求必须设置该属性
          rowKey: null,
          // 渲染的数据来源，是对 table 中的 data 过滤排序后的结果
          data: [],
          // 是否包含固定列
          isComplex: false,
          // 列
          _columns: [],
          // 不可响应的
          originColumns: [],
          columns: [],
          fixedColumns: [],
          rightFixedColumns: [],
          leafColumns: [],
          fixedLeafColumns: [],
          rightFixedLeafColumns: [],
          leafColumnsLength: 0,
          fixedLeafColumnsLength: 0,
          rightFixedLeafColumnsLength: 0,
          // 选择
          isAllSelected: false,
          selection: [],
          reserveSelection: false,
          selectOnIndeterminate: false,
          selectable: null,
          // 过滤
          filters: {},
          // 不可响应的
          filteredData: null,
          // 排序
          sortingColumn: null,
          sortProp: null,
          sortOrder: null,
          hoverRow: null
        }
      };
    },
    mixins: [expand, current, tree],
    methods: {
      // 检查 rowKey 是否存在
      assertRowKey: function assertRowKey() {
        var rowKey = this.states.rowKey;
        if (!rowKey) throw new Error('[ElTable] prop row-key is required');
      },
      // 更新列
      updateColumns: function updateColumns() {
        var states = this.states;
        var _columns = states._columns || [];
        states.fixedColumns = _columns.filter(function (column) {
          return column.fixed === true || column.fixed === 'left';
        });
        states.rightFixedColumns = _columns.filter(function (column) {
          return column.fixed === 'right';
        });
        if (states.fixedColumns.length > 0 && _columns[0] && _columns[0].type === 'selection' && !_columns[0].fixed) {
          _columns[0].fixed = true;
          states.fixedColumns.unshift(_columns[0]);
        }
        var notFixedColumns = _columns.filter(function (column) {
          return !column.fixed;
        });
        states.originColumns = [].concat(states.fixedColumns).concat(notFixedColumns).concat(states.rightFixedColumns);
        var leafColumns = doFlattenColumns(notFixedColumns);
        var fixedLeafColumns = doFlattenColumns(states.fixedColumns);
        var rightFixedLeafColumns = doFlattenColumns(states.rightFixedColumns);
        states.leafColumnsLength = leafColumns.length;
        states.fixedLeafColumnsLength = fixedLeafColumns.length;
        states.rightFixedLeafColumnsLength = rightFixedLeafColumns.length;
        states.columns = [].concat(fixedLeafColumns).concat(leafColumns).concat(rightFixedLeafColumns);
        states.isComplex = states.fixedColumns.length > 0 || states.rightFixedColumns.length > 0;
      },
      // 更新 DOM
      scheduleLayout: function scheduleLayout(needUpdateColumns) {
        if (needUpdateColumns) {
          this.updateColumns();
        }
        this.table.debouncedUpdateLayout();
      },
      // 选择
      isSelected: function isSelected(row) {
        var _states$selection = this.states.selection,
          selection = _states$selection === undefined ? [] : _states$selection;
        return selection.indexOf(row) > -1;
      },
      clearSelection: function clearSelection() {
        var states = this.states;
        states.isAllSelected = false;
        var oldSelection = states.selection;
        if (oldSelection.length) {
          states.selection = [];
          this.table.$emit('selection-change', []);
        }
      },
      cleanSelection: function cleanSelection() {
        var states = this.states;
        var data = states.data,
          rowKey = states.rowKey,
          selection = states.selection;
        var deleted = void 0;
        if (rowKey) {
          deleted = [];
          var selectedMap = Object(util["f" /* getKeysMap */])(selection, rowKey);
          var dataMap = Object(util["f" /* getKeysMap */])(data, rowKey);
          for (var key in selectedMap) {
            if (selectedMap.hasOwnProperty(key) && !dataMap[key]) {
              deleted.push(selectedMap[key].row);
            }
          }
        } else {
          deleted = selection.filter(function (item) {
            return data.indexOf(item) === -1;
          });
        }
        if (deleted.length) {
          var newSelection = selection.filter(function (item) {
            return deleted.indexOf(item) === -1;
          });
          states.selection = newSelection;
          this.table.$emit('selection-change', newSelection.slice());
        }
      },
      toggleRowSelection: function toggleRowSelection(row, selected) {
        var emitChange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var changed = Object(util["m" /* toggleRowStatus */])(this.states.selection, row, selected);
        if (changed) {
          var newSelection = (this.states.selection || []).slice();
          // 调用 API 修改选中值，不触发 select 事件
          if (emitChange) {
            this.table.$emit('select', newSelection, row);
          }
          this.table.$emit('selection-change', newSelection);
        }
      },
      _toggleAllSelection: function _toggleAllSelection() {
        var states = this.states;
        var _states$data = states.data,
          data = _states$data === undefined ? [] : _states$data,
          selection = states.selection;
        // when only some rows are selected (but not all), select or deselect all of them
        // depending on the value of selectOnIndeterminate

        var value = states.selectOnIndeterminate ? !states.isAllSelected : !(states.isAllSelected || selection.length);
        states.isAllSelected = value;
        var selectionChanged = false;
        data.forEach(function (row, index) {
          if (states.selectable) {
            if (states.selectable.call(null, row, index) && Object(util["m" /* toggleRowStatus */])(selection, row, value)) {
              selectionChanged = true;
            }
          } else {
            if (Object(util["m" /* toggleRowStatus */])(selection, row, value)) {
              selectionChanged = true;
            }
          }
        });
        if (selectionChanged) {
          this.table.$emit('selection-change', selection ? selection.slice() : []);
        }
        this.table.$emit('select-all', selection);
      },
      updateSelectionByRowKey: function updateSelectionByRowKey() {
        var states = this.states;
        var selection = states.selection,
          rowKey = states.rowKey,
          data = states.data;
        var selectedMap = Object(util["f" /* getKeysMap */])(selection, rowKey);
        data.forEach(function (row) {
          var rowId = Object(util["g" /* getRowIdentity */])(row, rowKey);
          var rowInfo = selectedMap[rowId];
          if (rowInfo) {
            selection[rowInfo.index] = row;
          }
        });
      },
      updateAllSelected: function updateAllSelected() {
        var states = this.states;
        var selection = states.selection,
          rowKey = states.rowKey,
          selectable = states.selectable;
        // data 为 null 时，解构时的默认值会被忽略

        var data = states.data || [];
        if (data.length === 0) {
          states.isAllSelected = false;
          return;
        }
        var selectedMap = void 0;
        if (rowKey) {
          selectedMap = Object(util["f" /* getKeysMap */])(selection, rowKey);
        }
        var isSelected = function isSelected(row) {
          if (selectedMap) {
            return !!selectedMap[Object(util["g" /* getRowIdentity */])(row, rowKey)];
          } else {
            return selection.indexOf(row) !== -1;
          }
        };
        var isAllSelected = true;
        var selectedCount = 0;
        for (var i = 0, j = data.length; i < j; i++) {
          var item = data[i];
          var isRowSelectable = selectable && selectable.call(null, item, i);
          if (!isSelected(item)) {
            if (!selectable || isRowSelectable) {
              isAllSelected = false;
              break;
            }
          } else {
            selectedCount++;
          }
        }
        if (selectedCount === 0) isAllSelected = false;
        states.isAllSelected = isAllSelected;
      },
      // 过滤与排序
      updateFilters: function updateFilters(columns, values) {
        if (!Array.isArray(columns)) {
          columns = [columns];
        }
        var states = this.states;
        var filters = {};
        columns.forEach(function (col) {
          states.filters[col.id] = values;
          filters[col.columnKey || col.id] = values;
        });
        return filters;
      },
      updateSort: function updateSort(column, prop, order) {
        if (this.states.sortingColumn && this.states.sortingColumn !== column) {
          this.states.sortingColumn.order = null;
        }
        this.states.sortingColumn = column;
        this.states.sortProp = prop;
        this.states.sortOrder = order;
      },
      execFilter: function execFilter() {
        var _this = this;
        var states = this.states;
        var _data = states._data,
          filters = states.filters;
        var data = _data;
        Object.keys(filters).forEach(function (columnId) {
          var values = states.filters[columnId];
          if (!values || values.length === 0) return;
          var column = Object(util["d" /* getColumnById */])(_this.states, columnId);
          if (column && column.filterMethod) {
            data = data.filter(function (row) {
              return values.some(function (value) {
                return column.filterMethod.call(null, value, row, column);
              });
            });
          }
        });
        states.filteredData = data;
      },
      execSort: function execSort() {
        var states = this.states;
        states.data = watcher_sortData(states.filteredData, states);
      },
      // 根据 filters 与 sort 去过滤 data
      execQuery: function execQuery(ignore) {
        if (!(ignore && ignore.filter)) {
          this.execFilter();
        }
        this.execSort();
      },
      clearFilter: function clearFilter(columnKeys) {
        var states = this.states;
        var _table$$refs = this.table.$refs,
          tableHeader = _table$$refs.tableHeader,
          fixedTableHeader = _table$$refs.fixedTableHeader,
          rightFixedTableHeader = _table$$refs.rightFixedTableHeader;
        var panels = {};
        if (tableHeader) panels = merge_default()(panels, tableHeader.filterPanels);
        if (fixedTableHeader) panels = merge_default()(panels, fixedTableHeader.filterPanels);
        if (rightFixedTableHeader) panels = merge_default()(panels, rightFixedTableHeader.filterPanels);
        var keys = Object.keys(panels);
        if (!keys.length) return;
        if (typeof columnKeys === 'string') {
          columnKeys = [columnKeys];
        }
        if (Array.isArray(columnKeys)) {
          var columns = columnKeys.map(function (key) {
            return Object(util["e" /* getColumnByKey */])(states, key);
          });
          keys.forEach(function (key) {
            var column = columns.find(function (col) {
              return col.id === key;
            });
            if (column) {
              // TODO: 优化这里的代码
              panels[key].filteredValue = [];
            }
          });
          this.commit('filterChange', {
            column: columns,
            values: [],
            silent: true,
            multi: true
          });
        } else {
          keys.forEach(function (key) {
            // TODO: 优化这里的代码
            panels[key].filteredValue = [];
          });
          states.filters = {};
          this.commit('filterChange', {
            column: {},
            values: [],
            silent: true
          });
        }
      },
      clearSort: function clearSort() {
        var states = this.states;
        if (!states.sortingColumn) return;
        this.updateSort(null, null, null);
        this.commit('changeSortCondition', {
          silent: true
        });
      },
      // 适配层，expand-row-keys 在 Expand 与 TreeTable 中都有使用
      setExpandRowKeysAdapter: function setExpandRowKeysAdapter(val) {
        // 这里会触发额外的计算，但为了兼容性，暂时这么做
        this.setExpandRowKeys(val);
        this.updateTreeExpandKeys(val);
      },
      // 展开行与 TreeTable 都要使用
      toggleRowExpansionAdapter: function toggleRowExpansionAdapter(row, expanded) {
        var hasExpandColumn = this.states.columns.some(function (_ref) {
          var type = _ref.type;
          return type === 'expand';
        });
        if (hasExpandColumn) {
          this.toggleRowExpansion(row, expanded);
        } else {
          this.toggleTreeExpansion(row, expanded);
        }
      }
    }
  });
  // CONCATENATED MODULE: ./packages/table/src/store/index.js

  watcher.prototype.mutations = {
    setData: function setData(states, data) {
      var dataInstanceChanged = states._data !== data;
      states._data = data;
      this.execQuery();
      // 数据变化，更新部分数据。
      // 没有使用 computed，而是手动更新部分数据 https://github.com/vuejs/vue/issues/6660#issuecomment-331417140
      this.updateCurrentRowData();
      this.updateExpandRows();
      if (states.reserveSelection) {
        this.assertRowKey();
        this.updateSelectionByRowKey();
      } else {
        if (dataInstanceChanged) {
          this.clearSelection();
        } else {
          this.cleanSelection();
        }
      }
      this.updateAllSelected();
      this.updateTableScrollY();
    },
    insertColumn: function insertColumn(states, column, index, parent) {
      var array = states._columns;
      if (parent) {
        array = parent.children;
        if (!array) array = parent.children = [];
      }
      if (typeof index !== 'undefined') {
        array.splice(index, 0, column);
      } else {
        array.push(column);
      }
      if (column.type === 'selection') {
        states.selectable = column.selectable;
        states.reserveSelection = column.reserveSelection;
      }
      if (this.table.$ready) {
        this.updateColumns(); // hack for dynamics insert column
        this.scheduleLayout();
      }
    },
    removeColumn: function removeColumn(states, column, parent) {
      var array = states._columns;
      if (parent) {
        array = parent.children;
        if (!array) array = parent.children = [];
      }
      if (array) {
        array.splice(array.indexOf(column), 1);
      }
      if (this.table.$ready) {
        this.updateColumns(); // hack for dynamics remove column
        this.scheduleLayout();
      }
    },
    sort: function sort(states, options) {
      var prop = options.prop,
        order = options.order,
        init = options.init;
      if (prop) {
        var column = Object(util_["arrayFind"])(states.columns, function (column) {
          return column.property === prop;
        });
        if (column) {
          column.order = order;
          this.updateSort(column, prop, order);
          this.commit('changeSortCondition', {
            init: init
          });
        }
      }
    },
    changeSortCondition: function changeSortCondition(states, options) {
      // 修复 pr https://github.com/ElemeFE/element/pull/15012 导致的 bug
      var column = states.sortingColumn,
        prop = states.sortProp,
        order = states.sortOrder;
      if (order === null) {
        states.sortingColumn = null;
        states.sortProp = null;
      }
      var ingore = {
        filter: true
      };
      this.execQuery(ingore);
      if (!options || !(options.silent || options.init)) {
        this.table.$emit('sort-change', {
          column: column,
          prop: prop,
          order: order
        });
      }
      this.updateTableScrollY();
    },
    filterChange: function filterChange(states, options) {
      var column = options.column,
        values = options.values,
        silent = options.silent;
      var newFilters = this.updateFilters(column, values);
      this.execQuery();
      if (!silent) {
        this.table.$emit('filter-change', newFilters);
      }
      this.updateTableScrollY();
    },
    toggleAllSelection: function toggleAllSelection() {
      this.toggleAllSelection();
    },
    rowSelectedChanged: function rowSelectedChanged(states, row) {
      this.toggleRowSelection(row);
      this.updateAllSelected();
    },
    setHoverRow: function setHoverRow(states, row) {
      states.hoverRow = row;
    },
    setCurrentRow: function setCurrentRow(states, row) {
      this.updateCurrentRow(row);
    }
  };
  watcher.prototype.commit = function (name) {
    var mutations = this.mutations;
    if (mutations[name]) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      mutations[name].apply(this, [this.states].concat(args));
    } else {
      throw new Error('Action not found: ' + name);
    }
  };
  watcher.prototype.updateTableScrollY = function () {
    external_vue_default.a.nextTick(this.table.updateScrollY);
  };

  /* harmony default export */
  var src_store = watcher;
  // EXTERNAL MODULE: external "throttle-debounce/debounce"
  var debounce_ = __nested_webpack_require_19058__(19);
  var debounce_default = /*#__PURE__*/__nested_webpack_require_19058__.n(debounce_);

  // CONCATENATED MODULE: ./packages/table/src/store/helper.js

  function createStore(table) {
    var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!table) {
      throw new Error('Table is required.');
    }
    var store = new src_store();
    store.table = table;
    // fix https://github.com/ElemeFE/element/issues/14075
    // related pr https://github.com/ElemeFE/element/pull/14146
    store.toggleAllSelection = debounce_default()(10, store._toggleAllSelection);
    Object.keys(initialState).forEach(function (key) {
      store.states[key] = initialState[key];
    });
    return store;
  }
  function mapStates(mapper) {
    var res = {};
    Object.keys(mapper).forEach(function (key) {
      var value = mapper[key];
      var fn = void 0;
      if (typeof value === 'string') {
        fn = function fn() {
          return this.store.states[value];
        };
      } else if (typeof value === 'function') {
        fn = function fn() {
          return value.call(this, this.store.states);
        };
      } else {
        console.error('invalid value type');
      }
      if (fn) {
        res[key] = fn;
      }
    });
    return res;
  }
  ;
  // EXTERNAL MODULE: external "element-ui/lib/utils/scrollbar-width"
  var scrollbar_width_ = __nested_webpack_require_19058__(39);
  var scrollbar_width_default = /*#__PURE__*/__nested_webpack_require_19058__.n(scrollbar_width_);

  // CONCATENATED MODULE: ./packages/table/src/table-layout.js
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var table_layout_TableLayout = function () {
    function TableLayout(options) {
      _classCallCheck(this, TableLayout);
      this.observers = [];
      this.table = null;
      this.store = null;
      this.columns = null;
      this.fit = true;
      this.showHeader = true;
      this.height = null;
      this.scrollX = false;
      this.scrollY = false;
      this.bodyWidth = null;
      this.fixedWidth = null;
      this.rightFixedWidth = null;
      this.tableHeight = null;
      this.headerHeight = 44; // Table Header Height
      this.appendHeight = 0; // Append Slot Height
      this.footerHeight = 44; // Table Footer Height
      this.viewportHeight = null; // Table Height - Scroll Bar Height
      this.bodyHeight = null; // Table Height - Table Header Height
      this.fixedBodyHeight = null; // Table Height - Table Header Height - Scroll Bar Height
      this.gutterWidth = scrollbar_width_default()();
      for (var name in options) {
        if (options.hasOwnProperty(name)) {
          this[name] = options[name];
        }
      }
      if (!this.table) {
        throw new Error('table is required for Table Layout');
      }
      if (!this.store) {
        throw new Error('store is required for Table Layout');
      }
    }
    TableLayout.prototype.updateScrollY = function updateScrollY() {
      var height = this.height;
      if (height === null) return false;
      var bodyWrapper = this.table.bodyWrapper;
      if (this.table.$el && bodyWrapper) {
        var body = bodyWrapper.querySelector('.el-table__body');
        var prevScrollY = this.scrollY;
        var scrollY = body.offsetHeight > this.bodyHeight;
        this.scrollY = scrollY;
        return prevScrollY !== scrollY;
      }
      return false;
    };
    TableLayout.prototype.setHeight = function setHeight(value) {
      var _this = this;
      var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'height';
      if (external_vue_default.a.prototype.$isServer) return;
      var el = this.table.$el;
      value = Object(util["j" /* parseHeight */])(value);
      this.height = value;
      if (!el && (value || value === 0)) return external_vue_default.a.nextTick(function () {
        return _this.setHeight(value, prop);
      });
      if (typeof value === 'number') {
        el.style[prop] = value + 'px';
        this.updateElsHeight();
      } else if (typeof value === 'string') {
        el.style[prop] = value;
        this.updateElsHeight();
      }
    };
    TableLayout.prototype.setMaxHeight = function setMaxHeight(value) {
      this.setHeight(value, 'max-height');
    };
    TableLayout.prototype.getFlattenColumns = function getFlattenColumns() {
      var flattenColumns = [];
      var columns = this.table.columns;
      columns.forEach(function (column) {
        if (column.isColumnGroup) {
          flattenColumns.push.apply(flattenColumns, column.columns);
        } else {
          flattenColumns.push(column);
        }
      });
      return flattenColumns;
    };
    TableLayout.prototype.updateElsHeight = function updateElsHeight() {
      var _this2 = this;
      if (!this.table.$ready) return external_vue_default.a.nextTick(function () {
        return _this2.updateElsHeight();
      });
      var _table$$refs = this.table.$refs,
        headerWrapper = _table$$refs.headerWrapper,
        appendWrapper = _table$$refs.appendWrapper,
        footerWrapper = _table$$refs.footerWrapper;
      this.appendHeight = appendWrapper ? appendWrapper.offsetHeight : 0;
      if (this.showHeader && !headerWrapper) return;

      // fix issue (https://github.com/ElemeFE/element/pull/16956)
      var headerTrElm = headerWrapper ? headerWrapper.querySelector('.el-table__header tr') : null;
      var noneHeader = this.headerDisplayNone(headerTrElm);
      var headerHeight = this.headerHeight = !this.showHeader ? 0 : headerWrapper.offsetHeight;
      if (this.showHeader && !noneHeader && headerWrapper.offsetWidth > 0 && (this.table.columns || []).length > 0 && headerHeight < 2) {
        return external_vue_default.a.nextTick(function () {
          return _this2.updateElsHeight();
        });
      }
      var tableHeight = this.tableHeight = this.table.$el.clientHeight;
      var footerHeight = this.footerHeight = footerWrapper ? footerWrapper.offsetHeight : 0;
      if (this.height !== null) {
        this.bodyHeight = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
      }
      this.fixedBodyHeight = this.scrollX ? this.bodyHeight - this.gutterWidth : this.bodyHeight;
      var noData = !(this.store.states.data && this.store.states.data.length);
      this.viewportHeight = this.scrollX ? tableHeight - (noData ? 0 : this.gutterWidth) : tableHeight;
      this.updateScrollY();
      this.notifyObservers('scrollable');
    };
    TableLayout.prototype.headerDisplayNone = function headerDisplayNone(elm) {
      if (!elm) return true;
      var headerChild = elm;
      while (headerChild.tagName !== 'DIV') {
        if (getComputedStyle(headerChild).display === 'none') {
          return true;
        }
        headerChild = headerChild.parentElement;
      }
      return false;
    };
    TableLayout.prototype.updateColumnsWidth = function updateColumnsWidth() {
      if (external_vue_default.a.prototype.$isServer) return;
      var fit = this.fit;
      var bodyWidth = this.table.$el.clientWidth;
      var bodyMinWidth = 0;
      var flattenColumns = this.getFlattenColumns();
      var flexColumns = flattenColumns.filter(function (column) {
        return typeof column.width !== 'number';
      });
      flattenColumns.forEach(function (column) {
        // Clean those columns whose width changed from flex to unflex
        if (typeof column.width === 'number' && column.realWidth) column.realWidth = null;
      });
      if (flexColumns.length > 0 && fit) {
        flattenColumns.forEach(function (column) {
          bodyMinWidth += column.width || column.minWidth || 80;
        });
        var scrollYWidth = this.scrollY ? this.gutterWidth : 0;
        if (bodyMinWidth <= bodyWidth - scrollYWidth) {
          // DON'T HAVE SCROLL BAR
          this.scrollX = false;
          var totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth;
          if (flexColumns.length === 1) {
            flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth;
          } else {
            var allColumnsWidth = flexColumns.reduce(function (prev, column) {
              return prev + (column.minWidth || 80);
            }, 0);
            var flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
            var noneFirstWidth = 0;
            flexColumns.forEach(function (column, index) {
              if (index === 0) return;
              var flexWidth = Math.floor((column.minWidth || 80) * flexWidthPerPixel);
              noneFirstWidth += flexWidth;
              column.realWidth = (column.minWidth || 80) + flexWidth;
            });
            flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
          }
        } else {
          // HAVE HORIZONTAL SCROLL BAR
          this.scrollX = true;
          flexColumns.forEach(function (column) {
            column.realWidth = column.minWidth;
          });
        }
        this.bodyWidth = Math.max(bodyMinWidth, bodyWidth);
        this.table.resizeState.width = this.bodyWidth;
      } else {
        flattenColumns.forEach(function (column) {
          if (!column.width && !column.minWidth) {
            column.realWidth = 80;
          } else {
            column.realWidth = column.width || column.minWidth;
          }
          bodyMinWidth += column.realWidth;
        });
        this.scrollX = bodyMinWidth > bodyWidth;
        this.bodyWidth = bodyMinWidth;
      }
      var fixedColumns = this.store.states.fixedColumns;
      if (fixedColumns.length > 0) {
        var fixedWidth = 0;
        fixedColumns.forEach(function (column) {
          fixedWidth += column.realWidth || column.width;
        });
        this.fixedWidth = fixedWidth;
      }
      var rightFixedColumns = this.store.states.rightFixedColumns;
      if (rightFixedColumns.length > 0) {
        var rightFixedWidth = 0;
        rightFixedColumns.forEach(function (column) {
          rightFixedWidth += column.realWidth || column.width;
        });
        this.rightFixedWidth = rightFixedWidth;
      }
      this.notifyObservers('columns');
    };
    TableLayout.prototype.addObserver = function addObserver(observer) {
      this.observers.push(observer);
    };
    TableLayout.prototype.removeObserver = function removeObserver(observer) {
      var index = this.observers.indexOf(observer);
      if (index !== -1) {
        this.observers.splice(index, 1);
      }
    };
    TableLayout.prototype.notifyObservers = function notifyObservers(event) {
      var _this3 = this;
      var observers = this.observers;
      observers.forEach(function (observer) {
        switch (event) {
          case 'columns':
            observer.onColumnsChange(_this3);
            break;
          case 'scrollable':
            observer.onScrollableChange(_this3);
            break;
          default:
            throw new Error('Table Layout don\'t have event ' + event + '.');
        }
      });
    };
    return TableLayout;
  }();

  /* harmony default export */
  var table_layout = table_layout_TableLayout;
  // EXTERNAL MODULE: external "element-ui/lib/utils/dom"
  var dom_ = __nested_webpack_require_19058__(2);

  // EXTERNAL MODULE: external "element-ui/lib/tooltip"
  var tooltip_ = __nested_webpack_require_19058__(29);
  var tooltip_default = /*#__PURE__*/__nested_webpack_require_19058__.n(tooltip_);

  // CONCATENATED MODULE: ./packages/table/src/layout-observer.js
  /* harmony default export */
  var layout_observer = {
    created: function created() {
      this.tableLayout.addObserver(this);
    },
    destroyed: function destroyed() {
      this.tableLayout.removeObserver(this);
    },
    computed: {
      tableLayout: function tableLayout() {
        var layout = this.layout;
        if (!layout && this.table) {
          layout = this.table.layout;
        }
        if (!layout) {
          throw new Error('Can not find table layout.');
        }
        return layout;
      }
    },
    mounted: function mounted() {
      this.onColumnsChange(this.tableLayout);
      this.onScrollableChange(this.tableLayout);
    },
    updated: function updated() {
      if (this.__updated__) return;
      this.onColumnsChange(this.tableLayout);
      this.onScrollableChange(this.tableLayout);
      this.__updated__ = true;
    },
    methods: {
      onColumnsChange: function onColumnsChange(layout) {
        var cols = this.$el.querySelectorAll('colgroup > col');
        if (!cols.length) return;
        var flattenColumns = layout.getFlattenColumns();
        var columnsMap = {};
        flattenColumns.forEach(function (column) {
          columnsMap[column.id] = column;
        });
        for (var i = 0, j = cols.length; i < j; i++) {
          var col = cols[i];
          var name = col.getAttribute('name');
          var column = columnsMap[name];
          if (column) {
            col.setAttribute('width', column.realWidth || column.width);
          }
        }
      },
      onScrollableChange: function onScrollableChange(layout) {
        var cols = this.$el.querySelectorAll('colgroup > col[name=gutter]');
        for (var i = 0, j = cols.length; i < j; i++) {
          var col = cols[i];
          col.setAttribute('width', layout.scrollY ? layout.gutterWidth : '0');
        }
        var ths = this.$el.querySelectorAll('th.gutter');
        for (var _i = 0, _j = ths.length; _i < _j; _i++) {
          var th = ths[_i];
          th.style.width = layout.scrollY ? layout.gutterWidth + 'px' : '0';
          th.style.display = layout.scrollY ? '' : 'none';
        }
      }
    }
  };
  // CONCATENATED MODULE: ./packages/table/src/table-row.js
  var table_row_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };

  /* harmony default export */
  var table_row = {
    name: 'ElTableRow',
    props: ['columns', 'row', 'index', 'isSelected', 'isExpanded', 'store', 'context', 'firstDefaultColumnIndex', 'treeRowData', 'treeIndent', 'columnsHidden', 'getSpan', 'getColspanRealWidth', 'getCellStyle', 'getCellClass', 'handleCellMouseLeave', 'handleCellMouseEnter', 'fixed'],
    components: {
      ElCheckbox: checkbox_default.a
    },
    render: function render() {
      var _this = this;
      var h = arguments[0];
      var columns = this.columns,
        row = this.row,
        $index = this.index,
        store = this.store,
        context = this.context,
        firstDefaultColumnIndex = this.firstDefaultColumnIndex,
        treeRowData = this.treeRowData,
        treeIndent = this.treeIndent,
        _columnsHidden = this.columnsHidden,
        columnsHidden = _columnsHidden === undefined ? [] : _columnsHidden,
        isSelected = this.isSelected,
        isExpanded = this.isExpanded;
      return h('tr', [columns.map(function (column, cellIndex) {
        var _getSpan = _this.getSpan(row, column, $index, cellIndex),
          rowspan = _getSpan.rowspan,
          colspan = _getSpan.colspan;
        if (!rowspan || !colspan) {
          return null;
        }
        var columnData = table_row_extends({}, column);
        columnData.realWidth = _this.getColspanRealWidth(columns, colspan, cellIndex);
        var data = {
          store: store,
          isSelected: isSelected,
          isExpanded: isExpanded,
          _self: context,
          column: columnData,
          row: row,
          $index: $index
        };
        if (cellIndex === firstDefaultColumnIndex && treeRowData) {
          data.treeNode = {
            indent: treeRowData.level * treeIndent,
            level: treeRowData.level
          };
          if (typeof treeRowData.expanded === 'boolean') {
            data.treeNode.expanded = treeRowData.expanded;
            // 表明是懒加载
            if ('loading' in treeRowData) {
              data.treeNode.loading = treeRowData.loading;
            }
            if ('noLazyChildren' in treeRowData) {
              data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
            }
          }
        }
        return h('td', {
          style: _this.getCellStyle($index, cellIndex, row, column),
          'class': _this.getCellClass($index, cellIndex, row, column),
          attrs: {
            rowspan: rowspan,
            colspan: colspan
          },
          on: {
            'mouseenter': function mouseenter($event) {
              return _this.handleCellMouseEnter($event, row);
            },
            'mouseleave': _this.handleCellMouseLeave
          }
        }, [column.renderCell.call(_this._renderProxy, _this.$createElement, data, columnsHidden[cellIndex])]);
      })]);
    }
  };
  // CONCATENATED MODULE: ./packages/table/src/table-body.js
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var table_body_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };

  /* harmony default export */
  var table_body = {
    name: 'ElTableBody',
    mixins: [layout_observer],
    components: {
      ElCheckbox: checkbox_default.a,
      ElTooltip: tooltip_default.a,
      TableRow: table_row
    },
    props: {
      store: {
        required: true
      },
      stripe: Boolean,
      context: {},
      rowClassName: [String, Function],
      rowStyle: [Object, Function],
      fixed: String,
      highlight: Boolean
    },
    render: function render(h) {
      var _this = this;
      var data = this.data || [];
      return h('table', {
        'class': 'el-table__body',
        attrs: {
          cellspacing: '0',
          cellpadding: '0',
          border: '0'
        }
      }, [h('colgroup', [this.columns.map(function (column) {
        return h('col', {
          attrs: {
            name: column.id
          },
          key: column.id
        });
      })]), h('tbody', [data.reduce(function (acc, row) {
        return acc.concat(_this.wrappedRowRender(row, acc.length));
      }, []), h('el-tooltip', {
        attrs: {
          effect: this.table.tooltipEffect,
          placement: 'top',
          content: this.tooltipContent
        },
        ref: 'tooltip'
      })])]);
    },
    computed: table_body_extends({
      table: function table() {
        return this.$parent;
      }
    }, mapStates({
      data: 'data',
      columns: 'columns',
      treeIndent: 'indent',
      leftFixedLeafCount: 'fixedLeafColumnsLength',
      rightFixedLeafCount: 'rightFixedLeafColumnsLength',
      columnsCount: function columnsCount(states) {
        return states.columns.length;
      },
      leftFixedCount: function leftFixedCount(states) {
        return states.fixedColumns.length;
      },
      rightFixedCount: function rightFixedCount(states) {
        return states.rightFixedColumns.length;
      },
      hasExpandColumn: function hasExpandColumn(states) {
        return states.columns.some(function (_ref) {
          var type = _ref.type;
          return type === 'expand';
        });
      }
    }), {
      columnsHidden: function columnsHidden() {
        var _this2 = this;
        return this.columns.map(function (column, index) {
          return _this2.isColumnHidden(index);
        });
      },
      firstDefaultColumnIndex: function firstDefaultColumnIndex() {
        return Object(util_["arrayFindIndex"])(this.columns, function (_ref2) {
          var type = _ref2.type;
          return type === 'default';
        });
      }
    }),
    watch: {
      // don't trigger getter of currentRow in getCellClass. see https://jsfiddle.net/oe2b4hqt/
      // update DOM manually. see https://github.com/ElemeFE/element/pull/13954/files#diff-9b450c00d0a9dec0ffad5a3176972e40
      'store.states.hoverRow': function storeStatesHoverRow(newVal, oldVal) {
        var _this3 = this;
        if (!this.store.states.isComplex || this.$isServer) return;
        var raf = window.requestAnimationFrame;
        if (!raf) {
          raf = function raf(fn) {
            return setTimeout(fn, 16);
          };
        }
        raf(function () {
          var rows = _this3.$el.querySelectorAll('.el-table__row');
          var oldRow = rows[oldVal];
          var newRow = rows[newVal];
          if (oldRow) {
            Object(dom_["removeClass"])(oldRow, 'hover-row');
          }
          if (newRow) {
            Object(dom_["addClass"])(newRow, 'hover-row');
          }
        });
      }
    },
    data: function data() {
      return {
        tooltipContent: ''
      };
    },
    created: function created() {
      this.activateTooltip = debounce_default()(50, function (tooltip) {
        return tooltip.handleShowPopper();
      });
    },
    methods: {
      getKeyOfRow: function getKeyOfRow(row, index) {
        var rowKey = this.table.rowKey;
        if (rowKey) {
          return Object(util["g" /* getRowIdentity */])(row, rowKey);
        }
        return index;
      },
      isColumnHidden: function isColumnHidden(index) {
        if (this.fixed === true || this.fixed === 'left') {
          return index >= this.leftFixedLeafCount;
        } else if (this.fixed === 'right') {
          return index < this.columnsCount - this.rightFixedLeafCount;
        } else {
          return index < this.leftFixedLeafCount || index >= this.columnsCount - this.rightFixedLeafCount;
        }
      },
      getSpan: function getSpan(row, column, rowIndex, columnIndex) {
        var rowspan = 1;
        var colspan = 1;
        var fn = this.table.spanMethod;
        if (typeof fn === 'function') {
          var result = fn({
            row: row,
            column: column,
            rowIndex: rowIndex,
            columnIndex: columnIndex
          });
          if (Array.isArray(result)) {
            rowspan = result[0];
            colspan = result[1];
          } else if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
            rowspan = result.rowspan;
            colspan = result.colspan;
          }
        }
        return {
          rowspan: rowspan,
          colspan: colspan
        };
      },
      getRowStyle: function getRowStyle(row, rowIndex) {
        var rowStyle = this.table.rowStyle;
        if (typeof rowStyle === 'function') {
          return rowStyle.call(null, {
            row: row,
            rowIndex: rowIndex
          });
        }
        return rowStyle || null;
      },
      getRowClass: function getRowClass(row, rowIndex) {
        var classes = ['el-table__row'];
        if (this.table.highlightCurrentRow && row === this.store.states.currentRow) {
          classes.push('current-row');
        }
        if (this.stripe && rowIndex % 2 === 1) {
          classes.push('el-table__row--striped');
        }
        var rowClassName = this.table.rowClassName;
        if (typeof rowClassName === 'string') {
          classes.push(rowClassName);
        } else if (typeof rowClassName === 'function') {
          classes.push(rowClassName.call(null, {
            row: row,
            rowIndex: rowIndex
          }));
        }
        if (this.store.states.expandRows.indexOf(row) > -1) {
          classes.push('expanded');
        }
        return classes;
      },
      getCellStyle: function getCellStyle(rowIndex, columnIndex, row, column) {
        var cellStyle = this.table.cellStyle;
        if (typeof cellStyle === 'function') {
          return cellStyle.call(null, {
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            row: row,
            column: column
          });
        }
        return cellStyle;
      },
      getCellClass: function getCellClass(rowIndex, columnIndex, row, column) {
        var classes = [column.id, column.align, column.className];
        if (this.isColumnHidden(columnIndex)) {
          classes.push('is-hidden');
        }
        var cellClassName = this.table.cellClassName;
        if (typeof cellClassName === 'string') {
          classes.push(cellClassName);
        } else if (typeof cellClassName === 'function') {
          classes.push(cellClassName.call(null, {
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            row: row,
            column: column
          }));
        }
        classes.push('el-table__cell');
        return classes.join(' ');
      },
      getColspanRealWidth: function getColspanRealWidth(columns, colspan, index) {
        if (colspan < 1) {
          return columns[index].realWidth;
        }
        var widthArr = columns.map(function (_ref3) {
          var realWidth = _ref3.realWidth;
          return realWidth;
        }).slice(index, index + colspan);
        return widthArr.reduce(function (acc, width) {
          return acc + width;
        }, -1);
      },
      handleCellMouseEnter: function handleCellMouseEnter(event, row) {
        var table = this.table;
        var cell = Object(util["b" /* getCell */])(event);
        if (cell) {
          var column = Object(util["c" /* getColumnByCell */])(table, cell);
          var hoverState = table.hoverState = {
            cell: cell,
            column: column,
            row: row
          };
          table.$emit('cell-mouse-enter', hoverState.row, hoverState.column, hoverState.cell, event);
        }

        // 判断是否text-overflow, 如果是就显示tooltip
        var cellChild = event.target.querySelector('.cell');
        if (!(Object(dom_["hasClass"])(cellChild, 'el-tooltip') && cellChild.childNodes.length)) {
          return;
        }
        // use range width instead of scrollWidth to determine whether the text is overflowing
        // to address a potential FireFox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1074543#c3
        var range = document.createRange();
        range.setStart(cellChild, 0);
        range.setEnd(cellChild, cellChild.childNodes.length);
        var rangeWidth = range.getBoundingClientRect().width;
        var padding = (parseInt(Object(dom_["getStyle"])(cellChild, 'paddingLeft'), 10) || 0) + (parseInt(Object(dom_["getStyle"])(cellChild, 'paddingRight'), 10) || 0);
        if ((rangeWidth + padding > cellChild.offsetWidth || cellChild.scrollWidth > cellChild.offsetWidth) && this.$refs.tooltip) {
          var tooltip = this.$refs.tooltip;
          // TODO 会引起整个 Table 的重新渲染，需要优化
          this.tooltipContent = cell.innerText || cell.textContent;
          tooltip.referenceElm = cell;
          tooltip.$refs.popper && (tooltip.$refs.popper.style.display = 'none');
          tooltip.doDestroy();
          tooltip.setExpectedState(true);
          this.activateTooltip(tooltip);
        }
      },
      handleCellMouseLeave: function handleCellMouseLeave(event) {
        var tooltip = this.$refs.tooltip;
        if (tooltip) {
          tooltip.setExpectedState(false);
          tooltip.handleClosePopper();
        }
        var cell = Object(util["b" /* getCell */])(event);
        if (!cell) return;
        var oldHoverState = this.table.hoverState || {};
        this.table.$emit('cell-mouse-leave', oldHoverState.row, oldHoverState.column, oldHoverState.cell, event);
      },
      handleMouseEnter: debounce_default()(30, function (index) {
        this.store.commit('setHoverRow', index);
      }),
      handleMouseLeave: debounce_default()(30, function () {
        this.store.commit('setHoverRow', null);
      }),
      handleContextMenu: function handleContextMenu(event, row) {
        this.handleEvent(event, row, 'contextmenu');
      },
      handleDoubleClick: function handleDoubleClick(event, row) {
        this.handleEvent(event, row, 'dblclick');
      },
      handleClick: function handleClick(event, row) {
        this.store.commit('setCurrentRow', row);
        this.handleEvent(event, row, 'click');
      },
      handleEvent: function handleEvent(event, row, name) {
        var table = this.table;
        var cell = Object(util["b" /* getCell */])(event);
        var column = void 0;
        if (cell) {
          column = Object(util["c" /* getColumnByCell */])(table, cell);
          if (column) {
            table.$emit('cell-' + name, row, column, cell, event);
          }
        }
        table.$emit('row-' + name, row, column, event);
      },
      rowRender: function rowRender(row, $index, treeRowData) {
        var _this4 = this;
        var h = this.$createElement;
        var treeIndent = this.treeIndent,
          columns = this.columns,
          firstDefaultColumnIndex = this.firstDefaultColumnIndex;
        var rowClasses = this.getRowClass(row, $index);
        var display = true;
        if (treeRowData) {
          rowClasses.push('el-table__row--level-' + treeRowData.level);
          display = treeRowData.display;
        }
        // 指令 v-show 会覆盖 row-style 中 display
        // 使用 :style 代替 v-show https://github.com/ElemeFE/element/issues/16995
        var displayStyle = display ? null : {
          display: 'none'
        };
        return h(table_row, {
          style: [displayStyle, this.getRowStyle(row, $index)],
          'class': rowClasses,
          key: this.getKeyOfRow(row, $index),
          nativeOn: {
            'dblclick': function dblclick($event) {
              return _this4.handleDoubleClick($event, row);
            },
            'click': function click($event) {
              return _this4.handleClick($event, row);
            },
            'contextmenu': function contextmenu($event) {
              return _this4.handleContextMenu($event, row);
            },
            'mouseenter': function mouseenter(_) {
              return _this4.handleMouseEnter($index);
            },
            'mouseleave': this.handleMouseLeave
          },
          attrs: {
            columns: columns,
            row: row,
            index: $index,
            store: this.store,
            context: this.context || this.table.$vnode.context,
            firstDefaultColumnIndex: firstDefaultColumnIndex,
            treeRowData: treeRowData,
            treeIndent: treeIndent,
            columnsHidden: this.columnsHidden,
            getSpan: this.getSpan,
            getColspanRealWidth: this.getColspanRealWidth,
            getCellStyle: this.getCellStyle,
            getCellClass: this.getCellClass,
            handleCellMouseEnter: this.handleCellMouseEnter,
            handleCellMouseLeave: this.handleCellMouseLeave,
            isSelected: this.store.isSelected(row),
            isExpanded: this.store.states.expandRows.indexOf(row) > -1,
            fixed: this.fixed
          }
        });
      },
      wrappedRowRender: function wrappedRowRender(row, $index) {
        var _this5 = this;
        var h = this.$createElement;
        var store = this.store;
        var isRowExpanded = store.isRowExpanded,
          assertRowKey = store.assertRowKey;
        var _store$states = store.states,
          treeData = _store$states.treeData,
          lazyTreeNodeMap = _store$states.lazyTreeNodeMap,
          childrenColumnName = _store$states.childrenColumnName,
          rowKey = _store$states.rowKey;
        if (this.hasExpandColumn && isRowExpanded(row)) {
          var renderExpanded = this.table.renderExpanded;
          var tr = this.rowRender(row, $index);
          if (!renderExpanded) {
            console.error('[Element Error]renderExpanded is required.');
            return tr;
          }
          // 使用二维数组，避免修改 $index
          return [[tr, h('tr', {
            key: 'expanded-row__' + tr.key
          }, [h('td', {
            attrs: {
              colspan: this.columnsCount
            },
            'class': 'el-table__cell el-table__expanded-cell'
          }, [renderExpanded(this.$createElement, {
            row: row,
            $index: $index,
            store: this.store
          })])])]];
        } else if (Object.keys(treeData).length) {
          assertRowKey();
          // TreeTable 时，rowKey 必须由用户设定，不使用 getKeyOfRow 计算
          // 在调用 rowRender 函数时，仍然会计算 rowKey，不太好的操作
          var key = Object(util["g" /* getRowIdentity */])(row, rowKey);
          var cur = treeData[key];
          var treeRowData = null;
          if (cur) {
            treeRowData = {
              expanded: cur.expanded,
              level: cur.level,
              display: true
            };
            if (typeof cur.lazy === 'boolean') {
              if (typeof cur.loaded === 'boolean' && cur.loaded) {
                treeRowData.noLazyChildren = !(cur.children && cur.children.length);
              }
              treeRowData.loading = cur.loading;
            }
          }
          var tmp = [this.rowRender(row, $index, treeRowData)];
          // 渲染嵌套数据
          if (cur) {
            // currentRow 记录的是 index，所以还需主动增加 TreeTable 的 index
            var i = 0;
            var traverse = function traverse(children, parent) {
              if (!(children && children.length && parent)) return;
              children.forEach(function (node) {
                // 父节点的 display 状态影响子节点的显示状态
                var innerTreeRowData = {
                  display: parent.display && parent.expanded,
                  level: parent.level + 1
                };
                var childKey = Object(util["g" /* getRowIdentity */])(node, rowKey);
                if (childKey === undefined || childKey === null) {
                  throw new Error('for nested data item, row-key is required.');
                }
                cur = table_body_extends({}, treeData[childKey]);
                // 对于当前节点，分成有无子节点两种情况。
                // 如果包含子节点的，设置 expanded 属性。
                // 对于它子节点的 display 属性由它本身的 expanded 与 display 共同决定。
                if (cur) {
                  innerTreeRowData.expanded = cur.expanded;
                  // 懒加载的某些节点，level 未知
                  cur.level = cur.level || innerTreeRowData.level;
                  cur.display = !!(cur.expanded && innerTreeRowData.display);
                  if (typeof cur.lazy === 'boolean') {
                    if (typeof cur.loaded === 'boolean' && cur.loaded) {
                      innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                    }
                    innerTreeRowData.loading = cur.loading;
                  }
                }
                i++;
                tmp.push(_this5.rowRender(node, $index + i, innerTreeRowData));
                if (cur) {
                  var _nodes = lazyTreeNodeMap[childKey] || node[childrenColumnName];
                  traverse(_nodes, cur);
                }
              });
            };
            // 对于 root 节点，display 一定为 true
            cur.display = true;
            var nodes = lazyTreeNodeMap[key] || row[childrenColumnName];
            traverse(nodes, cur);
          }
          return tmp;
        } else {
          return this.rowRender(row, $index);
        }
      }
    }
  };
  // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/filter-panel.vue?vue&type=template&id=7f2c919f&
  var filter_panelvue_type_template_id_7f2c919f_render = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("transition", {
      attrs: {
        name: "el-zoom-in-top"
      }
    }, [_vm.multiple ? _c("div", {
      directives: [{
        name: "clickoutside",
        rawName: "v-clickoutside",
        value: _vm.handleOutsideClick,
        expression: "handleOutsideClick"
      }, {
        name: "show",
        rawName: "v-show",
        value: _vm.showPopper,
        expression: "showPopper"
      }],
      staticClass: "el-table-filter"
    }, [_c("div", {
      staticClass: "el-table-filter__content"
    }, [_c("el-scrollbar", {
      attrs: {
        "wrap-class": "el-table-filter__wrap"
      }
    }, [_c("el-checkbox-group", {
      staticClass: "el-table-filter__checkbox-group",
      model: {
        value: _vm.filteredValue,
        callback: function ($$v) {
          _vm.filteredValue = $$v;
        },
        expression: "filteredValue"
      }
    }, _vm._l(_vm.filters, function (filter) {
      return _c("el-checkbox", {
        key: filter.value,
        attrs: {
          label: filter.value
        }
      }, [_vm._v(_vm._s(filter.text))]);
    }), 1)], 1)], 1), _c("div", {
      staticClass: "el-table-filter__bottom"
    }, [_c("button", {
      class: {
        "is-disabled": _vm.filteredValue.length === 0
      },
      attrs: {
        disabled: _vm.filteredValue.length === 0
      },
      on: {
        click: _vm.handleConfirm
      }
    }, [_vm._v(_vm._s(_vm.t("el.table.confirmFilter")))]), _c("button", {
      on: {
        click: _vm.handleReset
      }
    }, [_vm._v(_vm._s(_vm.t("el.table.resetFilter")))])])]) : _c("div", {
      directives: [{
        name: "clickoutside",
        rawName: "v-clickoutside",
        value: _vm.handleOutsideClick,
        expression: "handleOutsideClick"
      }, {
        name: "show",
        rawName: "v-show",
        value: _vm.showPopper,
        expression: "showPopper"
      }],
      staticClass: "el-table-filter"
    }, [_c("ul", {
      staticClass: "el-table-filter__list"
    }, [_c("li", {
      staticClass: "el-table-filter__list-item",
      class: {
        "is-active": _vm.filterValue === undefined || _vm.filterValue === null
      },
      on: {
        click: function ($event) {
          _vm.handleSelect(null);
        }
      }
    }, [_vm._v(_vm._s(_vm.t("el.table.clearFilter")))]), _vm._l(_vm.filters, function (filter) {
      return _c("li", {
        key: filter.value,
        staticClass: "el-table-filter__list-item",
        class: {
          "is-active": _vm.isActive(filter)
        },
        attrs: {
          label: filter.value
        },
        on: {
          click: function ($event) {
            _vm.handleSelect(filter.value);
          }
        }
      }, [_vm._v(_vm._s(filter.text))]);
    })], 2)])]);
  };
  var filter_panelvue_type_template_id_7f2c919f_staticRenderFns = [];
  filter_panelvue_type_template_id_7f2c919f_render._withStripped = true;

  // CONCATENATED MODULE: ./packages/table/src/filter-panel.vue?vue&type=template&id=7f2c919f&

  // EXTERNAL MODULE: external "element-ui/lib/utils/vue-popper"
  var vue_popper_ = __nested_webpack_require_19058__(5);
  var vue_popper_default = /*#__PURE__*/__nested_webpack_require_19058__.n(vue_popper_);

  // EXTERNAL MODULE: external "element-ui/lib/utils/popup"
  var popup_ = __nested_webpack_require_19058__(13);

  // EXTERNAL MODULE: external "element-ui/lib/utils/clickoutside"
  var clickoutside_ = __nested_webpack_require_19058__(12);
  var clickoutside_default = /*#__PURE__*/__nested_webpack_require_19058__.n(clickoutside_);

  // CONCATENATED MODULE: ./packages/table/src/dropdown.js

  var dropdowns = [];
  !external_vue_default.a.prototype.$isServer && document.addEventListener('click', function (event) {
    dropdowns.forEach(function (dropdown) {
      var target = event.target;
      if (!dropdown || !dropdown.$el) return;
      if (target === dropdown.$el || dropdown.$el.contains(target)) {
        return;
      }
      dropdown.handleOutsideClick && dropdown.handleOutsideClick(event);
    });
  });

  /* harmony default export */
  var dropdown = {
    open: function open(instance) {
      if (instance) {
        dropdowns.push(instance);
      }
    },
    close: function close(instance) {
      var index = dropdowns.indexOf(instance);
      if (index !== -1) {
        dropdowns.splice(instance, 1);
      }
    }
  };
  // EXTERNAL MODULE: external "element-ui/lib/checkbox-group"
  var checkbox_group_ = __nested_webpack_require_19058__(40);
  var checkbox_group_default = /*#__PURE__*/__nested_webpack_require_19058__.n(checkbox_group_);

  // EXTERNAL MODULE: external "element-ui/lib/scrollbar"
  var scrollbar_ = __nested_webpack_require_19058__(15);
  var scrollbar_default = /*#__PURE__*/__nested_webpack_require_19058__.n(scrollbar_);

  // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/filter-panel.vue?vue&type=script&lang=js&
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  /* harmony default export */
  var filter_panelvue_type_script_lang_js_ = {
    name: 'ElTableFilterPanel',
    mixins: [vue_popper_default.a, locale_default.a],
    directives: {
      Clickoutside: clickoutside_default.a
    },
    components: {
      ElCheckbox: checkbox_default.a,
      ElCheckboxGroup: checkbox_group_default.a,
      ElScrollbar: scrollbar_default.a
    },
    props: {
      placement: {
        type: String,
        default: 'bottom-end'
      }
    },
    methods: {
      isActive: function isActive(filter) {
        return filter.value === this.filterValue;
      },
      handleOutsideClick: function handleOutsideClick() {
        var _this = this;
        setTimeout(function () {
          _this.showPopper = false;
        }, 16);
      },
      handleConfirm: function handleConfirm() {
        this.confirmFilter(this.filteredValue);
        this.handleOutsideClick();
      },
      handleReset: function handleReset() {
        this.filteredValue = [];
        this.confirmFilter(this.filteredValue);
        this.handleOutsideClick();
      },
      handleSelect: function handleSelect(filterValue) {
        this.filterValue = filterValue;
        if (typeof filterValue !== 'undefined' && filterValue !== null) {
          this.confirmFilter(this.filteredValue);
        } else {
          this.confirmFilter([]);
        }
        this.handleOutsideClick();
      },
      confirmFilter: function confirmFilter(filteredValue) {
        this.table.store.commit('filterChange', {
          column: this.column,
          values: filteredValue
        });
        this.table.store.updateAllSelected();
      }
    },
    data: function data() {
      return {
        table: null,
        cell: null,
        column: null
      };
    },
    computed: {
      filters: function filters() {
        return this.column && this.column.filters;
      },
      filterValue: {
        get: function get() {
          return (this.column.filteredValue || [])[0];
        },
        set: function set(value) {
          if (this.filteredValue) {
            if (typeof value !== 'undefined' && value !== null) {
              this.filteredValue.splice(0, 1, value);
            } else {
              this.filteredValue.splice(0, 1);
            }
          }
        }
      },
      filteredValue: {
        get: function get() {
          if (this.column) {
            return this.column.filteredValue || [];
          }
          return [];
        },
        set: function set(value) {
          if (this.column) {
            this.column.filteredValue = value;
          }
        }
      },
      multiple: function multiple() {
        if (this.column) {
          return this.column.filterMultiple;
        }
        return true;
      }
    },
    mounted: function mounted() {
      var _this2 = this;
      this.popperElm = this.$el;
      this.referenceElm = this.cell;
      this.table.bodyWrapper.addEventListener('scroll', function () {
        _this2.updatePopper();
      });
      this.$watch('showPopper', function (value) {
        if (_this2.column) _this2.column.filterOpened = value;
        if (value) {
          dropdown.open(_this2);
        } else {
          dropdown.close(_this2);
        }
      });
    },
    watch: {
      showPopper: function showPopper(val) {
        if (val === true && parseInt(this.popperJS._popper.style.zIndex, 10) < popup_["PopupManager"].zIndex) {
          this.popperJS._popper.style.zIndex = popup_["PopupManager"].nextZIndex();
        }
      }
    }
  };
  // CONCATENATED MODULE: ./packages/table/src/filter-panel.vue?vue&type=script&lang=js&
  /* harmony default export */
  var src_filter_panelvue_type_script_lang_js_ = filter_panelvue_type_script_lang_js_;
  // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
  var componentNormalizer = __nested_webpack_require_19058__(0);

  // CONCATENATED MODULE: ./packages/table/src/filter-panel.vue

  /* normalize component */

  var component = Object(componentNormalizer["a" /* default */])(src_filter_panelvue_type_script_lang_js_, filter_panelvue_type_template_id_7f2c919f_render, filter_panelvue_type_template_id_7f2c919f_staticRenderFns, false, null, null, null);

  /* hot reload */
  if (false) { var api; }
  component.options.__file = "packages/table/src/filter-panel.vue";
  /* harmony default export */
  var filter_panel = component.exports;
  // CONCATENATED MODULE: ./packages/table/src/table-header.js
  var table_header_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var getAllColumns = function getAllColumns(columns) {
    var result = [];
    columns.forEach(function (column) {
      if (column.children) {
        result.push(column);
        result.push.apply(result, getAllColumns(column.children));
      } else {
        result.push(column);
      }
    });
    return result;
  };
  var convertToRows = function convertToRows(originColumns) {
    var maxLevel = 1;
    var traverse = function traverse(column, parent) {
      if (parent) {
        column.level = parent.level + 1;
        if (maxLevel < column.level) {
          maxLevel = column.level;
        }
      }
      if (column.children) {
        var colSpan = 0;
        column.children.forEach(function (subColumn) {
          traverse(subColumn, column);
          colSpan += subColumn.colSpan;
        });
        column.colSpan = colSpan;
      } else {
        column.colSpan = 1;
      }
    };
    originColumns.forEach(function (column) {
      column.level = 1;
      traverse(column);
    });
    var rows = [];
    for (var i = 0; i < maxLevel; i++) {
      rows.push([]);
    }
    var allColumns = getAllColumns(originColumns);
    allColumns.forEach(function (column) {
      if (!column.children) {
        column.rowSpan = maxLevel - column.level + 1;
      } else {
        column.rowSpan = 1;
      }
      rows[column.level - 1].push(column);
    });
    return rows;
  };

  /* harmony default export */
  var table_header = {
    name: 'ElTableHeader',
    mixins: [layout_observer],
    render: function render(h) {
      var _this = this;
      var originColumns = this.store.states.originColumns;
      var columnRows = convertToRows(originColumns, this.columns);
      // 是否拥有多级表头
      var isGroup = columnRows.length > 1;
      if (isGroup) this.$parent.isGroup = true;
      return h('table', {
        'class': 'el-table__header',
        attrs: {
          cellspacing: '0',
          cellpadding: '0',
          border: '0'
        }
      }, [h('colgroup', [this.columns.map(function (column) {
        return h('col', {
          attrs: {
            name: column.id
          },
          key: column.id
        });
      }), this.hasGutter ? h('col', {
        attrs: {
          name: 'gutter'
        }
      }) : '']), h('thead', {
        'class': [{
          'is-group': isGroup,
          'has-gutter': this.hasGutter
        }]
      }, [this._l(columnRows, function (columns, rowIndex) {
        return h('tr', {
          style: _this.getHeaderRowStyle(rowIndex),
          'class': _this.getHeaderRowClass(rowIndex)
        }, [columns.map(function (column, cellIndex) {
          return h('th', {
            attrs: {
              colspan: column.colSpan,
              rowspan: column.rowSpan
            },
            on: {
              'mousemove': function mousemove($event) {
                return _this.handleMouseMove($event, column);
              },
              'mouseout': _this.handleMouseOut,
              'mousedown': function mousedown($event) {
                return _this.handleMouseDown($event, column);
              },
              'click': function click($event) {
                return _this.handleHeaderClick($event, column);
              },
              'contextmenu': function contextmenu($event) {
                return _this.handleHeaderContextMenu($event, column);
              }
            },
            style: _this.getHeaderCellStyle(rowIndex, cellIndex, columns, column),
            'class': _this.getHeaderCellClass(rowIndex, cellIndex, columns, column),
            key: column.id
          }, [h('div', {
            'class': ['cell', column.filteredValue && column.filteredValue.length > 0 ? 'highlight' : '', column.labelClassName]
          }, [column.renderHeader ? column.renderHeader.call(_this._renderProxy, h, {
            column: column,
            $index: cellIndex,
            store: _this.store,
            _self: _this.$parent.$vnode.context
          }) : column.label, column.sortable ? h('span', {
            'class': 'caret-wrapper',
            on: {
              'click': function click($event) {
                return _this.handleSortClick($event, column);
              }
            }
          }, [h('i', {
            'class': 'sort-caret ascending',
            on: {
              'click': function click($event) {
                return _this.handleSortClick($event, column, 'ascending');
              }
            }
          }), h('i', {
            'class': 'sort-caret descending',
            on: {
              'click': function click($event) {
                return _this.handleSortClick($event, column, 'descending');
              }
            }
          })]) : '', column.filterable ? h('span', {
            'class': 'el-table__column-filter-trigger',
            on: {
              'click': function click($event) {
                return _this.handleFilterClick($event, column);
              }
            }
          }, [h('i', {
            'class': ['el-icon-arrow-down', column.filterOpened ? 'el-icon-arrow-up' : '']
          })]) : ''])]);
        }), _this.hasGutter ? h('th', {
          'class': 'el-table__cell gutter'
        }) : '']);
      })])]);
    },
    props: {
      fixed: String,
      store: {
        required: true
      },
      border: Boolean,
      defaultSort: {
        type: Object,
        default: function _default() {
          return {
            prop: '',
            order: ''
          };
        }
      }
    },
    components: {
      ElCheckbox: checkbox_default.a
    },
    computed: table_header_extends({
      table: function table() {
        return this.$parent;
      },
      hasGutter: function hasGutter() {
        return !this.fixed && this.tableLayout.gutterWidth;
      }
    }, mapStates({
      columns: 'columns',
      isAllSelected: 'isAllSelected',
      leftFixedLeafCount: 'fixedLeafColumnsLength',
      rightFixedLeafCount: 'rightFixedLeafColumnsLength',
      columnsCount: function columnsCount(states) {
        return states.columns.length;
      },
      leftFixedCount: function leftFixedCount(states) {
        return states.fixedColumns.length;
      },
      rightFixedCount: function rightFixedCount(states) {
        return states.rightFixedColumns.length;
      }
    })),
    created: function created() {
      this.filterPanels = {};
    },
    mounted: function mounted() {
      var _this2 = this;

      // nextTick 是有必要的 https://github.com/ElemeFE/element/pull/11311
      this.$nextTick(function () {
        var _defaultSort = _this2.defaultSort,
          prop = _defaultSort.prop,
          order = _defaultSort.order;
        var init = true;
        _this2.store.commit('sort', {
          prop: prop,
          order: order,
          init: init
        });
      });
    },
    beforeDestroy: function beforeDestroy() {
      var panels = this.filterPanels;
      for (var prop in panels) {
        if (panels.hasOwnProperty(prop) && panels[prop]) {
          panels[prop].$destroy(true);
        }
      }
    },
    methods: {
      isCellHidden: function isCellHidden(index, columns) {
        var start = 0;
        for (var i = 0; i < index; i++) {
          start += columns[i].colSpan;
        }
        var after = start + columns[index].colSpan - 1;
        if (this.fixed === true || this.fixed === 'left') {
          return after >= this.leftFixedLeafCount;
        } else if (this.fixed === 'right') {
          return start < this.columnsCount - this.rightFixedLeafCount;
        } else {
          return after < this.leftFixedLeafCount || start >= this.columnsCount - this.rightFixedLeafCount;
        }
      },
      getHeaderRowStyle: function getHeaderRowStyle(rowIndex) {
        var headerRowStyle = this.table.headerRowStyle;
        if (typeof headerRowStyle === 'function') {
          return headerRowStyle.call(null, {
            rowIndex: rowIndex
          });
        }
        return headerRowStyle;
      },
      getHeaderRowClass: function getHeaderRowClass(rowIndex) {
        var classes = [];
        var headerRowClassName = this.table.headerRowClassName;
        if (typeof headerRowClassName === 'string') {
          classes.push(headerRowClassName);
        } else if (typeof headerRowClassName === 'function') {
          classes.push(headerRowClassName.call(null, {
            rowIndex: rowIndex
          }));
        }
        return classes.join(' ');
      },
      getHeaderCellStyle: function getHeaderCellStyle(rowIndex, columnIndex, row, column) {
        var headerCellStyle = this.table.headerCellStyle;
        if (typeof headerCellStyle === 'function') {
          return headerCellStyle.call(null, {
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            row: row,
            column: column
          });
        }
        return headerCellStyle;
      },
      getHeaderCellClass: function getHeaderCellClass(rowIndex, columnIndex, row, column) {
        var classes = [column.id, column.order, column.headerAlign, column.className, column.labelClassName];
        if (rowIndex === 0 && this.isCellHidden(columnIndex, row)) {
          classes.push('is-hidden');
        }
        if (!column.children) {
          classes.push('is-leaf');
        }
        if (column.sortable) {
          classes.push('is-sortable');
        }
        var headerCellClassName = this.table.headerCellClassName;
        if (typeof headerCellClassName === 'string') {
          classes.push(headerCellClassName);
        } else if (typeof headerCellClassName === 'function') {
          classes.push(headerCellClassName.call(null, {
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            row: row,
            column: column
          }));
        }
        classes.push('el-table__cell');
        return classes.join(' ');
      },
      toggleAllSelection: function toggleAllSelection() {
        this.store.commit('toggleAllSelection');
      },
      handleFilterClick: function handleFilterClick(event, column) {
        event.stopPropagation();
        var target = event.target;
        var cell = target.tagName === 'TH' ? target : target.parentNode;
        if (Object(dom_["hasClass"])(cell, 'noclick')) return;
        cell = cell.querySelector('.el-table__column-filter-trigger') || cell;
        var table = this.$parent;
        var filterPanel = this.filterPanels[column.id];
        if (filterPanel && column.filterOpened) {
          filterPanel.showPopper = false;
          return;
        }
        if (!filterPanel) {
          filterPanel = new external_vue_default.a(filter_panel);
          this.filterPanels[column.id] = filterPanel;
          if (column.filterPlacement) {
            filterPanel.placement = column.filterPlacement;
          }
          filterPanel.table = table;
          filterPanel.cell = cell;
          filterPanel.column = column;
          !this.$isServer && filterPanel.$mount(document.createElement('div'));
        }
        setTimeout(function () {
          filterPanel.showPopper = true;
        }, 16);
      },
      handleHeaderClick: function handleHeaderClick(event, column) {
        if (!column.filters && column.sortable) {
          this.handleSortClick(event, column);
        } else if (column.filterable && !column.sortable) {
          this.handleFilterClick(event, column);
        }
        this.$parent.$emit('header-click', column, event);
      },
      handleHeaderContextMenu: function handleHeaderContextMenu(event, column) {
        this.$parent.$emit('header-contextmenu', column, event);
      },
      handleMouseDown: function handleMouseDown(event, column) {
        var _this3 = this;
        if (this.$isServer) return;
        if (column.children && column.children.length > 0) return;
        /* istanbul ignore if */
        if (this.draggingColumn && this.border) {
          this.dragging = true;
          this.$parent.resizeProxyVisible = true;
          var table = this.$parent;
          var tableEl = table.$el;
          var tableLeft = tableEl.getBoundingClientRect().left;
          var columnEl = this.$el.querySelector('th.' + column.id);
          var columnRect = columnEl.getBoundingClientRect();
          var minLeft = columnRect.left - tableLeft + 30;
          Object(dom_["addClass"])(columnEl, 'noclick');
          this.dragState = {
            startMouseLeft: event.clientX,
            startLeft: columnRect.right - tableLeft,
            startColumnLeft: columnRect.left - tableLeft,
            tableLeft: tableLeft
          };
          var resizeProxy = table.$refs.resizeProxy;
          resizeProxy.style.left = this.dragState.startLeft + 'px';
          document.onselectstart = function () {
            return false;
          };
          document.ondragstart = function () {
            return false;
          };
          var handleMouseMove = function handleMouseMove(event) {
            var deltaLeft = event.clientX - _this3.dragState.startMouseLeft;
            var proxyLeft = _this3.dragState.startLeft + deltaLeft;
            resizeProxy.style.left = Math.max(minLeft, proxyLeft) + 'px';
          };
          var handleMouseUp = function handleMouseUp() {
            if (_this3.dragging) {
              var _dragState = _this3.dragState,
                startColumnLeft = _dragState.startColumnLeft,
                startLeft = _dragState.startLeft;
              var finalLeft = parseInt(resizeProxy.style.left, 10);
              var columnWidth = finalLeft - startColumnLeft;
              column.width = column.realWidth = columnWidth;
              table.$emit('header-dragend', column.width, startLeft - startColumnLeft, column, event);
              _this3.store.scheduleLayout();
              document.body.style.cursor = '';
              _this3.dragging = false;
              _this3.draggingColumn = null;
              _this3.dragState = {};
              table.resizeProxyVisible = false;
            }
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.onselectstart = null;
            document.ondragstart = null;
            setTimeout(function () {
              Object(dom_["removeClass"])(columnEl, 'noclick');
            }, 0);
          };
          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        }
      },
      handleMouseMove: function handleMouseMove(event, column) {
        if (column.children && column.children.length > 0) return;
        var target = event.target;
        while (target && target.tagName !== 'TH') {
          target = target.parentNode;
        }
        if (!column || !column.resizable) return;
        if (!this.dragging && this.border) {
          var rect = target.getBoundingClientRect();
          var bodyStyle = document.body.style;
          if (rect.width > 12 && rect.right - event.pageX < 8) {
            bodyStyle.cursor = 'col-resize';
            if (Object(dom_["hasClass"])(target, 'is-sortable')) {
              target.style.cursor = 'col-resize';
            }
            this.draggingColumn = column;
          } else if (!this.dragging) {
            bodyStyle.cursor = '';
            if (Object(dom_["hasClass"])(target, 'is-sortable')) {
              target.style.cursor = 'pointer';
            }
            this.draggingColumn = null;
          }
        }
      },
      handleMouseOut: function handleMouseOut() {
        if (this.$isServer) return;
        document.body.style.cursor = '';
      },
      toggleOrder: function toggleOrder(_ref) {
        var order = _ref.order,
          sortOrders = _ref.sortOrders;
        if (order === '') return sortOrders[0];
        var index = sortOrders.indexOf(order || null);
        return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
      },
      handleSortClick: function handleSortClick(event, column, givenOrder) {
        event.stopPropagation();
        var order = column.order === givenOrder ? null : givenOrder || this.toggleOrder(column);
        var target = event.target;
        while (target && target.tagName !== 'TH') {
          target = target.parentNode;
        }
        if (target && target.tagName === 'TH') {
          if (Object(dom_["hasClass"])(target, 'noclick')) {
            Object(dom_["removeClass"])(target, 'noclick');
            return;
          }
        }
        if (!column.sortable) return;
        var states = this.store.states;
        var sortProp = states.sortProp;
        var sortOrder = void 0;
        var sortingColumn = states.sortingColumn;
        if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
          if (sortingColumn) {
            sortingColumn.order = null;
          }
          states.sortingColumn = column;
          sortProp = column.property;
        }
        if (!order) {
          sortOrder = column.order = null;
        } else {
          sortOrder = column.order = order;
        }
        states.sortProp = sortProp;
        states.sortOrder = sortOrder;
        this.store.commit('changeSortCondition');
      }
    },
    data: function data() {
      return {
        draggingColumn: null,
        dragging: false,
        dragState: {}
      };
    }
  };
  // CONCATENATED MODULE: ./packages/table/src/table-footer.js
  var table_footer_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };

  /* harmony default export */
  var table_footer = {
    name: 'ElTableFooter',
    mixins: [layout_observer],
    render: function render(h) {
      var _this = this;
      var sums = [];
      if (this.summaryMethod) {
        sums = this.summaryMethod({
          columns: this.columns,
          data: this.store.states.data
        });
      } else {
        this.columns.forEach(function (column, index) {
          if (index === 0) {
            sums[index] = _this.sumText;
            return;
          }
          var values = _this.store.states.data.map(function (item) {
            return Number(item[column.property]);
          });
          var precisions = [];
          var notNumber = true;
          values.forEach(function (value) {
            if (!isNaN(value)) {
              notNumber = false;
              var decimal = ('' + value).split('.')[1];
              precisions.push(decimal ? decimal.length : 0);
            }
          });
          var precision = Math.max.apply(null, precisions);
          if (!notNumber) {
            sums[index] = values.reduce(function (prev, curr) {
              var value = Number(curr);
              if (!isNaN(value)) {
                return parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
              } else {
                return prev;
              }
            }, 0);
          } else {
            sums[index] = '';
          }
        });
      }
      return h('table', {
        'class': 'el-table__footer',
        attrs: {
          cellspacing: '0',
          cellpadding: '0',
          border: '0'
        }
      }, [h('colgroup', [this.columns.map(function (column) {
        return h('col', {
          attrs: {
            name: column.id
          },
          key: column.id
        });
      }), this.hasGutter ? h('col', {
        attrs: {
          name: 'gutter'
        }
      }) : '']), h('tbody', {
        'class': [{
          'has-gutter': this.hasGutter
        }]
      }, [h('tr', [this.columns.map(function (column, cellIndex) {
        return h('td', {
          key: cellIndex,
          attrs: {
            colspan: column.colSpan,
            rowspan: column.rowSpan
          },
          'class': [].concat(_this.getRowClasses(column, cellIndex), ['el-table__cell'])
        }, [h('div', {
          'class': ['cell', column.labelClassName]
        }, [sums[cellIndex]])]);
      }), this.hasGutter ? h('th', {
        'class': 'el-table__cell gutter'
      }) : ''])])]);
    },
    props: {
      fixed: String,
      store: {
        required: true
      },
      summaryMethod: Function,
      sumText: String,
      border: Boolean,
      defaultSort: {
        type: Object,
        default: function _default() {
          return {
            prop: '',
            order: ''
          };
        }
      }
    },
    computed: table_footer_extends({
      table: function table() {
        return this.$parent;
      },
      hasGutter: function hasGutter() {
        return !this.fixed && this.tableLayout.gutterWidth;
      }
    }, mapStates({
      columns: 'columns',
      isAllSelected: 'isAllSelected',
      leftFixedLeafCount: 'fixedLeafColumnsLength',
      rightFixedLeafCount: 'rightFixedLeafColumnsLength',
      columnsCount: function columnsCount(states) {
        return states.columns.length;
      },
      leftFixedCount: function leftFixedCount(states) {
        return states.fixedColumns.length;
      },
      rightFixedCount: function rightFixedCount(states) {
        return states.rightFixedColumns.length;
      }
    })),
    methods: {
      isCellHidden: function isCellHidden(index, columns, column) {
        if (this.fixed === true || this.fixed === 'left') {
          return index >= this.leftFixedLeafCount;
        } else if (this.fixed === 'right') {
          var before = 0;
          for (var i = 0; i < index; i++) {
            before += columns[i].colSpan;
          }
          return before < this.columnsCount - this.rightFixedLeafCount;
        } else if (!this.fixed && column.fixed) {
          // hide cell when footer instance is not fixed and column is fixed
          return true;
        } else {
          return index < this.leftFixedCount || index >= this.columnsCount - this.rightFixedCount;
        }
      },
      getRowClasses: function getRowClasses(column, cellIndex) {
        var classes = [column.id, column.align, column.labelClassName];
        if (column.className) {
          classes.push(column.className);
        }
        if (this.isCellHidden(cellIndex, this.columns, column)) {
          classes.push('is-hidden');
        }
        if (!column.children) {
          classes.push('is-leaf');
        }
        return classes;
      }
    }
  };
  // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/table.vue?vue&type=script&lang=js&
  var tablevue_type_script_lang_js_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  var tableIdSeed = 1;

  /* harmony default export */
  var tablevue_type_script_lang_js_ = {
    name: 'ElTable',
    mixins: [locale_default.a, migrating_default.a],
    directives: {
      Mousewheel: directives_mousewheel
    },
    props: {
      data: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      size: String,
      width: [String, Number],
      height: [String, Number],
      maxHeight: [String, Number],
      fit: {
        type: Boolean,
        default: true
      },
      stripe: Boolean,
      border: Boolean,
      rowKey: [String, Function],
      context: {},
      showHeader: {
        type: Boolean,
        default: true
      },
      showSummary: Boolean,
      sumText: String,
      summaryMethod: Function,
      rowClassName: [String, Function],
      rowStyle: [Object, Function],
      cellClassName: [String, Function],
      cellStyle: [Object, Function],
      headerRowClassName: [String, Function],
      headerRowStyle: [Object, Function],
      headerCellClassName: [String, Function],
      headerCellStyle: [Object, Function],
      highlightCurrentRow: Boolean,
      currentRowKey: [String, Number],
      emptyText: String,
      expandRowKeys: Array,
      defaultExpandAll: Boolean,
      defaultSort: Object,
      tooltipEffect: String,
      spanMethod: Function,
      selectOnIndeterminate: {
        type: Boolean,
        default: true
      },
      indent: {
        type: Number,
        default: 16
      },
      treeProps: {
        type: Object,
        default: function _default() {
          return {
            hasChildren: 'hasChildren',
            children: 'children'
          };
        }
      },
      lazy: Boolean,
      load: Function
    },
    components: {
      TableHeader: table_header,
      TableFooter: table_footer,
      TableBody: table_body,
      ElCheckbox: checkbox_default.a
    },
    methods: {
      getMigratingConfig: function getMigratingConfig() {
        return {
          events: {
            expand: 'expand is renamed to expand-change'
          }
        };
      },
      setCurrentRow: function setCurrentRow(row) {
        this.store.commit('setCurrentRow', row);
      },
      toggleRowSelection: function toggleRowSelection(row, selected) {
        this.store.toggleRowSelection(row, selected, false);
        this.store.updateAllSelected();
      },
      toggleRowExpansion: function toggleRowExpansion(row, expanded) {
        this.store.toggleRowExpansionAdapter(row, expanded);
      },
      clearSelection: function clearSelection() {
        this.store.clearSelection();
      },
      clearFilter: function clearFilter(columnKeys) {
        this.store.clearFilter(columnKeys);
      },
      clearSort: function clearSort() {
        this.store.clearSort();
      },
      handleMouseLeave: function handleMouseLeave() {
        this.store.commit('setHoverRow', null);
        if (this.hoverState) this.hoverState = null;
      },
      updateScrollY: function updateScrollY() {
        var changed = this.layout.updateScrollY();
        if (changed) {
          this.layout.notifyObservers('scrollable');
          this.layout.updateColumnsWidth();
        }
      },
      handleFixedMousewheel: function handleFixedMousewheel(event, data) {
        var bodyWrapper = this.bodyWrapper;
        if (Math.abs(data.spinY) > 0) {
          var currentScrollTop = bodyWrapper.scrollTop;
          if (data.pixelY < 0 && currentScrollTop !== 0) {
            event.preventDefault();
          }
          if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
            event.preventDefault();
          }
          bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
        } else {
          bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
        }
      },
      handleHeaderFooterMousewheel: function handleHeaderFooterMousewheel(event, data) {
        var pixelX = data.pixelX,
          pixelY = data.pixelY;
        if (Math.abs(pixelX) >= Math.abs(pixelY)) {
          this.bodyWrapper.scrollLeft += data.pixelX / 5;
        }
      },
      // TODO 使用 CSS transform
      syncPostion: function syncPostion() {
        var _bodyWrapper = this.bodyWrapper,
          scrollLeft = _bodyWrapper.scrollLeft,
          scrollTop = _bodyWrapper.scrollTop,
          offsetWidth = _bodyWrapper.offsetWidth,
          scrollWidth = _bodyWrapper.scrollWidth;
        var _$refs = this.$refs,
          headerWrapper = _$refs.headerWrapper,
          footerWrapper = _$refs.footerWrapper,
          fixedBodyWrapper = _$refs.fixedBodyWrapper,
          rightFixedBodyWrapper = _$refs.rightFixedBodyWrapper;
        if (headerWrapper) headerWrapper.scrollLeft = scrollLeft;
        if (footerWrapper) footerWrapper.scrollLeft = scrollLeft;
        if (fixedBodyWrapper) fixedBodyWrapper.scrollTop = scrollTop;
        if (rightFixedBodyWrapper) rightFixedBodyWrapper.scrollTop = scrollTop;
        var maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
        if (scrollLeft >= maxScrollLeftPosition) {
          this.scrollPosition = 'right';
        } else if (scrollLeft === 0) {
          this.scrollPosition = 'left';
        } else {
          this.scrollPosition = 'middle';
        }
      },
      throttleSyncPostion: Object(external_throttle_debounce_["throttle"])(16, function () {
        this.syncPostion();
      }),
      onScroll: function onScroll(evt) {
        var raf = window.requestAnimationFrame;
        if (!raf) {
          this.throttleSyncPostion();
        } else {
          raf(this.syncPostion);
        }
      },
      bindEvents: function bindEvents() {
        this.bodyWrapper.addEventListener('scroll', this.onScroll, {
          passive: true
        });
        if (this.fit) {
          Object(resize_event_["addResizeListener"])(this.$el, this.resizeListener);
        }
      },
      unbindEvents: function unbindEvents() {
        this.bodyWrapper.removeEventListener('scroll', this.onScroll, {
          passive: true
        });
        if (this.fit) {
          Object(resize_event_["removeResizeListener"])(this.$el, this.resizeListener);
        }
      },
      resizeListener: function resizeListener() {
        if (!this.$ready) return;
        var shouldUpdateLayout = false;
        var el = this.$el;
        var _resizeState = this.resizeState,
          oldWidth = _resizeState.width,
          oldHeight = _resizeState.height;
        var width = el.offsetWidth;
        if (oldWidth !== width) {
          shouldUpdateLayout = true;
        }
        var height = el.offsetHeight;
        if ((this.height || this.shouldUpdateHeight) && oldHeight !== height) {
          shouldUpdateLayout = true;
        }
        if (shouldUpdateLayout) {
          this.resizeState.width = width;
          this.resizeState.height = height;
          this.doLayout();
        }
      },
      doLayout: function doLayout() {
        if (this.shouldUpdateHeight) {
          this.layout.updateElsHeight();
        }
        this.layout.updateColumnsWidth();
      },
      sort: function sort(prop, order) {
        this.store.commit('sort', {
          prop: prop,
          order: order
        });
      },
      toggleAllSelection: function toggleAllSelection() {
        this.store.commit('toggleAllSelection');
      }
    },
    computed: tablevue_type_script_lang_js_extends({
      tableSize: function tableSize() {
        return this.size || (this.$ELEMENT || {}).size;
      },
      bodyWrapper: function bodyWrapper() {
        return this.$refs.bodyWrapper;
      },
      shouldUpdateHeight: function shouldUpdateHeight() {
        return this.height || this.maxHeight || this.fixedColumns.length > 0 || this.rightFixedColumns.length > 0;
      },
      bodyWidth: function bodyWidth() {
        var _layout = this.layout,
          bodyWidth = _layout.bodyWidth,
          scrollY = _layout.scrollY,
          gutterWidth = _layout.gutterWidth;
        return bodyWidth ? bodyWidth - (scrollY ? gutterWidth : 0) + 'px' : '';
      },
      bodyHeight: function bodyHeight() {
        var _layout2 = this.layout,
          _layout2$headerHeight = _layout2.headerHeight,
          headerHeight = _layout2$headerHeight === undefined ? 0 : _layout2$headerHeight,
          bodyHeight = _layout2.bodyHeight,
          _layout2$footerHeight = _layout2.footerHeight,
          footerHeight = _layout2$footerHeight === undefined ? 0 : _layout2$footerHeight;
        if (this.height) {
          return {
            height: bodyHeight ? bodyHeight + 'px' : ''
          };
        } else if (this.maxHeight) {
          var maxHeight = Object(util["j" /* parseHeight */])(this.maxHeight);
          if (typeof maxHeight === 'number') {
            return {
              'max-height': maxHeight - footerHeight - (this.showHeader ? headerHeight : 0) + 'px'
            };
          }
        }
        return {};
      },
      fixedBodyHeight: function fixedBodyHeight() {
        if (this.height) {
          return {
            height: this.layout.fixedBodyHeight ? this.layout.fixedBodyHeight + 'px' : ''
          };
        } else if (this.maxHeight) {
          var maxHeight = Object(util["j" /* parseHeight */])(this.maxHeight);
          if (typeof maxHeight === 'number') {
            maxHeight = this.layout.scrollX ? maxHeight - this.layout.gutterWidth : maxHeight;
            if (this.showHeader) {
              maxHeight -= this.layout.headerHeight;
            }
            maxHeight -= this.layout.footerHeight;
            return {
              'max-height': maxHeight + 'px'
            };
          }
        }
        return {};
      },
      fixedHeight: function fixedHeight() {
        if (this.maxHeight) {
          if (this.showSummary) {
            return {
              bottom: 0
            };
          }
          return {
            bottom: this.layout.scrollX && this.data.length ? this.layout.gutterWidth + 'px' : ''
          };
        } else {
          if (this.showSummary) {
            return {
              height: this.layout.tableHeight ? this.layout.tableHeight + 'px' : ''
            };
          }
          return {
            height: this.layout.viewportHeight ? this.layout.viewportHeight + 'px' : ''
          };
        }
      },
      emptyBlockStyle: function emptyBlockStyle() {
        if (this.data && this.data.length) return null;
        var height = '100%';
        if (this.layout.appendHeight) {
          height = 'calc(100% - ' + this.layout.appendHeight + 'px)';
        }
        return {
          width: this.bodyWidth,
          height: height
        };
      }
    }, mapStates({
      selection: 'selection',
      columns: 'columns',
      tableData: 'data',
      fixedColumns: 'fixedColumns',
      rightFixedColumns: 'rightFixedColumns'
    })),
    watch: {
      height: {
        immediate: true,
        handler: function handler(value) {
          this.layout.setHeight(value);
        }
      },
      maxHeight: {
        immediate: true,
        handler: function handler(value) {
          this.layout.setMaxHeight(value);
        }
      },
      currentRowKey: {
        immediate: true,
        handler: function handler(value) {
          if (!this.rowKey) return;
          this.store.setCurrentRowKey(value);
        }
      },
      data: {
        immediate: true,
        handler: function handler(value) {
          this.store.commit('setData', value);
        }
      },
      expandRowKeys: {
        immediate: true,
        handler: function handler(newVal) {
          if (newVal) {
            this.store.setExpandRowKeysAdapter(newVal);
          }
        }
      }
    },
    created: function created() {
      var _this = this;
      this.tableId = 'el-table_' + tableIdSeed++;
      this.debouncedUpdateLayout = Object(external_throttle_debounce_["debounce"])(50, function () {
        return _this.doLayout();
      });
    },
    mounted: function mounted() {
      var _this2 = this;
      this.bindEvents();
      this.store.updateColumns();
      this.doLayout();
      this.resizeState = {
        width: this.$el.offsetWidth,
        height: this.$el.offsetHeight
      };

      // init filters
      this.store.states.columns.forEach(function (column) {
        if (column.filteredValue && column.filteredValue.length) {
          _this2.store.commit('filterChange', {
            column: column,
            values: column.filteredValue,
            silent: true
          });
        }
      });
      this.$ready = true;
    },
    destroyed: function destroyed() {
      this.unbindEvents();
    },
    data: function data() {
      var _treeProps = this.treeProps,
        _treeProps$hasChildre = _treeProps.hasChildren,
        hasChildren = _treeProps$hasChildre === undefined ? 'hasChildren' : _treeProps$hasChildre,
        _treeProps$children = _treeProps.children,
        children = _treeProps$children === undefined ? 'children' : _treeProps$children;
      this.store = createStore(this, {
        rowKey: this.rowKey,
        defaultExpandAll: this.defaultExpandAll,
        selectOnIndeterminate: this.selectOnIndeterminate,
        // TreeTable 的相关配置
        indent: this.indent,
        lazy: this.lazy,
        lazyColumnIdentifier: hasChildren,
        childrenColumnName: children
      });
      var layout = new table_layout({
        store: this.store,
        table: this,
        fit: this.fit,
        showHeader: this.showHeader
      });
      return {
        layout: layout,
        isHidden: false,
        renderExpanded: null,
        resizeProxyVisible: false,
        resizeState: {
          width: null,
          height: null
        },
        // 是否拥有多级表头
        isGroup: false,
        scrollPosition: 'left'
      };
    }
  };
  // CONCATENATED MODULE: ./packages/table/src/table.vue?vue&type=script&lang=js&
  /* harmony default export */
  var src_tablevue_type_script_lang_js_ = tablevue_type_script_lang_js_;
  // CONCATENATED MODULE: ./packages/table/src/table.vue

  /* normalize component */

  var table_component = Object(componentNormalizer["a" /* default */])(src_tablevue_type_script_lang_js_, render, staticRenderFns, false, null, null, null);

  /* hot reload */
  if (false) { var table_api; }
  table_component.options.__file = "packages/table/src/table.vue";
  /* harmony default export */
  var src_table = table_component.exports;
  // CONCATENATED MODULE: ./packages/table/index.js

  /* istanbul ignore next */
  src_table.install = function (Vue) {
    Vue.component(src_table.name, src_table);
  };

  /* harmony default export */
  var packages_table = __nested_webpack_exports__["default"] = src_table;

  /***/
}
/******/]);

/***/ }),

/***/ 849:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = /******/function (modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/
  var installedModules = {};
  /******/
  /******/ // The require function
  /******/
  function __nested_webpack_require_198__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/if (installedModules[moduleId]) {
      /******/return installedModules[moduleId].exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/
    var module = installedModules[moduleId] = {
      /******/i: moduleId,
      /******/l: false,
      /******/exports: {}
      /******/
    };
    /******/
    /******/ // Execute the module function
    /******/
    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_198__);
    /******/
    /******/ // Flag the module as loaded
    /******/
    module.l = true;
    /******/
    /******/ // Return the exports of the module
    /******/
    return module.exports;
    /******/
  }
  /******/
  /******/
  /******/ // expose the modules object (__webpack_modules__)
  /******/
  __nested_webpack_require_198__.m = modules;
  /******/
  /******/ // expose the module cache
  /******/
  __nested_webpack_require_198__.c = installedModules;
  /******/
  /******/ // define getter function for harmony exports
  /******/
  __nested_webpack_require_198__.d = function (exports, name, getter) {
    /******/if (!__nested_webpack_require_198__.o(exports, name)) {
      /******/Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/
  };
  /******/
  /******/ // define __esModule on exports
  /******/
  __nested_webpack_require_198__.r = function (exports) {
    /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/
  /******/ // create a fake namespace object
  /******/ // mode & 1: value is a module id, require it
  /******/ // mode & 2: merge all properties of value into the ns
  /******/ // mode & 4: return value when already ns object
  /******/ // mode & 8|1: behave like require
  /******/
  __nested_webpack_require_198__.t = function (value, mode) {
    /******/if (mode & 1) value = __nested_webpack_require_198__(value);
    /******/
    if (mode & 8) return value;
    /******/
    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
    /******/
    var ns = Object.create(null);
    /******/
    __nested_webpack_require_198__.r(ns);
    /******/
    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/
    if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_198__.d(ns, key, function (key) {
      return value[key];
    }.bind(null, key));
    /******/
    return ns;
    /******/
  };
  /******/
  /******/ // getDefaultExport function for compatibility with non-harmony modules
  /******/
  __nested_webpack_require_198__.n = function (module) {
    /******/var getter = module && module.__esModule ? /******/function getDefault() {
      return module['default'];
    } : /******/function getModuleExports() {
      return module;
    };
    /******/
    __nested_webpack_require_198__.d(getter, 'a', getter);
    /******/
    return getter;
    /******/
  };
  /******/
  /******/ // Object.prototype.hasOwnProperty.call
  /******/
  __nested_webpack_require_198__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/
  /******/ // __webpack_public_path__
  /******/
  __nested_webpack_require_198__.p = "/dist/";
  /******/
  /******/
  /******/ // Load entry module and return exports
  /******/
  return __nested_webpack_require_198__(__nested_webpack_require_198__.s = 138);
  /******/
}
/************************************************************************/
/******/({
  /***/138: /***/function (module, __nested_webpack_exports__, __nested_webpack_require_4033__) {
    "use strict";

    __nested_webpack_require_4033__.r(__nested_webpack_exports__);

    // EXTERNAL MODULE: external "element-ui/lib/utils/vue-popper"
    var vue_popper_ = __nested_webpack_require_4033__(5);
    var vue_popper_default = /*#__PURE__*/__nested_webpack_require_4033__.n(vue_popper_);

    // EXTERNAL MODULE: external "throttle-debounce/debounce"
    var debounce_ = __nested_webpack_require_4033__(19);
    var debounce_default = /*#__PURE__*/__nested_webpack_require_4033__.n(debounce_);

    // EXTERNAL MODULE: external "element-ui/lib/utils/dom"
    var dom_ = __nested_webpack_require_4033__(2);

    // EXTERNAL MODULE: external "element-ui/lib/utils/util"
    var util_ = __nested_webpack_require_4033__(3);

    // EXTERNAL MODULE: external "vue"
    var external_vue_ = __nested_webpack_require_4033__(7);
    var external_vue_default = /*#__PURE__*/__nested_webpack_require_4033__.n(external_vue_);

    // CONCATENATED MODULE: ./packages/tooltip/src/main.js

    /* harmony default export */
    var main = {
      name: 'ElTooltip',
      mixins: [vue_popper_default.a],
      props: {
        openDelay: {
          type: Number,
          default: 0
        },
        disabled: Boolean,
        manual: Boolean,
        effect: {
          type: String,
          default: 'dark'
        },
        arrowOffset: {
          type: Number,
          default: 0
        },
        popperClass: String,
        content: String,
        visibleArrow: {
          default: true
        },
        transition: {
          type: String,
          default: 'el-fade-in-linear'
        },
        popperOptions: {
          default: function _default() {
            return {
              boundariesPadding: 10,
              gpuAcceleration: false
            };
          }
        },
        enterable: {
          type: Boolean,
          default: true
        },
        hideAfter: {
          type: Number,
          default: 0
        },
        tabindex: {
          type: Number,
          default: 0
        }
      },
      data: function data() {
        return {
          tooltipId: 'el-tooltip-' + Object(util_["generateId"])(),
          timeoutPending: null,
          focusing: false
        };
      },
      beforeCreate: function beforeCreate() {
        var _this = this;
        if (this.$isServer) return;
        this.popperVM = new external_vue_default.a({
          data: {
            node: ''
          },
          render: function render(h) {
            return this.node;
          }
        }).$mount();
        this.debounceClose = debounce_default()(200, function () {
          return _this.handleClosePopper();
        });
      },
      render: function render(h) {
        var _this2 = this;
        if (this.popperVM) {
          this.popperVM.node = h('transition', {
            attrs: {
              name: this.transition
            },
            on: {
              'afterLeave': this.doDestroy
            }
          }, [h('div', {
            on: {
              'mouseleave': function mouseleave() {
                _this2.setExpectedState(false);
                _this2.debounceClose();
              },
              'mouseenter': function mouseenter() {
                _this2.setExpectedState(true);
              }
            },
            ref: 'popper',
            attrs: {
              role: 'tooltip',
              id: this.tooltipId,
              'aria-hidden': this.disabled || !this.showPopper ? 'true' : 'false'
            },
            directives: [{
              name: 'show',
              value: !this.disabled && this.showPopper
            }],
            'class': ['el-tooltip__popper', 'is-' + this.effect, this.popperClass]
          }, [this.$slots.content || this.content])]);
        }
        var firstElement = this.getFirstElement();
        if (!firstElement) return null;
        var data = firstElement.data = firstElement.data || {};
        data.staticClass = this.addTooltipClass(data.staticClass);
        return firstElement;
      },
      mounted: function mounted() {
        var _this3 = this;
        this.referenceElm = this.$el;
        if (this.$el.nodeType === 1) {
          this.$el.setAttribute('aria-describedby', this.tooltipId);
          this.$el.setAttribute('tabindex', this.tabindex);
          Object(dom_["on"])(this.referenceElm, 'mouseenter', this.show);
          Object(dom_["on"])(this.referenceElm, 'mouseleave', this.hide);
          Object(dom_["on"])(this.referenceElm, 'focus', function () {
            if (!_this3.$slots.default || !_this3.$slots.default.length) {
              _this3.handleFocus();
              return;
            }
            var instance = _this3.$slots.default[0].componentInstance;
            if (instance && instance.focus) {
              instance.focus();
            } else {
              _this3.handleFocus();
            }
          });
          Object(dom_["on"])(this.referenceElm, 'blur', this.handleBlur);
          Object(dom_["on"])(this.referenceElm, 'click', this.removeFocusing);
        }
        // fix issue https://github.com/ElemeFE/element/issues/14424
        if (this.value && this.popperVM) {
          this.popperVM.$nextTick(function () {
            if (_this3.value) {
              _this3.updatePopper();
            }
          });
        }
      },
      watch: {
        focusing: function focusing(val) {
          if (val) {
            Object(dom_["addClass"])(this.referenceElm, 'focusing');
          } else {
            Object(dom_["removeClass"])(this.referenceElm, 'focusing');
          }
        }
      },
      methods: {
        show: function show() {
          this.setExpectedState(true);
          this.handleShowPopper();
        },
        hide: function hide() {
          this.setExpectedState(false);
          this.debounceClose();
        },
        handleFocus: function handleFocus() {
          this.focusing = true;
          this.show();
        },
        handleBlur: function handleBlur() {
          this.focusing = false;
          this.hide();
        },
        removeFocusing: function removeFocusing() {
          this.focusing = false;
        },
        addTooltipClass: function addTooltipClass(prev) {
          if (!prev) {
            return 'el-tooltip';
          } else {
            return 'el-tooltip ' + prev.replace('el-tooltip', '');
          }
        },
        handleShowPopper: function handleShowPopper() {
          var _this4 = this;
          if (!this.expectedState || this.manual) return;
          clearTimeout(this.timeout);
          this.timeout = setTimeout(function () {
            _this4.showPopper = true;
          }, this.openDelay);
          if (this.hideAfter > 0) {
            this.timeoutPending = setTimeout(function () {
              _this4.showPopper = false;
            }, this.hideAfter);
          }
        },
        handleClosePopper: function handleClosePopper() {
          if (this.enterable && this.expectedState || this.manual) return;
          clearTimeout(this.timeout);
          if (this.timeoutPending) {
            clearTimeout(this.timeoutPending);
          }
          this.showPopper = false;
          if (this.disabled) {
            this.doDestroy();
          }
        },
        setExpectedState: function setExpectedState(expectedState) {
          if (expectedState === false) {
            clearTimeout(this.timeoutPending);
          }
          this.expectedState = expectedState;
        },
        getFirstElement: function getFirstElement() {
          var slots = this.$slots.default;
          if (!Array.isArray(slots)) return null;
          var element = null;
          for (var index = 0; index < slots.length; index++) {
            if (slots[index] && slots[index].tag) {
              element = slots[index];
              break;
            }
            ;
          }
          return element;
        }
      },
      beforeDestroy: function beforeDestroy() {
        this.popperVM && this.popperVM.$destroy();
      },
      destroyed: function destroyed() {
        var reference = this.referenceElm;
        if (reference.nodeType === 1) {
          Object(dom_["off"])(reference, 'mouseenter', this.show);
          Object(dom_["off"])(reference, 'mouseleave', this.hide);
          Object(dom_["off"])(reference, 'focus', this.handleFocus);
          Object(dom_["off"])(reference, 'blur', this.handleBlur);
          Object(dom_["off"])(reference, 'click', this.removeFocusing);
        }
      }
    };
    // CONCATENATED MODULE: ./packages/tooltip/index.js

    /* istanbul ignore next */
    main.install = function (Vue) {
      Vue.component(main.name, main);
    };

    /* harmony default export */
    var tooltip = __nested_webpack_exports__["default"] = main;

    /***/
  },

  /***/19: /***/function (module, exports) {
    module.exports = __webpack_require__(492);

    /***/
  },

  /***/2: /***/function (module, exports) {
    module.exports = __webpack_require__(597);

    /***/
  },

  /***/3: /***/function (module, exports) {
    module.exports = __webpack_require__(125);

    /***/
  },

  /***/5: /***/function (module, exports) {
    module.exports = __webpack_require__(617);

    /***/
  },

  /***/7: /***/function (module, exports) {
    module.exports = __webpack_require__(203);

    /***/
  }

  /******/
});

/***/ }),

/***/ 486:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var _vue = __webpack_require__(203);
var _vue2 = _interopRequireDefault(_vue);
var _dom = __webpack_require__(597);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var nodeList = [];
var ctx = '@@clickoutsideContext';
var startClick = void 0;
var seed = 0;
!_vue2.default.prototype.$isServer && (0, _dom.on)(document, 'mousedown', function (e) {
  return startClick = e;
});
!_vue2.default.prototype.$isServer && (0, _dom.on)(document, 'mouseup', function (e) {
  nodeList.forEach(function (node) {
    return node[ctx].documentHandler(e, startClick);
  });
});
function createDocumentHandler(el, binding, vnode) {
  return function () {
    var mouseup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var mousedown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!vnode || !vnode.context || !mouseup.target || !mousedown.target || el.contains(mouseup.target) || el.contains(mousedown.target) || el === mouseup.target || vnode.context.popperElm && (vnode.context.popperElm.contains(mouseup.target) || vnode.context.popperElm.contains(mousedown.target))) return;
    if (binding.expression && el[ctx].methodName && vnode.context[el[ctx].methodName]) {
      vnode.context[el[ctx].methodName]();
    } else {
      el[ctx].bindingFn && el[ctx].bindingFn();
    }
  };
}

/**
 * v-clickoutside
 * @desc 点击元素外面才会触发的事件
 * @example
 * ```vue
 * <div v-element-clickoutside="handleClose">
 * ```
 */
exports["default"] = {
  bind: function bind(el, binding, vnode) {
    nodeList.push(el);
    var id = seed++;
    el[ctx] = {
      id: id,
      documentHandler: createDocumentHandler(el, binding, vnode),
      methodName: binding.expression,
      bindingFn: binding.value
    };
  },
  update: function update(el, binding, vnode) {
    el[ctx].documentHandler = createDocumentHandler(el, binding, vnode);
    el[ctx].methodName = binding.expression;
    el[ctx].bindingFn = binding.value;
  },
  unbind: function unbind(el) {
    var len = nodeList.length;
    for (var i = 0; i < len; i++) {
      if (nodeList[i][ctx].id === el[ctx].id) {
        nodeList.splice(i, 1);
        break;
      }
    }
    delete el[ctx];
  }
};

/***/ }),

/***/ 597:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isInContainer = exports.getScrollContainer = exports.isScroll = exports.getStyle = exports.once = exports.off = exports.on = undefined;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
}; /* istanbul ignore next */

exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.setStyle = setStyle;
var _vue = __webpack_require__(203);
var _vue2 = _interopRequireDefault(_vue);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var isServer = _vue2.default.prototype.$isServer;
var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
var MOZ_HACK_REGEXP = /^moz([A-Z])/;
var ieVersion = isServer ? 0 : Number(document.documentMode);

/* istanbul ignore next */
var trim = function trim(string) {
  return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
};
/* istanbul ignore next */
var camelCase = function camelCase(name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
};

/* istanbul ignore next */
var on = exports.on = function () {
  if (!isServer && document.addEventListener) {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.addEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.attachEvent('on' + event, handler);
      }
    };
  }
}();

/* istanbul ignore next */
var off = exports.off = function () {
  if (!isServer && document.removeEventListener) {
    return function (element, event, handler) {
      if (element && event) {
        element.removeEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event) {
        element.detachEvent('on' + event, handler);
      }
    };
  }
}();

/* istanbul ignore next */
var once = exports.once = function once(el, event, fn) {
  var listener = function listener() {
    if (fn) {
      fn.apply(this, arguments);
    }
    off(el, event, listener);
  };
  on(el, event, listener);
};

/* istanbul ignore next */
function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');
  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
}
;

/* istanbul ignore next */
function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || '').split(' ');
  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;
    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += ' ' + clsName;
    }
  }
  if (!el.classList) {
    el.setAttribute('class', curClass);
  }
}
;

/* istanbul ignore next */
function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(' ');
  var curClass = ' ' + el.className + ' ';
  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;
    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(' ' + clsName + ' ', ' ');
    }
  }
  if (!el.classList) {
    el.setAttribute('class', trim(curClass));
  }
}
;

/* istanbul ignore next */
var getStyle = exports.getStyle = ieVersion < 9 ? function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'styleFloat';
  }
  try {
    switch (styleName) {
      case 'opacity':
        try {
          return element.filters.item('alpha').opacity / 100;
        } catch (e) {
          return 1.0;
        }
      default:
        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
    }
  } catch (e) {
    return element.style[styleName];
  }
} : function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'cssFloat';
  }
  try {
    var computed = document.defaultView.getComputedStyle(element, '');
    return element.style[styleName] || computed ? computed[styleName] : null;
  } catch (e) {
    return element.style[styleName];
  }
};

/* istanbul ignore next */
function setStyle(element, styleName, value) {
  if (!element || !styleName) return;
  if ((typeof styleName === 'undefined' ? 'undefined' : _typeof(styleName)) === 'object') {
    for (var prop in styleName) {
      if (styleName.hasOwnProperty(prop)) {
        setStyle(element, prop, styleName[prop]);
      }
    }
  } else {
    styleName = camelCase(styleName);
    if (styleName === 'opacity' && ieVersion < 9) {
      element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';
    } else {
      element.style[styleName] = value;
    }
  }
}
;
var isScroll = exports.isScroll = function isScroll(el, vertical) {
  if (isServer) return;
  var determinedDirection = vertical !== null && vertical !== undefined;
  var overflow = determinedDirection ? vertical ? getStyle(el, 'overflow-y') : getStyle(el, 'overflow-x') : getStyle(el, 'overflow');
  return overflow.match(/(scroll|auto|overlay)/);
};
var getScrollContainer = exports.getScrollContainer = function getScrollContainer(el, vertical) {
  if (isServer) return;
  var parent = el;
  while (parent) {
    if ([window, document, document.documentElement].includes(parent)) {
      return window;
    }
    if (isScroll(parent, vertical)) {
      return parent;
    }
    parent = parent.parentNode;
  }
  return parent;
};
var isInContainer = exports.isInContainer = function isInContainer(el, container) {
  if (isServer || !el || !container) return false;
  var elRect = el.getBoundingClientRect();
  var containerRect = void 0;
  if ([window, document, document.documentElement, null, undefined].includes(container)) {
    containerRect = {
      top: 0,
      right: window.innerWidth,
      bottom: window.innerHeight,
      left: 0
    };
  } else {
    containerRect = container.getBoundingClientRect();
  }
  return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
};

/***/ }),

/***/ 186:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.__esModule = true;
exports["default"] = function (target) {
  for (var i = 1, j = arguments.length; i < j; i++) {
    var source = arguments[i] || {};
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        var value = source[prop];
        if (value !== undefined) {
          target[prop] = value;
        }
      }
    }
  }
  return target;
};
;

/***/ }),

/***/ 235:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

/**
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version {{version}}
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

//
// Cross module loader
// Supported: Node, AMD, Browser globals
//
;
(function (root, factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(undefined, function () {
  'use strict';

  var root = window;

  // default options
  var DEFAULTS = {
    // placement of the popper
    placement: 'bottom',
    gpuAcceleration: true,
    // shift popper from its origin by the given amount of pixels (can be negative)
    offset: 0,
    // the element which will act as boundary of the popper
    boundariesElement: 'viewport',
    // amount of pixel used to define a minimum distance between the boundaries and the popper
    boundariesPadding: 5,
    // popper will try to prevent overflow following this order,
    // by default, then, it could overflow on the left and on top of the boundariesElement
    preventOverflowOrder: ['left', 'right', 'top', 'bottom'],
    // the behavior used by flip to change the placement of the popper
    flipBehavior: 'flip',
    arrowElement: '[x-arrow]',
    arrowOffset: 0,
    // list of functions used to modify the offsets before they are applied to the popper
    modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],
    modifiersIgnored: [],
    forceAbsolute: false
  };

  /**
   * Create a new Popper.js instance
   * @constructor Popper
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement|Object} popper
   *      The HTML element used as popper, or a configuration used to generate the popper.
   * @param {String} [popper.tagName='div'] The tag name of the generated popper.
   * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.
   * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.
   * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.
   * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.
   * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.
   * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.
   * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.
   * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.
   * @param {Object} options
   * @param {String} [options.placement=bottom]
   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),
   *      left(-start, -end)`
   *
   * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']
   *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of
   *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its
   *      reference element.
   *      By default, it will look for a child node of the popper with the `x-arrow` attribute.
   *
   * @param {Boolean} [options.gpuAcceleration=true]
   *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the
   *      browser to use the GPU to accelerate the rendering.
   *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.
   *
   * @param {Number} [options.offset=0]
   *      Amount of pixels the popper will be shifted (can be negative).
   *
   * @param {String|Element} [options.boundariesElement='viewport']
   *      The element which will define the boundaries of the popper position, the popper will never be placed outside
   *      of the defined boundaries (except if `keepTogether` is enabled)
   *
   * @param {Number} [options.boundariesPadding=5]
   *      Additional padding for the boundaries
   *
   * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]
   *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,
   *      this means that the last ones will never overflow
   *
   * @param {String|Array} [options.flipBehavior='flip']
   *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to
   *      overlap its reference element. Defining `flip` as value, the placement will be flipped on
   *      its axis (`right - left`, `top - bottom`).
   *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify
   *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,
   *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)
   *
   * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]
   *      List of functions used to modify the data before they are applied to the popper, add your custom functions
   *      to this array to edit the offsets and placement.
   *      The function should reflect the @params and @returns of preventOverflow
   *
   * @param {Array} [options.modifiersIgnored=[]]
   *      Put here any built-in modifier name you want to exclude from the modifiers list
   *      The function should reflect the @params and @returns of preventOverflow
   *
   * @param {Boolean} [options.removeOnDestroy=false]
   *      Set to true if you want to automatically remove the popper when you call the `destroy` method.
   */
  function Popper(reference, popper, options) {
    this._reference = reference.jquery ? reference[0] : reference;
    this.state = {};

    // if the popper variable is a configuration object, parse it to generate an HTMLElement
    // generate a default popper if is not defined
    var isNotDefined = typeof popper === 'undefined' || popper === null;
    var isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';
    if (isNotDefined || isConfig) {
      this._popper = this.parse(isConfig ? popper : {});
    }
    // otherwise, use the given HTMLElement as popper
    else {
      this._popper = popper.jquery ? popper[0] : popper;
    }

    // with {} we create a new object with the options inside it
    this._options = Object.assign({}, DEFAULTS, options);

    // refactoring modifiers' list
    this._options.modifiers = this._options.modifiers.map(function (modifier) {
      // remove ignored modifiers
      if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return;

      // set the x-placement attribute before everything else because it could be used to add margins to the popper
      // margins needs to be calculated to get the correct popper offsets
      if (modifier === 'applyStyle') {
        this._popper.setAttribute('x-placement', this._options.placement);
      }

      // return predefined modifier identified by string or keep the custom one
      return this.modifiers[modifier] || modifier;
    }.bind(this));

    // make sure to apply the popper position before any computation
    this.state.position = this._getPosition(this._popper, this._reference);
    setStyle(this._popper, {
      position: this.state.position,
      top: 0
    });

    // fire the first update to position the popper in the right place
    this.update();

    // setup event listeners, they will take care of update the position in specific situations
    this._setupEventListeners();
    return this;
  }

  //
  // Methods
  //
  /**
   * Destroy the popper
   * @method
   * @memberof Popper
   */
  Popper.prototype.destroy = function () {
    this._popper.removeAttribute('x-placement');
    this._popper.style.left = '';
    this._popper.style.position = '';
    this._popper.style.top = '';
    this._popper.style[getSupportedPropertyName('transform')] = '';
    this._removeEventListeners();

    // remove the popper if user explicity asked for the deletion on destroy
    if (this._options.removeOnDestroy) {
      this._popper.remove();
    }
    return this;
  };

  /**
   * Updates the position of the popper, computing the new offsets and applying the new style
   * @method
   * @memberof Popper
   */
  Popper.prototype.update = function () {
    var data = {
      instance: this,
      styles: {}
    };

    // store placement inside the data object, modifiers will be able to edit `placement` if needed
    // and refer to _originalPlacement to know the original value
    data.placement = this._options.placement;
    data._originalPlacement = this._options.placement;

    // compute the popper and reference offsets and put them inside data.offsets
    data.offsets = this._getOffsets(this._popper, this._reference, data.placement);

    // get boundaries
    data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);
    data = this.runModifiers(data, this._options.modifiers);
    if (typeof this.state.updateCallback === 'function') {
      this.state.updateCallback(data);
    }
  };

  /**
   * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.
   * @method
   * @memberof Popper
   * @param {Function} callback
   */
  Popper.prototype.onCreate = function (callback) {
    // the createCallbacks return as first argument the popper instance
    callback(this);
    return this;
  };

  /**
   * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations
   * used to style popper and its arrow.
   * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!
   * @method
   * @memberof Popper
   * @param {Function} callback
   */
  Popper.prototype.onUpdate = function (callback) {
    this.state.updateCallback = callback;
    return this;
  };

  /**
   * Helper used to generate poppers from a configuration file
   * @method
   * @memberof Popper
   * @param config {Object} configuration
   * @returns {HTMLElement} popper
   */
  Popper.prototype.parse = function (config) {
    var defaultConfig = {
      tagName: 'div',
      classNames: ['popper'],
      attributes: [],
      parent: root.document.body,
      content: '',
      contentType: 'text',
      arrowTagName: 'div',
      arrowClassNames: ['popper__arrow'],
      arrowAttributes: ['x-arrow']
    };
    config = Object.assign({}, defaultConfig, config);
    var d = root.document;
    var popper = d.createElement(config.tagName);
    addClassNames(popper, config.classNames);
    addAttributes(popper, config.attributes);
    if (config.contentType === 'node') {
      popper.appendChild(config.content.jquery ? config.content[0] : config.content);
    } else if (config.contentType === 'html') {
      popper.innerHTML = config.content;
    } else {
      popper.textContent = config.content;
    }
    if (config.arrowTagName) {
      var arrow = d.createElement(config.arrowTagName);
      addClassNames(arrow, config.arrowClassNames);
      addAttributes(arrow, config.arrowAttributes);
      popper.appendChild(arrow);
    }
    var parent = config.parent.jquery ? config.parent[0] : config.parent;

    // if the given parent is a string, use it to match an element
    // if more than one element is matched, the first one will be used as parent
    // if no elements are matched, the script will throw an error
    if (typeof parent === 'string') {
      parent = d.querySelectorAll(config.parent);
      if (parent.length > 1) {
        console.warn('WARNING: the given `parent` query(' + config.parent + ') matched more than one element, the first one will be used');
      }
      if (parent.length === 0) {
        throw 'ERROR: the given `parent` doesn\'t exists!';
      }
      parent = parent[0];
    }
    // if the given parent is a DOM nodes list or an array of nodes with more than one element,
    // the first one will be used as parent
    if (parent.length > 1 && parent instanceof Element === false) {
      console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');
      parent = parent[0];
    }

    // append the generated popper to its parent
    parent.appendChild(popper);
    return popper;

    /**
     * Adds class names to the given element
     * @function
     * @ignore
     * @param {HTMLElement} target
     * @param {Array} classes
     */
    function addClassNames(element, classNames) {
      classNames.forEach(function (className) {
        element.classList.add(className);
      });
    }

    /**
     * Adds attributes to the given element
     * @function
     * @ignore
     * @param {HTMLElement} target
     * @param {Array} attributes
     * @example
     * addAttributes(element, [ 'data-info:foobar' ]);
     */
    function addAttributes(element, attributes) {
      attributes.forEach(function (attribute) {
        element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');
      });
    }
  };

  /**
   * Helper used to get the position which will be applied to the popper
   * @method
   * @memberof Popper
   * @param config {HTMLElement} popper element
   * @param reference {HTMLElement} reference element
   * @returns {String} position
   */
  Popper.prototype._getPosition = function (popper, reference) {
    var container = getOffsetParent(reference);
    if (this._options.forceAbsolute) {
      return 'absolute';
    }

    // Decide if the popper will be fixed
    // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together
    var isParentFixed = isFixed(reference, container);
    return isParentFixed ? 'fixed' : 'absolute';
  };

  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper
   * @access private
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */
  Popper.prototype._getOffsets = function (popper, reference, placement) {
    placement = placement.split('-')[0];
    var popperOffsets = {};
    popperOffsets.position = this.state.position;
    var isParentFixed = popperOffsets.position === 'fixed';

    //
    // Get reference element position
    //
    var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed);

    //
    // Get popper sizes
    //
    var popperRect = getOuterSizes(popper);

    //
    // Compute offsets of popper
    //

    // depending by the popper placement we have to compute its offsets slightly differently
    if (['right', 'left'].indexOf(placement) !== -1) {
      popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;
      if (placement === 'left') {
        popperOffsets.left = referenceOffsets.left - popperRect.width;
      } else {
        popperOffsets.left = referenceOffsets.right;
      }
    } else {
      popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;
      if (placement === 'top') {
        popperOffsets.top = referenceOffsets.top - popperRect.height;
      } else {
        popperOffsets.top = referenceOffsets.bottom;
      }
    }

    // Add width and height to our offsets object
    popperOffsets.width = popperRect.width;
    popperOffsets.height = popperRect.height;
    return {
      popper: popperOffsets,
      reference: referenceOffsets
    };
  };

  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper
   * @access private
   */
  Popper.prototype._setupEventListeners = function () {
    // NOTE: 1 DOM access here
    this.state.updateBound = this.update.bind(this);
    root.addEventListener('resize', this.state.updateBound);
    // if the boundariesElement is window we don't need to listen for the scroll event
    if (this._options.boundariesElement !== 'window') {
      var target = getScrollParent(this._reference);
      // here it could be both `body` or `documentElement` thanks to Firefox, we then check both
      if (target === root.document.body || target === root.document.documentElement) {
        target = root;
      }
      target.addEventListener('scroll', this.state.updateBound);
      this.state.scrollTarget = target;
    }
  };

  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper
   * @access private
   */
  Popper.prototype._removeEventListeners = function () {
    // NOTE: 1 DOM access here
    root.removeEventListener('resize', this.state.updateBound);
    if (this._options.boundariesElement !== 'window' && this.state.scrollTarget) {
      this.state.scrollTarget.removeEventListener('scroll', this.state.updateBound);
      this.state.scrollTarget = null;
    }
    this.state.updateBound = null;
  };

  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper
   * @access private
   * @param {Object} data - Object containing the property "offsets" generated by `_getOffsets`
   * @param {Number} padding - Boundaries padding
   * @param {Element} boundariesElement - Element used to define the boundaries
   * @returns {Object} Coordinates of the boundaries
   */
  Popper.prototype._getBoundaries = function (data, padding, boundariesElement) {
    // NOTE: 1 DOM access here
    var boundaries = {};
    var width, height;
    if (boundariesElement === 'window') {
      var body = root.document.body,
        html = root.document.documentElement;
      height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
      width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
      boundaries = {
        top: 0,
        right: width,
        bottom: height,
        left: 0
      };
    } else if (boundariesElement === 'viewport') {
      var offsetParent = getOffsetParent(this._popper);
      var scrollParent = getScrollParent(this._popper);
      var offsetParentRect = getOffsetRect(offsetParent);

      // Thanks the fucking native API, `document.body.scrollTop` & `document.documentElement.scrollTop`
      var getScrollTopValue = function getScrollTopValue(element) {
        return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;
      };
      var getScrollLeftValue = function getScrollLeftValue(element) {
        return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;
      };

      // if the popper is fixed we don't have to substract scrolling from the boundaries
      var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);
      var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);
      boundaries = {
        top: 0 - (offsetParentRect.top - scrollTop),
        right: root.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),
        bottom: root.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),
        left: 0 - (offsetParentRect.left - scrollLeft)
      };
    } else {
      if (getOffsetParent(this._popper) === boundariesElement) {
        boundaries = {
          top: 0,
          left: 0,
          right: boundariesElement.clientWidth,
          bottom: boundariesElement.clientHeight
        };
      } else {
        boundaries = getOffsetRect(boundariesElement);
      }
    }
    boundaries.left += padding;
    boundaries.right -= padding;
    boundaries.top = boundaries.top + padding;
    boundaries.bottom = boundaries.bottom - padding;
    return boundaries;
  };

  /**
   * Loop trough the list of modifiers and run them in order, each of them will then edit the data object
   * @method
   * @memberof Popper
   * @access public
   * @param {Object} data
   * @param {Array} modifiers
   * @param {Function} ends
   */
  Popper.prototype.runModifiers = function (data, modifiers, ends) {
    var modifiersToRun = modifiers.slice();
    if (ends !== undefined) {
      modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));
    }
    modifiersToRun.forEach(function (modifier) {
      if (isFunction(modifier)) {
        data = modifier.call(this, data);
      }
    }.bind(this));
    return data;
  };

  /**
   * Helper used to know if the given modifier depends from another one.
   * @method
   * @memberof Popper
   * @param {String} requesting - name of requesting modifier
   * @param {String} requested - name of requested modifier
   * @returns {Boolean}
   */
  Popper.prototype.isModifierRequired = function (requesting, requested) {
    var index = getArrayKeyIndex(this._options.modifiers, requesting);
    return !!this._options.modifiers.slice(0, index).filter(function (modifier) {
      return modifier === requested;
    }).length;
  };

  //
  // Modifiers
  //

  /**
   * Modifiers list
   * @namespace Popper.modifiers
   * @memberof Popper
   * @type {Object}
   */
  Popper.prototype.modifiers = {};

  /**
   * Apply the computed styles to the popper element
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @returns {Object} The same data object
   */
  Popper.prototype.modifiers.applyStyle = function (data) {
    // apply the final offsets to the popper
    // NOTE: 1 DOM access here
    var styles = {
      position: data.offsets.popper.position
    };

    // round top and left to avoid blurry text
    var left = Math.round(data.offsets.popper.left);
    var top = Math.round(data.offsets.popper.top);

    // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper
    // we automatically use the supported prefixed version if needed
    var prefixedProperty;
    if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles.top = 0;
      styles.left = 0;
    }
    // othwerise, we use the standard `left` and `top` properties
    else {
      styles.left = left;
      styles.top = top;
    }

    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    Object.assign(styles, data.styles);
    setStyle(this._popper, styles);

    // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)
    // NOTE: 1 DOM access here
    this._popper.setAttribute('x-placement', data.placement);

    // if the arrow modifier is required and the arrow style has been computed, apply the arrow style
    if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {
      setStyle(data.arrowElement, data.offsets.arrow);
    }
    return data;
  };

  /**
   * Modifier used to shift the popper on the start or end of its reference element side
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @returns {Object} The data object, properly modified
   */
  Popper.prototype.modifiers.shift = function (data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftVariation = placement.split('-')[1];

    // if shift shiftVariation is specified, run the modifier
    if (shiftVariation) {
      var reference = data.offsets.reference;
      var popper = getPopperClientRect(data.offsets.popper);
      var shiftOffsets = {
        y: {
          start: {
            top: reference.top
          },
          end: {
            top: reference.top + reference.height - popper.height
          }
        },
        x: {
          start: {
            left: reference.left
          },
          end: {
            left: reference.left + reference.width - popper.width
          }
        }
      };
      var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';
      data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);
    }
    return data;
  };

  /**
   * Modifier used to make sure the popper does not overflows from it's boundaries
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @returns {Object} The data object, properly modified
   */
  Popper.prototype.modifiers.preventOverflow = function (data) {
    var order = this._options.preventOverflowOrder;
    var popper = getPopperClientRect(data.offsets.popper);
    var check = {
      left: function left() {
        var left = popper.left;
        if (popper.left < data.boundaries.left) {
          left = Math.max(popper.left, data.boundaries.left);
        }
        return {
          left: left
        };
      },
      right: function right() {
        var left = popper.left;
        if (popper.right > data.boundaries.right) {
          left = Math.min(popper.left, data.boundaries.right - popper.width);
        }
        return {
          left: left
        };
      },
      top: function top() {
        var top = popper.top;
        if (popper.top < data.boundaries.top) {
          top = Math.max(popper.top, data.boundaries.top);
        }
        return {
          top: top
        };
      },
      bottom: function bottom() {
        var top = popper.top;
        if (popper.bottom > data.boundaries.bottom) {
          top = Math.min(popper.top, data.boundaries.bottom - popper.height);
        }
        return {
          top: top
        };
      }
    };
    order.forEach(function (direction) {
      data.offsets.popper = Object.assign(popper, check[direction]());
    });
    return data;
  };

  /**
   * Modifier used to make sure the popper is always near its reference
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by _update method
   * @returns {Object} The data object, properly modified
   */
  Popper.prototype.modifiers.keepTogether = function (data) {
    var popper = getPopperClientRect(data.offsets.popper);
    var reference = data.offsets.reference;
    var f = Math.floor;
    if (popper.right < f(reference.left)) {
      data.offsets.popper.left = f(reference.left) - popper.width;
    }
    if (popper.left > f(reference.right)) {
      data.offsets.popper.left = f(reference.right);
    }
    if (popper.bottom < f(reference.top)) {
      data.offsets.popper.top = f(reference.top) - popper.height;
    }
    if (popper.top > f(reference.bottom)) {
      data.offsets.popper.top = f(reference.bottom);
    }
    return data;
  };

  /**
   * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.
   * Requires the `preventOverflow` modifier before it in order to work.
   * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by _update method
   * @returns {Object} The data object, properly modified
   */
  Popper.prototype.modifiers.flip = function (data) {
    // check if preventOverflow is in the list of modifiers before the flip modifier.
    // otherwise flip would not work as expected.
    if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {
      console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');
      return data;
    }
    if (data.flipped && data.placement === data._originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];
    if (this._options.flipBehavior === 'flip') {
      flipOrder = [placement, placementOpposite];
    } else {
      flipOrder = this._options.flipBehavior;
    }
    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return;
      }
      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = getPopperClientRect(data.offsets.popper);

      // this boolean is used to distinguish right and bottom from top and left
      // they need different computations to get flipped
      var a = ['right', 'bottom'].indexOf(placement) !== -1;

      // using Math.floor because the reference offsets may contain decimals we are not going to consider here
      if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {
        // we'll use this boolean to detect any flip loop
        data.flipped = true;
        data.placement = flipOrder[index + 1];
        if (variation) {
          data.placement += '-' + variation;
        }
        data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;
        data = this.runModifiers(data, this._options.modifiers, this._flip);
      }
    }.bind(this));
    return data;
  };

  /**
   * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.
   * The offsets will shift the popper on the side of its reference element.
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by _update method
   * @returns {Object} The data object, properly modified
   */
  Popper.prototype.modifiers.offset = function (data) {
    var offset = this._options.offset;
    var popper = data.offsets.popper;
    if (data.placement.indexOf('left') !== -1) {
      popper.top -= offset;
    } else if (data.placement.indexOf('right') !== -1) {
      popper.top += offset;
    } else if (data.placement.indexOf('top') !== -1) {
      popper.left -= offset;
    } else if (data.placement.indexOf('bottom') !== -1) {
      popper.left += offset;
    }
    return data;
  };

  /**
   * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element
   * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by _update method
   * @returns {Object} The data object, properly modified
   */
  Popper.prototype.modifiers.arrow = function (data) {
    var arrow = this._options.arrowElement;
    var arrowOffset = this._options.arrowOffset;

    // if the arrowElement is a string, suppose it's a CSS selector
    if (typeof arrow === 'string') {
      arrow = this._popper.querySelector(arrow);
    }

    // if arrow element is not found, don't run the modifier
    if (!arrow) {
      return data;
    }

    // the arrow element must be child of its popper
    if (!this._popper.contains(arrow)) {
      console.warn('WARNING: `arrowElement` must be child of its popper element!');
      return data;
    }

    // arrow depends on keepTogether in order to work
    if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {
      console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');
      return data;
    }
    var arrowStyle = {};
    var placement = data.placement.split('-')[0];
    var popper = getPopperClientRect(data.offsets.popper);
    var reference = data.offsets.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var side = isVertical ? 'top' : 'left';
    var translate = isVertical ? 'translateY' : 'translateX';
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowSize = getOuterSizes(arrow)[len];

    //
    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
    //

    // top/left side
    if (reference[opSide] - arrowSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
    }
    // bottom/right side
    if (reference[side] + arrowSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowSize - popper[opSide];
    }

    // compute center of the popper
    var center = reference[side] + (arrowOffset || reference[len] / 2 - arrowSize / 2);
    var sideValue = center - popper[side];

    // prevent arrow from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowSize - 8, sideValue), 8);
    arrowStyle[side] = sideValue;
    arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow

    data.offsets.arrow = arrowStyle;
    data.arrowElement = arrow;
    return data;
  };

  //
  // Helpers
  //

  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @function
   * @ignore
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */
  function getOuterSizes(element) {
    // NOTE: 1 DOM access here
    var _display = element.style.display,
      _visibility = element.style.visibility;
    element.style.display = 'block';
    element.style.visibility = 'hidden';
    var calcWidthToForceRepaint = element.offsetWidth;

    // original method
    var styles = root.getComputedStyle(element);
    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };

    // reset element styles
    element.style.display = _display;
    element.style.visibility = _visibility;
    return result;
  }

  /**
   * Get the opposite placement of the given one/
   * @function
   * @ignore
   * @argument {String} placement
   * @returns {String} flipped placement
   */
  function getOppositePlacement(placement) {
    var hash = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }

  /**
   * Given the popper offsets, generate an output similar to getBoundingClientRect
   * @function
   * @ignore
   * @argument {Object} popperOffsets
   * @returns {Object} ClientRect like output
   */
  function getPopperClientRect(popperOffsets) {
    var offsets = Object.assign({}, popperOffsets);
    offsets.right = offsets.left + offsets.width;
    offsets.bottom = offsets.top + offsets.height;
    return offsets;
  }

  /**
   * Given an array and the key to find, returns its index
   * @function
   * @ignore
   * @argument {Array} arr
   * @argument keyToFind
   * @returns index or null
   */
  function getArrayKeyIndex(arr, keyToFind) {
    var i = 0,
      key;
    for (key in arr) {
      if (arr[key] === keyToFind) {
        return i;
      }
      i++;
    }
    return null;
  }

  /**
   * Get CSS computed property of the given element
   * @function
   * @ignore
   * @argument {Eement} element
   * @argument {String} property
   */
  function getStyleComputedProperty(element, property) {
    // NOTE: 1 DOM access here
    var css = root.getComputedStyle(element, null);
    return css[property];
  }

  /**
   * Returns the offset parent of the given element
   * @function
   * @ignore
   * @argument {Element} element
   * @returns {Element} offset parent
   */
  function getOffsetParent(element) {
    // NOTE: 1 DOM access here
    var offsetParent = element.offsetParent;
    return offsetParent === root.document.body || !offsetParent ? root.document.documentElement : offsetParent;
  }

  /**
   * Returns the scrolling parent of the given element
   * @function
   * @ignore
   * @argument {Element} element
   * @returns {Element} offset parent
   */
  function getScrollParent(element) {
    var parent = element.parentNode;
    if (!parent) {
      return element;
    }
    if (parent === root.document) {
      // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is
      // greater than 0 and return the proper element
      if (root.document.body.scrollTop || root.document.body.scrollLeft) {
        return root.document.body;
      } else {
        return root.document.documentElement;
      }
    }

    // Firefox want us to check `-x` and `-y` variations as well
    if (['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1) {
      // If the detected scrollParent is body, we perform an additional check on its parentNode
      // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise
      // fixes issue #65
      return parent;
    }
    return getScrollParent(element.parentNode);
  }

  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @function
   * @ignore
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */
  function isFixed(element) {
    if (element === root.document.body) {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    return element.parentNode ? isFixed(element.parentNode) : element;
  }

  /**
   * Set the style to the given popper
   * @function
   * @ignore
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles - Object with a list of properties and values which will be applied to the element
   */
  function setStyle(element, styles) {
    function is_numeric(n) {
      return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
    }
    Object.keys(styles).forEach(function (prop) {
      var unit = '';
      // add unit if the value is numeric and is one of the following
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }

  /**
   * Check if the given variable is a function
   * @function
   * @ignore
   * @argument {*} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }

  /**
   * Get the position of the given element, relative to its offset parent
   * @function
   * @ignore
   * @param {Element} element
   * @return {Object} position - Coordinates of the element and its `scrollTop`
   */
  function getOffsetRect(element) {
    var elementRect = {
      width: element.offsetWidth,
      height: element.offsetHeight,
      left: element.offsetLeft,
      top: element.offsetTop
    };
    elementRect.right = elementRect.left + elementRect.width;
    elementRect.bottom = elementRect.top + elementRect.height;

    // position
    return elementRect;
  }

  /**
   * Get bounding client rect of given element
   * @function
   * @ignore
   * @param {HTMLElement} element
   * @return {Object} client rect
   */
  function getBoundingClientRect(element) {
    var rect = element.getBoundingClientRect();

    // whether the IE version is lower than 11
    var isIE = navigator.userAgent.indexOf("MSIE") != -1;

    // fix ie document bounding top always 0 bug
    var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;
    return {
      left: rect.left,
      top: rectTop,
      right: rect.right,
      bottom: rect.bottom,
      width: rect.right - rect.left,
      height: rect.bottom - rectTop
    };
  }

  /**
   * Given an element and one of its parents, return the offset
   * @function
   * @ignore
   * @param {HTMLElement} element
   * @param {HTMLElement} parent
   * @return {Object} rect
   */
  function getOffsetRectRelativeToCustomParent(element, parent, fixed) {
    var elementRect = getBoundingClientRect(element);
    var parentRect = getBoundingClientRect(parent);
    if (fixed) {
      var scrollParent = getScrollParent(parent);
      parentRect.top += scrollParent.scrollTop;
      parentRect.bottom += scrollParent.scrollTop;
      parentRect.left += scrollParent.scrollLeft;
      parentRect.right += scrollParent.scrollLeft;
    }
    var rect = {
      top: elementRect.top - parentRect.top,
      left: elementRect.left - parentRect.left,
      bottom: elementRect.top - parentRect.top + elementRect.height,
      right: elementRect.left - parentRect.left + elementRect.width,
      width: elementRect.width,
      height: elementRect.height
    };
    return rect;
  }

  /**
   * Get the prefixed supported property name
   * @function
   * @ignore
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase)
   */
  function getSupportedPropertyName(property) {
    var prefixes = ['', 'ms', 'webkit', 'moz', 'o'];
    for (var i = 0; i < prefixes.length; i++) {
      var toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;
      if (typeof root.document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }

  /**
   * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source
   * objects to a target object. It will return the target object.
   * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway
   * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
   * @function
   * @ignore
   */
  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function value(target) {
        if (target === undefined || target === null) {
          throw new TypeError('Cannot convert first argument to object');
        }
        var to = Object(target);
        for (var i = 1; i < arguments.length; i++) {
          var nextSource = arguments[i];
          if (nextSource === undefined || nextSource === null) {
            continue;
          }
          nextSource = Object(nextSource);
          var keysArray = Object.keys(nextSource);
          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== undefined && desc.enumerable) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
        return to;
      }
    });
  }
  return Popper;
});

/***/ }),

/***/ 711:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.PopupManager = undefined;
var _vue = __webpack_require__(203);
var _vue2 = _interopRequireDefault(_vue);
var _merge = __webpack_require__(186);
var _merge2 = _interopRequireDefault(_merge);
var _popupManager = __webpack_require__(731);
var _popupManager2 = _interopRequireDefault(_popupManager);
var _scrollbarWidth = __webpack_require__(190);
var _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);
var _dom = __webpack_require__(597);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var idSeed = 1;
var scrollBarWidth = void 0;
exports["default"] = {
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    openDelay: {},
    closeDelay: {},
    zIndex: {},
    modal: {
      type: Boolean,
      default: false
    },
    modalFade: {
      type: Boolean,
      default: true
    },
    modalClass: {},
    modalAppendToBody: {
      type: Boolean,
      default: false
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: false
    },
    closeOnClickModal: {
      type: Boolean,
      default: false
    }
  },
  beforeMount: function beforeMount() {
    this._popupId = 'popup-' + idSeed++;
    _popupManager2.default.register(this._popupId, this);
  },
  beforeDestroy: function beforeDestroy() {
    _popupManager2.default.deregister(this._popupId);
    _popupManager2.default.closeModal(this._popupId);
    this.restoreBodyStyle();
  },
  data: function data() {
    return {
      opened: false,
      bodyPaddingRight: null,
      computedBodyPaddingRight: 0,
      withoutHiddenClass: true,
      rendered: false
    };
  },
  watch: {
    visible: function visible(val) {
      var _this = this;
      if (val) {
        if (this._opening) return;
        if (!this.rendered) {
          this.rendered = true;
          _vue2.default.nextTick(function () {
            _this.open();
          });
        } else {
          this.open();
        }
      } else {
        this.close();
      }
    }
  },
  methods: {
    open: function open(options) {
      var _this2 = this;
      if (!this.rendered) {
        this.rendered = true;
      }
      var props = (0, _merge2.default)({}, this.$props || this, options);
      if (this._closeTimer) {
        clearTimeout(this._closeTimer);
        this._closeTimer = null;
      }
      clearTimeout(this._openTimer);
      var openDelay = Number(props.openDelay);
      if (openDelay > 0) {
        this._openTimer = setTimeout(function () {
          _this2._openTimer = null;
          _this2.doOpen(props);
        }, openDelay);
      } else {
        this.doOpen(props);
      }
    },
    doOpen: function doOpen(props) {
      if (this.$isServer) return;
      if (this.willOpen && !this.willOpen()) return;
      if (this.opened) return;
      this._opening = true;
      var dom = this.$el;
      var modal = props.modal;
      var zIndex = props.zIndex;
      if (zIndex) {
        _popupManager2.default.zIndex = zIndex;
      }
      if (modal) {
        if (this._closing) {
          _popupManager2.default.closeModal(this._popupId);
          this._closing = false;
        }
        _popupManager2.default.openModal(this._popupId, _popupManager2.default.nextZIndex(), this.modalAppendToBody ? undefined : dom, props.modalClass, props.modalFade);
        if (props.lockScroll) {
          this.withoutHiddenClass = !(0, _dom.hasClass)(document.body, 'el-popup-parent--hidden');
          if (this.withoutHiddenClass) {
            this.bodyPaddingRight = document.body.style.paddingRight;
            this.computedBodyPaddingRight = parseInt((0, _dom.getStyle)(document.body, 'paddingRight'), 10);
          }
          scrollBarWidth = (0, _scrollbarWidth2.default)();
          var bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          var bodyOverflowY = (0, _dom.getStyle)(document.body, 'overflowY');
          if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll') && this.withoutHiddenClass) {
            document.body.style.paddingRight = this.computedBodyPaddingRight + scrollBarWidth + 'px';
          }
          (0, _dom.addClass)(document.body, 'el-popup-parent--hidden');
        }
      }
      if (getComputedStyle(dom).position === 'static') {
        dom.style.position = 'absolute';
      }
      dom.style.zIndex = _popupManager2.default.nextZIndex();
      this.opened = true;
      this.onOpen && this.onOpen();
      this.doAfterOpen();
    },
    doAfterOpen: function doAfterOpen() {
      this._opening = false;
    },
    close: function close() {
      var _this3 = this;
      if (this.willClose && !this.willClose()) return;
      if (this._openTimer !== null) {
        clearTimeout(this._openTimer);
        this._openTimer = null;
      }
      clearTimeout(this._closeTimer);
      var closeDelay = Number(this.closeDelay);
      if (closeDelay > 0) {
        this._closeTimer = setTimeout(function () {
          _this3._closeTimer = null;
          _this3.doClose();
        }, closeDelay);
      } else {
        this.doClose();
      }
    },
    doClose: function doClose() {
      this._closing = true;
      this.onClose && this.onClose();
      if (this.lockScroll) {
        setTimeout(this.restoreBodyStyle, 200);
      }
      this.opened = false;
      this.doAfterClose();
    },
    doAfterClose: function doAfterClose() {
      _popupManager2.default.closeModal(this._popupId);
      this._closing = false;
    },
    restoreBodyStyle: function restoreBodyStyle() {
      if (this.modal && this.withoutHiddenClass) {
        document.body.style.paddingRight = this.bodyPaddingRight;
        (0, _dom.removeClass)(document.body, 'el-popup-parent--hidden');
      }
      this.withoutHiddenClass = true;
    }
  }
};
exports.PopupManager = _popupManager2.default;

/***/ }),

/***/ 731:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var _vue = __webpack_require__(203);
var _vue2 = _interopRequireDefault(_vue);
var _dom = __webpack_require__(597);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var hasModal = false;
var hasInitZIndex = false;
var zIndex = void 0;
var getModal = function getModal() {
  if (_vue2.default.prototype.$isServer) return;
  var modalDom = PopupManager.modalDom;
  if (modalDom) {
    hasModal = true;
  } else {
    hasModal = false;
    modalDom = document.createElement('div');
    PopupManager.modalDom = modalDom;
    modalDom.addEventListener('touchmove', function (event) {
      event.preventDefault();
      event.stopPropagation();
    });
    modalDom.addEventListener('click', function () {
      PopupManager.doOnModalClick && PopupManager.doOnModalClick();
    });
  }
  return modalDom;
};
var instances = {};
var PopupManager = {
  modalFade: true,
  getInstance: function getInstance(id) {
    return instances[id];
  },
  register: function register(id, instance) {
    if (id && instance) {
      instances[id] = instance;
    }
  },
  deregister: function deregister(id) {
    if (id) {
      instances[id] = null;
      delete instances[id];
    }
  },
  nextZIndex: function nextZIndex() {
    return PopupManager.zIndex++;
  },
  modalStack: [],
  doOnModalClick: function doOnModalClick() {
    var topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topItem) return;
    var instance = PopupManager.getInstance(topItem.id);
    if (instance && instance.closeOnClickModal) {
      instance.close();
    }
  },
  openModal: function openModal(id, zIndex, dom, modalClass, modalFade) {
    if (_vue2.default.prototype.$isServer) return;
    if (!id || zIndex === undefined) return;
    this.modalFade = modalFade;
    var modalStack = this.modalStack;
    for (var i = 0, j = modalStack.length; i < j; i++) {
      var item = modalStack[i];
      if (item.id === id) {
        return;
      }
    }
    var modalDom = getModal();
    (0, _dom.addClass)(modalDom, 'v-modal');
    if (this.modalFade && !hasModal) {
      (0, _dom.addClass)(modalDom, 'v-modal-enter');
    }
    if (modalClass) {
      var classArr = modalClass.trim().split(/\s+/);
      classArr.forEach(function (item) {
        return (0, _dom.addClass)(modalDom, item);
      });
    }
    setTimeout(function () {
      (0, _dom.removeClass)(modalDom, 'v-modal-enter');
    }, 200);
    if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {
      dom.parentNode.appendChild(modalDom);
    } else {
      document.body.appendChild(modalDom);
    }
    if (zIndex) {
      modalDom.style.zIndex = zIndex;
    }
    modalDom.tabIndex = 0;
    modalDom.style.display = '';
    this.modalStack.push({
      id: id,
      zIndex: zIndex,
      modalClass: modalClass
    });
  },
  closeModal: function closeModal(id) {
    var modalStack = this.modalStack;
    var modalDom = getModal();
    if (modalStack.length > 0) {
      var topItem = modalStack[modalStack.length - 1];
      if (topItem.id === id) {
        if (topItem.modalClass) {
          var classArr = topItem.modalClass.trim().split(/\s+/);
          classArr.forEach(function (item) {
            return (0, _dom.removeClass)(modalDom, item);
          });
        }
        modalStack.pop();
        if (modalStack.length > 0) {
          modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;
        }
      } else {
        for (var i = modalStack.length - 1; i >= 0; i--) {
          if (modalStack[i].id === id) {
            modalStack.splice(i, 1);
            break;
          }
        }
      }
    }
    if (modalStack.length === 0) {
      if (this.modalFade) {
        (0, _dom.addClass)(modalDom, 'v-modal-leave');
      }
      setTimeout(function () {
        if (modalStack.length === 0) {
          if (modalDom.parentNode) modalDom.parentNode.removeChild(modalDom);
          modalDom.style.display = 'none';
          PopupManager.modalDom = undefined;
        }
        (0, _dom.removeClass)(modalDom, 'v-modal-leave');
      }, 200);
    }
  }
};
Object.defineProperty(PopupManager, 'zIndex', {
  configurable: true,
  get: function get() {
    if (!hasInitZIndex) {
      zIndex = zIndex || (_vue2.default.prototype.$ELEMENT || {}).zIndex || 2000;
      hasInitZIndex = true;
    }
    return zIndex;
  },
  set: function set(value) {
    zIndex = value;
  }
});
var getTopPopup = function getTopPopup() {
  if (_vue2.default.prototype.$isServer) return;
  if (PopupManager.modalStack.length > 0) {
    var topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topPopup) return;
    var instance = PopupManager.getInstance(topPopup.id);
    return instance;
  }
};
if (!_vue2.default.prototype.$isServer) {
  // handle `esc` key when the popup is shown
  window.addEventListener('keydown', function (event) {
    if (event.keyCode === 27) {
      var topPopup = getTopPopup();
      if (topPopup && topPopup.closeOnPressEscape) {
        topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction('cancel') : topPopup.close();
      }
    }
  });
}
exports["default"] = PopupManager;

/***/ }),

/***/ 268:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.removeResizeListener = exports.addResizeListener = undefined;
var _resizeObserverPolyfill = __webpack_require__(748);
var _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);
var _throttleDebounce = __webpack_require__(658);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var isServer = typeof window === 'undefined';

/* istanbul ignore next */
var resizeHandler = function resizeHandler(entries) {
  for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;
    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }
    var entry = _ref;
    var listeners = entry.target.__resizeListeners__ || [];
    if (listeners.length) {
      listeners.forEach(function (fn) {
        fn();
      });
    }
  }
};

/* istanbul ignore next */
var addResizeListener = exports.addResizeListener = function addResizeListener(element, fn) {
  if (isServer) return;
  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = [];
    element.__ro__ = new _resizeObserverPolyfill2.default((0, _throttleDebounce.debounce)(16, resizeHandler));
    element.__ro__.observe(element);
  }
  element.__resizeListeners__.push(fn);
};

/* istanbul ignore next */
var removeResizeListener = exports.removeResizeListener = function removeResizeListener(element, fn) {
  if (!element || !element.__resizeListeners__) return;
  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
  if (!element.__resizeListeners__.length) {
    element.__ro__.disconnect();
  }
};

/***/ }),

/***/ 190:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = function () {
  if (_vue2.default.prototype.$isServer) return 0;
  if (scrollBarWidth !== undefined) return scrollBarWidth;
  var outer = document.createElement('div');
  outer.className = 'el-scrollbar__wrap';
  outer.style.visibility = 'hidden';
  outer.style.width = '100px';
  outer.style.position = 'absolute';
  outer.style.top = '-9999px';
  document.body.appendChild(outer);
  var widthNoScroll = outer.offsetWidth;
  outer.style.overflow = 'scroll';
  var inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);
  var widthWithScroll = inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;
  return scrollBarWidth;
};
var _vue = __webpack_require__(203);
var _vue2 = _interopRequireDefault(_vue);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var scrollBarWidth = void 0;
;

/***/ }),

/***/ 628:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isDefined = exports.isUndefined = exports.isFunction = undefined;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
exports.isString = isString;
exports.isObject = isObject;
exports.isHtmlElement = isHtmlElement;
var _vue = __webpack_require__(203);
var _vue2 = _interopRequireDefault(_vue);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function isString(obj) {
  return Object.prototype.toString.call(obj) === '[object String]';
}
function isObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}
function isHtmlElement(node) {
  return node && node.nodeType === Node.ELEMENT_NODE;
}

/**
 *  - Inspired:
 *    https://github.com/jashkenas/underscore/blob/master/modules/isFunction.js
 */
var isFunction = function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
};
if ( true && (typeof Int8Array === 'undefined' ? 'undefined' : _typeof(Int8Array)) !== 'object' && (_vue2.default.prototype.$isServer || typeof document.childNodes !== 'function')) {
  exports.isFunction = isFunction = function isFunction(obj) {
    return typeof obj === 'function' || false;
  };
}
exports.isFunction = isFunction;
var isUndefined = exports.isUndefined = function isUndefined(val) {
  return val === void 0;
};
var isDefined = exports.isDefined = function isDefined(val) {
  return val !== undefined && val !== null;
};

/***/ }),

/***/ 125:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isMac = exports.isEmpty = exports.isEqual = exports.arrayEquals = exports.looseEqual = exports.capitalize = exports.kebabCase = exports.autoprefixer = exports.isFirefox = exports.isEdge = exports.isIE = exports.coerceTruthyValueToArray = exports.arrayFind = exports.arrayFindIndex = exports.escapeRegexpString = exports.valueEquals = exports.generateId = exports.getValueByPath = undefined;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
exports.noop = noop;
exports.hasOwn = hasOwn;
exports.toObject = toObject;
exports.getPropByPath = getPropByPath;
exports.rafThrottle = rafThrottle;
exports.objToArray = objToArray;
var _vue = __webpack_require__(203);
var _vue2 = _interopRequireDefault(_vue);
var _types = __webpack_require__(628);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function noop() {}
;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
;
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}
;
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}
;
var getValueByPath = exports.getValueByPath = function getValueByPath(object, prop) {
  prop = prop || '';
  var paths = prop.split('.');
  var current = object;
  var result = null;
  for (var i = 0, j = paths.length; i < j; i++) {
    var path = paths[i];
    if (!current) break;
    if (i === j - 1) {
      result = current[path];
      break;
    }
    current = current[path];
  }
  return result;
};
function getPropByPath(obj, path, strict) {
  var tempObj = obj;
  path = path.replace(/\[(\w+)\]/g, '.$1');
  path = path.replace(/^\./, '');
  var keyArr = path.split('.');
  var i = 0;
  for (var len = keyArr.length; i < len - 1; ++i) {
    if (!tempObj && !strict) break;
    var key = keyArr[i];
    if (key in tempObj) {
      tempObj = tempObj[key];
    } else {
      if (strict) {
        throw new Error('please transfer a valid prop path to form item!');
      }
      break;
    }
  }
  return {
    o: tempObj,
    k: keyArr[i],
    v: tempObj ? tempObj[keyArr[i]] : null
  };
}
;
var generateId = exports.generateId = function generateId() {
  return Math.floor(Math.random() * 10000);
};
var valueEquals = exports.valueEquals = function valueEquals(a, b) {
  // see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
  if (a === b) return true;
  if (!(a instanceof Array)) return false;
  if (!(b instanceof Array)) return false;
  if (a.length !== b.length) return false;
  for (var i = 0; i !== a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
};
var escapeRegexpString = exports.escapeRegexpString = function escapeRegexpString() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return String(value).replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
};

// TODO: use native Array.find, Array.findIndex when IE support is dropped
var arrayFindIndex = exports.arrayFindIndex = function arrayFindIndex(arr, pred) {
  for (var i = 0; i !== arr.length; ++i) {
    if (pred(arr[i])) {
      return i;
    }
  }
  return -1;
};
var arrayFind = exports.arrayFind = function arrayFind(arr, pred) {
  var idx = arrayFindIndex(arr, pred);
  return idx !== -1 ? arr[idx] : undefined;
};

// coerce truthy value to array
var coerceTruthyValueToArray = exports.coerceTruthyValueToArray = function coerceTruthyValueToArray(val) {
  if (Array.isArray(val)) {
    return val;
  } else if (val) {
    return [val];
  } else {
    return [];
  }
};
var isIE = exports.isIE = function isIE() {
  return !_vue2.default.prototype.$isServer && !isNaN(Number(document.documentMode));
};
var isEdge = exports.isEdge = function isEdge() {
  return !_vue2.default.prototype.$isServer && navigator.userAgent.indexOf('Edge') > -1;
};
var isFirefox = exports.isFirefox = function isFirefox() {
  return !_vue2.default.prototype.$isServer && !!window.navigator.userAgent.match(/firefox/i);
};
var autoprefixer = exports.autoprefixer = function autoprefixer(style) {
  if ((typeof style === 'undefined' ? 'undefined' : _typeof(style)) !== 'object') return style;
  var rules = ['transform', 'transition', 'animation'];
  var prefixes = ['ms-', 'webkit-'];
  rules.forEach(function (rule) {
    var value = style[rule];
    if (rule && value) {
      prefixes.forEach(function (prefix) {
        style[prefix + rule] = value;
      });
    }
  });
  return style;
};
var kebabCase = exports.kebabCase = function kebabCase(str) {
  var hyphenateRE = /([^-])([A-Z])/g;
  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
};
var capitalize = exports.capitalize = function capitalize(str) {
  if (!(0, _types.isString)(str)) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
};
var looseEqual = exports.looseEqual = function looseEqual(a, b) {
  var isObjectA = (0, _types.isObject)(a);
  var isObjectB = (0, _types.isObject)(b);
  if (isObjectA && isObjectB) {
    return JSON.stringify(a) === JSON.stringify(b);
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
};
var arrayEquals = exports.arrayEquals = function arrayEquals(arrayA, arrayB) {
  arrayA = arrayA || [];
  arrayB = arrayB || [];
  if (arrayA.length !== arrayB.length) {
    return false;
  }
  for (var i = 0; i < arrayA.length; i++) {
    if (!looseEqual(arrayA[i], arrayB[i])) {
      return false;
    }
  }
  return true;
};
var isEqual = exports.isEqual = function isEqual(value1, value2) {
  if (Array.isArray(value1) && Array.isArray(value2)) {
    return arrayEquals(value1, value2);
  }
  return looseEqual(value1, value2);
};
var isEmpty = exports.isEmpty = function isEmpty(val) {
  // null or undefined
  if (val == null) return true;
  if (typeof val === 'boolean') return false;
  if (typeof val === 'number') return !val;
  if (val instanceof Error) return val.message === '';
  switch (Object.prototype.toString.call(val)) {
    // String or Array
    case '[object String]':
    case '[object Array]':
      return !val.length;

    // Map or Set or File
    case '[object File]':
    case '[object Map]':
    case '[object Set]':
      {
        return !val.size;
      }
    // Plain Object
    case '[object Object]':
      {
        return !Object.keys(val).length;
      }
  }
  return false;
};
function rafThrottle(fn) {
  var locked = false;
  return function () {
    var _this = this;
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (locked) return;
    locked = true;
    window.requestAnimationFrame(function (_) {
      fn.apply(_this, args);
      locked = false;
    });
  };
}
function objToArray(obj) {
  if (Array.isArray(obj)) {
    return obj;
  }
  return isEmpty(obj) ? [] : [obj];
}
var isMac = exports.isMac = function isMac() {
  return !_vue2.default.prototype.$isServer && /macintosh|mac os x/i.test(navigator.userAgent);
};

/***/ }),

/***/ 617:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var _vue = __webpack_require__(203);
var _vue2 = _interopRequireDefault(_vue);
var _popup = __webpack_require__(711);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var PopperJS = _vue2.default.prototype.$isServer ? function () {} : __webpack_require__(235);
var stop = function stop(e) {
  return e.stopPropagation();
};

/**
 * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.
 * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.
 * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -end), left(-start, -end)
 * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).
 * @param {Boolean} [visible=false] Visibility of the popup element.
 * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.
 */
exports["default"] = {
  props: {
    transformOrigin: {
      type: [Boolean, String],
      default: true
    },
    placement: {
      type: String,
      default: 'bottom'
    },
    boundariesPadding: {
      type: Number,
      default: 5
    },
    reference: {},
    popper: {},
    offset: {
      default: 0
    },
    value: Boolean,
    visibleArrow: Boolean,
    arrowOffset: {
      type: Number,
      default: 35
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    popperOptions: {
      type: Object,
      default: function _default() {
        return {
          gpuAcceleration: false
        };
      }
    }
  },
  data: function data() {
    return {
      showPopper: false,
      currentPlacement: ''
    };
  },
  watch: {
    value: {
      immediate: true,
      handler: function handler(val) {
        this.showPopper = val;
        this.$emit('input', val);
      }
    },
    showPopper: function showPopper(val) {
      if (this.disabled) return;
      val ? this.updatePopper() : this.destroyPopper();
      this.$emit('input', val);
    }
  },
  methods: {
    createPopper: function createPopper() {
      var _this = this;
      if (this.$isServer) return;
      this.currentPlacement = this.currentPlacement || this.placement;
      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.currentPlacement)) {
        return;
      }
      var options = this.popperOptions;
      var popper = this.popperElm = this.popperElm || this.popper || this.$refs.popper;
      var reference = this.referenceElm = this.referenceElm || this.reference || this.$refs.reference;
      if (!reference && this.$slots.reference && this.$slots.reference[0]) {
        reference = this.referenceElm = this.$slots.reference[0].elm;
      }
      if (!popper || !reference) return;
      if (this.visibleArrow) this.appendArrow(popper);
      if (this.appendToBody) document.body.appendChild(this.popperElm);
      if (this.popperJS && this.popperJS.destroy) {
        this.popperJS.destroy();
      }
      options.placement = this.currentPlacement;
      options.offset = this.offset;
      options.arrowOffset = this.arrowOffset;
      this.popperJS = new PopperJS(reference, popper, options);
      this.popperJS.onCreate(function (_) {
        _this.$emit('created', _this);
        _this.resetTransformOrigin();
        _this.$nextTick(_this.updatePopper);
      });
      if (typeof options.onUpdate === 'function') {
        this.popperJS.onUpdate(options.onUpdate);
      }
      this.popperJS._popper.style.zIndex = _popup.PopupManager.nextZIndex();
      this.popperElm.addEventListener('click', stop);
    },
    updatePopper: function updatePopper() {
      var popperJS = this.popperJS;
      if (popperJS) {
        popperJS.update();
        if (popperJS._popper) {
          popperJS._popper.style.zIndex = _popup.PopupManager.nextZIndex();
        }
      } else {
        this.createPopper();
      }
    },
    doDestroy: function doDestroy(forceDestroy) {
      /* istanbul ignore if */
      if (!this.popperJS || this.showPopper && !forceDestroy) return;
      this.popperJS.destroy();
      this.popperJS = null;
    },
    destroyPopper: function destroyPopper() {
      if (this.popperJS) {
        this.resetTransformOrigin();
      }
    },
    resetTransformOrigin: function resetTransformOrigin() {
      if (!this.transformOrigin) return;
      var placementMap = {
        top: 'bottom',
        bottom: 'top',
        left: 'right',
        right: 'left'
      };
      var placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];
      var origin = placementMap[placement];
      this.popperJS._popper.style.transformOrigin = typeof this.transformOrigin === 'string' ? this.transformOrigin : ['top', 'bottom'].indexOf(placement) > -1 ? 'center ' + origin : origin + ' center';
    },
    appendArrow: function appendArrow(element) {
      var hash = void 0;
      if (this.appended) {
        return;
      }
      this.appended = true;
      for (var item in element.attributes) {
        if (/^_v-/.test(element.attributes[item].name)) {
          hash = element.attributes[item].name;
          break;
        }
      }
      var arrow = document.createElement('div');
      if (hash) {
        arrow.setAttribute(hash, '');
      }
      arrow.setAttribute('x-arrow', '');
      arrow.className = 'popper__arrow';
      element.appendChild(arrow);
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.doDestroy(true);
    if (this.popperElm && this.popperElm.parentNode === document.body) {
      this.popperElm.removeEventListener('click', stop);
      document.body.removeChild(this.popperElm);
    }
  },
  // call destroy in keep-alive mode
  deactivated: function deactivated() {
    this.$options.beforeDestroy[0].call(this);
  }
};

/***/ }),

/***/ 26:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(452);

/***/ }),

/***/ 509:
/***/ (function(module) {

"use strict";
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

/*jslint evil: true */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {
  canUseDOM: canUseDOM,
  canUseWorkers: typeof Worker !== 'undefined',
  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
  canUseViewport: canUseDOM && !!window.screen,
  isInWorker: !canUseDOM // For now, this is true - might change in the future.
};

module.exports = ExecutionEnvironment;

/***/ }),

/***/ 431:
/***/ (function(module) {

/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * @providesModule UserAgent_DEPRECATED
 */

/**
 *  Provides entirely client-side User Agent and OS detection. You should prefer
 *  the non-deprecated UserAgent module when possible, which exposes our
 *  authoritative server-side PHP-based detection to the client.
 *
 *  Usage is straightforward:
 *
 *    if (UserAgent_DEPRECATED.ie()) {
 *      //  IE
 *    }
 *
 *  You can also do version checks:
 *
 *    if (UserAgent_DEPRECATED.ie() >= 7) {
 *      //  IE7 or better
 *    }
 *
 *  The browser functions will return NaN if the browser does not match, so
 *  you can also do version compares the other way:
 *
 *    if (UserAgent_DEPRECATED.ie() < 7) {
 *      //  IE6 or worse
 *    }
 *
 *  Note that the version is a float and may include a minor version number,
 *  so you should always use range operators to perform comparisons, not
 *  strict equality.
 *
 *  **Note:** You should **strongly** prefer capability detection to browser
 *  version detection where it's reasonable:
 *
 *    http://www.quirksmode.org/js/support.html
 *
 *  Further, we have a large number of mature wrapper functions and classes
 *  which abstract away many browser irregularities. Check the documentation,
 *  grep for things, or ask on javascript@lists.facebook.com before writing yet
 *  another copy of "event || window.event".
 *
 */

var _populated = false;

// Browsers
var _ie, _firefox, _opera, _webkit, _chrome;

// Actual IE browser for compatibility mode
var _ie_real_version;

// Platforms
var _osx, _windows, _linux, _android;

// Architectures
var _win64;

// Devices
var _iphone, _ipad, _native;
var _mobile;
function _populate() {
  if (_populated) {
    return;
  }
  _populated = true;

  // To work around buggy JS libraries that can't handle multi-digit
  // version numbers, Opera 10's user agent string claims it's Opera
  // 9, then later includes a Version/X.Y field:
  //
  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10
  var uas = navigator.userAgent;
  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
  var os = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);
  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
  _ipad = /\b(iP[ao]d)/.exec(uas);
  _android = /Android/i.exec(uas);
  _native = /FBAN\/\w+;/i.exec(uas);
  _mobile = /Mobile/i.exec(uas);

  // Note that the IE team blog would have you believe you should be checking
  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
  // from either x64 or ia64;  so ultimately, you should just check for Win64
  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
  // Windows will send 'WOW64' instead.
  _win64 = !!/Win64/.exec(uas);
  if (agent) {
    _ie = agent[1] ? parseFloat(agent[1]) : agent[5] ? parseFloat(agent[5]) : NaN;
    // IE compatibility mode
    if (_ie && document && document.documentMode) {
      _ie = document.documentMode;
    }
    // grab the "true" ie version from the trident token if available
    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;
    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
    _opera = agent[3] ? parseFloat(agent[3]) : NaN;
    _webkit = agent[4] ? parseFloat(agent[4]) : NaN;
    if (_webkit) {
      // We do not add the regexp to the above test, because it will always
      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
      // the userAgent string.
      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
    } else {
      _chrome = NaN;
    }
  } else {
    _ie = _firefox = _opera = _chrome = _webkit = NaN;
  }
  if (os) {
    if (os[1]) {
      // Detect OS X version.  If no version number matches, set _osx to true.
      // Version examples:  10, 10_6_1, 10.7
      // Parses version number as a float, taking only first two sets of
      // digits.  If only one set of digits is found, returns just the major
      // version number.
      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);
      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
    } else {
      _osx = false;
    }
    _windows = !!os[2];
    _linux = !!os[3];
  } else {
    _osx = _windows = _linux = false;
  }
}
var UserAgent_DEPRECATED = {
  /**
   *  Check if the UA is Internet Explorer.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  ie: function () {
    return _populate() || _ie;
  },
  /**
   * Check if we're in Internet Explorer compatibility mode.
   *
   * @return bool true if in compatibility mode, false if
   * not compatibility mode or not ie
   */
  ieCompatibilityMode: function () {
    return _populate() || _ie_real_version > _ie;
  },
  /**
   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
   * only need this because Skype can't handle 64-bit IE yet.  We need to remove
   * this when we don't need it -- tracked by #601957.
   */
  ie64: function () {
    return UserAgent_DEPRECATED.ie() && _win64;
  },
  /**
   *  Check if the UA is Firefox.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  firefox: function () {
    return _populate() || _firefox;
  },
  /**
   *  Check if the UA is Opera.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  opera: function () {
    return _populate() || _opera;
  },
  /**
   *  Check if the UA is WebKit.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  webkit: function () {
    return _populate() || _webkit;
  },
  /**
   *  For Push
   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
   */
  safari: function () {
    return UserAgent_DEPRECATED.webkit();
  },
  /**
   *  Check if the UA is a Chrome browser.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  chrome: function () {
    return _populate() || _chrome;
  },
  /**
   *  Check if the user is running Windows.
   *
   *  @return bool `true' if the user's OS is Windows.
   */
  windows: function () {
    return _populate() || _windows;
  },
  /**
   *  Check if the user is running Mac OS X.
   *
   *  @return float|bool   Returns a float if a version number is detected,
   *                       otherwise true/false.
   */
  osx: function () {
    return _populate() || _osx;
  },
  /**
   * Check if the user is running Linux.
   *
   * @return bool `true' if the user's OS is some flavor of Linux.
   */
  linux: function () {
    return _populate() || _linux;
  },
  /**
   * Check if the user is running on an iPhone or iPod platform.
   *
   * @return bool `true' if the user is running some flavor of the
   *    iPhone OS.
   */
  iphone: function () {
    return _populate() || _iphone;
  },
  mobile: function () {
    return _populate() || _iphone || _ipad || _android || _mobile;
  },
  nativeApp: function () {
    // webviews inside of the native apps
    return _populate() || _native;
  },
  android: function () {
    return _populate() || _android;
  },
  ipad: function () {
    return _populate() || _ipad;
  }
};
module.exports = UserAgent_DEPRECATED;

/***/ }),

/***/ 417:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */



var ExecutionEnvironment = __webpack_require__(509);
var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }
  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);
  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }
  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }
  return isSupported;
}
module.exports = isEventSupported;

/***/ }),

/***/ 452:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule normalizeWheel
 * @typechecks
 */



var UserAgent_DEPRECATED = __webpack_require__(431);
var isEventSupported = __webpack_require__(417);

// Reasonable defaults
var PIXEL_STEP = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;

/**
 * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
 * complicated, thus this doc is long and (hopefully) detailed enough to answer
 * your questions.
 *
 * If you need to react to the mouse wheel in a predictable way, this code is
 * like your bestest friend. * hugs *
 *
 * As of today, there are 4 DOM event types you can listen to:
 *
 *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
 *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
 *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
 *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
 *
 * So what to do?  The is the best:
 *
 *   normalizeWheel.getEventType();
 *
 * In your event callback, use this code to get sane interpretation of the
 * deltas.  This code will return an object with properties:
 *
 *   spinX   -- normalized spin speed (use for zoom) - x plane
 *   spinY   -- " - y plane
 *   pixelX  -- normalized distance (to pixels) - x plane
 *   pixelY  -- " - y plane
 *
 * Wheel values are provided by the browser assuming you are using the wheel to
 * scroll a web page by a number of lines or pixels (or pages).  Values can vary
 * significantly on different platforms and browsers, forgetting that you can
 * scroll at different speeds.  Some devices (like trackpads) emit more events
 * at smaller increments with fine granularity, and some emit massive jumps with
 * linear speed or acceleration.
 *
 * This code does its best to normalize the deltas for you:
 *
 *   - spin is trying to normalize how far the wheel was spun (or trackpad
 *     dragged).  This is super useful for zoom support where you want to
 *     throw away the chunky scroll steps on the PC and make those equal to
 *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
 *     resolve a single slow step on a wheel to 1.
 *
 *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
 *     get the crazy differences between browsers, but at least it'll be in
 *     pixels!
 *
 *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
 *     should translate to positive value zooming IN, negative zooming OUT.
 *     This matches the newer 'wheel' event.
 *
 * Why are there spinX, spinY (or pixels)?
 *
 *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
 *     with a mouse.  It results in side-scrolling in the browser by default.
 *
 *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
 *
 *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
 *     probably is by browsers in conjunction with fancy 3D controllers .. but
 *     you know.
 *
 * Implementation info:
 *
 * Examples of 'wheel' event if you scroll slowly (down) by one step with an
 * average mouse:
 *
 *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
 *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
 *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
 *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
 *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
 *
 * On the trackpad:
 *
 *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
 *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
 *
 * On other/older browsers.. it's more complicated as there can be multiple and
 * also missing delta values.
 *
 * The 'wheel' event is more standard:
 *
 * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
 *
 * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
 * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
 * backward compatibility with older events.  Those other values help us
 * better normalize spin speed.  Example of what the browsers provide:
 *
 *                          | event.wheelDelta | event.detail
 *        ------------------+------------------+--------------
 *          Safari v5/OS X  |       -120       |       0
 *          Safari v5/Win7  |       -120       |       0
 *         Chrome v17/OS X  |       -120       |       0
 *         Chrome v17/Win7  |       -120       |       0
 *                IE9/Win7  |       -120       |   undefined
 *         Firefox v4/OS X  |     undefined    |       1
 *         Firefox v4/Win7  |     undefined    |       3
 *
 */
function normalizeWheel( /*object*/event) /*object*/{
  var sX = 0,
    sY = 0,
    // spinX, spinY
    pX = 0,
    pY = 0; // pixelX, pixelY

  // Legacy
  if ('detail' in event) {
    sY = event.detail;
  }
  if ('wheelDelta' in event) {
    sY = -event.wheelDelta / 120;
  }
  if ('wheelDeltaY' in event) {
    sY = -event.wheelDeltaY / 120;
  }
  if ('wheelDeltaX' in event) {
    sX = -event.wheelDeltaX / 120;
  }

  // side scrolling on FF with DOMMouseScroll
  if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }
  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;
  if ('deltaY' in event) {
    pY = event.deltaY;
  }
  if ('deltaX' in event) {
    pX = event.deltaX;
  }
  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode == 1) {
      // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }
  return {
    spinX: sX,
    spinY: sY,
    pixelX: pX,
    pixelY: pY
  };
}

/**
 * The best combination if you prefer spinX + spinY normalization.  It favors
 * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
 * 'wheel' event, making spin speed determination impossible.
 */
normalizeWheel.getEventType = function () /*string*/{
  return UserAgent_DEPRECATED.firefox() ? 'DOMMouseScroll' : isEventSupported('wheel') ? 'wheel' : 'mousewheel';
};
module.exports = normalizeWheel;

/***/ }),

/***/ 748:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = function () {
  if (typeof Map !== 'undefined') {
    return Map;
  }
  /**
   * Returns index in provided array that matches the specified key.
   *
   * @param {Array<Array>} arr
   * @param {*} key
   * @returns {number}
   */
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function (entry, index) {
      if (entry[0] === key) {
        result = index;
        return true;
      }
      return false;
    });
    return result;
  }
  return (/** @class */function () {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function () {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      /**
       * @param {*} key
       * @returns {*}
       */
      class_1.prototype.get = function (key) {
        var index = getIndex(this.__entries__, key);
        var entry = this.__entries__[index];
        return entry && entry[1];
      };
      /**
       * @param {*} key
       * @param {*} value
       * @returns {void}
       */
      class_1.prototype.set = function (key, value) {
        var index = getIndex(this.__entries__, key);
        if (~index) {
          this.__entries__[index][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */
      class_1.prototype.delete = function (key) {
        var entries = this.__entries__;
        var index = getIndex(entries, key);
        if (~index) {
          entries.splice(index, 1);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */
      class_1.prototype.has = function (key) {
        return !!~getIndex(this.__entries__, key);
      };
      /**
       * @returns {void}
       */
      class_1.prototype.clear = function () {
        this.__entries__.splice(0);
      };
      /**
       * @param {Function} callback
       * @param {*} [ctx=null]
       * @returns {void}
       */
      class_1.prototype.forEach = function (callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = function () {
  if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {
    return __webpack_require__.g;
  }
  if (typeof self !== 'undefined' && self.Math === Math) {
    return self;
  }
  if (typeof window !== 'undefined' && window.Math === Math) {
    return window;
  }
  // eslint-disable-next-line no-new-func
  return Function('return this')();
}();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = function () {
  if (typeof requestAnimationFrame === 'function') {
    // It's required to use a bounded function because IE sometimes throws
    // an "Invalid calling object" error if rAF is invoked without the global
    // object on the left hand side.
    return requestAnimationFrame.bind(global$1);
  }
  return function (callback) {
    return setTimeout(function () {
      return callback(Date.now());
    }, 1000 / 60);
  };
}();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle(callback, delay) {
  var leadingCall = false,
    trailingCall = false,
    lastCallTime = 0;
  /**
   * Invokes the original callback function and schedules new invocation if
   * the "proxy" was called during current request.
   *
   * @returns {void}
   */
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  /**
   * Callback invoked after the specified delay. It will further postpone
   * invocation of the original function delegating it to the
   * requestAnimationFrame.
   *
   * @returns {void}
   */
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  /**
   * Schedules invocation of the original function.
   *
   * @returns {void}
   */
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      // Reject immediately following calls.
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      // Schedule new call to be in invoked when the pending one is resolved.
      // This is important for "transitions" which never actually start
      // immediately so there is a chance that we might miss one if change
      // happens amids the pending invocation.
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */function () {
  /**
   * Creates a new instance of ResizeObserverController.
   *
   * @private
   */
  function ResizeObserverController() {
    /**
     * Indicates whether DOM listeners have been added.
     *
     * @private {boolean}
     */
    this.connected_ = false;
    /**
     * Tells that controller has subscribed for Mutation Events.
     *
     * @private {boolean}
     */
    this.mutationEventsAdded_ = false;
    /**
     * Keeps reference to the instance of MutationObserver.
     *
     * @private {MutationObserver}
     */
    this.mutationsObserver_ = null;
    /**
     * A list of connected observers.
     *
     * @private {Array<ResizeObserverSPI>}
     */
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  /**
   * Adds observer to observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be added.
   * @returns {void}
   */
  ResizeObserverController.prototype.addObserver = function (observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    // Add listeners if they haven't been added yet.
    if (!this.connected_) {
      this.connect_();
    }
  };
  /**
   * Removes observer from observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be removed.
   * @returns {void}
   */
  ResizeObserverController.prototype.removeObserver = function (observer) {
    var observers = this.observers_;
    var index = observers.indexOf(observer);
    // Remove observer if it's present in registry.
    if (~index) {
      observers.splice(index, 1);
    }
    // Remove listeners if controller has no connected observers.
    if (!observers.length && this.connected_) {
      this.disconnect_();
    }
  };
  /**
   * Invokes the update of observers. It will continue running updates insofar
   * it detects changes.
   *
   * @returns {void}
   */
  ResizeObserverController.prototype.refresh = function () {
    var changesDetected = this.updateObservers_();
    // Continue running updates if changes have been detected as there might
    // be future ones caused by CSS transitions.
    if (changesDetected) {
      this.refresh();
    }
  };
  /**
   * Updates every observer from observers list and notifies them of queued
   * entries.
   *
   * @private
   * @returns {boolean} Returns "true" if any observer has detected changes in
   *      dimensions of it's elements.
   */
  ResizeObserverController.prototype.updateObservers_ = function () {
    // Collect observers that have active observations.
    var activeObservers = this.observers_.filter(function (observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    // Deliver notifications in a separate cycle in order to avoid any
    // collisions between observers, e.g. when multiple instances of
    // ResizeObserver are tracking the same element and the callback of one
    // of them changes content dimensions of the observed target. Sometimes
    // this may result in notifications being blocked for the rest of observers.
    activeObservers.forEach(function (observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  /**
   * Initializes DOM listeners.
   *
   * @private
   * @returns {void}
   */
  ResizeObserverController.prototype.connect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already added.
    if (!isBrowser || this.connected_) {
      return;
    }
    // Subscription to the "Transitionend" event is used as a workaround for
    // delayed transitions. This way it's possible to capture at least the
    // final state of an element.
    document.addEventListener('transitionend', this.onTransitionEnd_);
    window.addEventListener('resize', this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener('DOMSubtreeModified', this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  /**
   * Removes DOM listeners.
   *
   * @private
   * @returns {void}
   */
  ResizeObserverController.prototype.disconnect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already removed.
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener('transitionend', this.onTransitionEnd_);
    window.removeEventListener('resize', this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener('DOMSubtreeModified', this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  /**
   * "Transitionend" event handler.
   *
   * @private
   * @param {TransitionEvent} event
   * @returns {void}
   */
  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
    var _b = _a.propertyName,
      propertyName = _b === void 0 ? '' : _b;
    // Detect whether transition may affect dimensions of an element.
    var isReflowProperty = transitionKeys.some(function (key) {
      return !!~propertyName.indexOf(key);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  /**
   * Returns instance of the ResizeObserverController.
   *
   * @returns {ResizeObserverController}
   */
  ResizeObserverController.getInstance = function () {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController();
    }
    return this.instance_;
  };
  /**
   * Holds reference to the controller's instance.
   *
   * @private {ResizeObserverController}
   */
  ResizeObserverController.instance_ = null;
  return ResizeObserverController;
}();

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = function (target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = function (target) {
  // Assume that the element is an instance of Node, which means that it
  // has the "ownerDocument" property from which we can retrieve a
  // corresponding global object.
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  // Return the local global object if it's not possible extract one from
  // provided element.
  return ownerGlobal || global$1;
};

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
  return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function (size, position) {
    var value = styles['border-' + position + '-width'];
    return size + toFloat(value);
  }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
  var positions = ['top', 'right', 'bottom', 'left'];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles['padding-' + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
  // Client width & height properties can't be
  // used exclusively as they provide rounded values.
  var clientWidth = target.clientWidth,
    clientHeight = target.clientHeight;
  // By this condition we can catch all non-replaced inline, hidden and
  // detached elements. Though elements with width & height properties less
  // than 0.5 will be discarded as well.
  //
  // Without it we would need to implement separate methods for each of
  // those cases and it's not possible to perform a precise and performance
  // effective test for hidden elements. E.g. even jQuery's ':visible' filter
  // gives wrong results for elements with width & height less than 0.5.
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  // Computed styles of width & height are being used because they are the
  // only dimensions available to JS that contain non-rounded values. It could
  // be possible to utilize the getBoundingClientRect if only it's data wasn't
  // affected by CSS transformations let alone paddings, borders and scroll bars.
  var width = toFloat(styles.width),
    height = toFloat(styles.height);
  // Width & height include paddings and borders when the 'border-box' box
  // model is applied (except for IE).
  if (styles.boxSizing === 'border-box') {
    // Following conditions are required to handle Internet Explorer which
    // doesn't include paddings and borders to computed CSS dimensions.
    //
    // We can say that if CSS dimensions + paddings are equal to the "client"
    // properties then it's either IE, and thus we don't need to subtract
    // anything, or an element merely doesn't have paddings/borders styles.
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, 'left', 'right') + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
    }
  }
  // Following steps can't be applied to the document's root element as its
  // client[Width/Height] properties represent viewport area of the window.
  // Besides, it's as well not necessary as the <html> itself neither has
  // rendered scroll bars nor it can be clipped.
  if (!isDocumentElement(target)) {
    // In some browsers (only in Firefox, actually) CSS width & height
    // include scroll bars size which can be removed at this step as scroll
    // bars are the only difference between rounded dimensions + paddings
    // and "client" properties, though that is not always true in Chrome.
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    // Chrome has a rather weird rounding of "client" properties.
    // E.g. for an element with content width of 314.2px it sometimes gives
    // the client width of 315px and for the width of 314.7px it may give
    // 314px. And it doesn't happen all the time. So just ignore this delta
    // as a non-relevant.
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = function () {
  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
  // interface.
  if (typeof SVGGraphicsElement !== 'undefined') {
    return function (target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  // If it's so, then check that element is at least an instance of the
  // SVGElement and that it has the "getBBox" method.
  // eslint-disable-next-line no-extra-parens
  return function (target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
  };
}();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
  var x = _a.x,
    y = _a.y,
    width = _a.width,
    height = _a.height;
  // If DOMRectReadOnly is available use it as a prototype for the rectangle.
  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  // Rectangle's properties are not writable and non-enumerable.
  defineConfigurable(rect, {
    x: x,
    y: y,
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */function () {
  /**
   * Creates an instance of ResizeObservation.
   *
   * @param {Element} target - Element to be observed.
   */
  function ResizeObservation(target) {
    /**
     * Broadcasted width of content rectangle.
     *
     * @type {number}
     */
    this.broadcastWidth = 0;
    /**
     * Broadcasted height of content rectangle.
     *
     * @type {number}
     */
    this.broadcastHeight = 0;
    /**
     * Reference to the last observed content rectangle.
     *
     * @private {DOMRectInit}
     */
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  /**
   * Updates content rectangle and tells whether it's width or height properties
   * have changed since the last broadcast.
   *
   * @returns {boolean}
   */
  ResizeObservation.prototype.isActive = function () {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  /**
   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
   * from the corresponding properties of the last observed content rectangle.
   *
   * @returns {DOMRectInit} Last observed content rectangle.
   */
  ResizeObservation.prototype.broadcastRect = function () {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation;
}();
var ResizeObserverEntry = /** @class */function () {
  /**
   * Creates an instance of ResizeObserverEntry.
   *
   * @param {Element} target - Element that is being observed.
   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
   */
  function ResizeObserverEntry(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    // According to the specification following properties are not writable
    // and are also not enumerable in the native implementation.
    //
    // Property accessors are not being used as they'd require to define a
    // private WeakMap storage which may cause memory leaks in browsers that
    // don't support this type of collections.
    defineConfigurable(this, {
      target: target,
      contentRect: contentRect
    });
  }
  return ResizeObserverEntry;
}();
var ResizeObserverSPI = /** @class */function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback function that is invoked
   *      when one of the observed elements changes it's content dimensions.
   * @param {ResizeObserverController} controller - Controller instance which
   *      is responsible for the updates of observer.
   * @param {ResizeObserver} callbackCtx - Reference to the public
   *      ResizeObserver instance which will be passed to callback function.
   */
  function ResizeObserverSPI(callback, controller, callbackCtx) {
    /**
     * Collection of resize observations that have detected changes in dimensions
     * of elements.
     *
     * @private {Array<ResizeObservation>}
     */
    this.activeObservations_ = [];
    /**
     * Registry of the ResizeObservation instances.
     *
     * @private {Map<Element, ResizeObservation>}
     */
    this.observations_ = new MapShim();
    if (typeof callback !== 'function') {
      throw new TypeError('The callback provided as parameter 1 is not a function.');
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  /**
   * Starts observing provided element.
   *
   * @param {Element} target - Element to be observed.
   * @returns {void}
   */
  ResizeObserverSPI.prototype.observe = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }
    // Do nothing if current environment doesn't have the Element interface.
    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    // Do nothing if element is already being observed.
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    // Force the update of observations.
    this.controller_.refresh();
  };
  /**
   * Stops observing provided element.
   *
   * @param {Element} target - Element to stop observing.
   * @returns {void}
   */
  ResizeObserverSPI.prototype.unobserve = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }
    // Do nothing if current environment doesn't have the Element interface.
    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    // Do nothing if element is not being observed.
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  /**
   * Stops observing all elements.
   *
   * @returns {void}
   */
  ResizeObserverSPI.prototype.disconnect = function () {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  /**
   * Collects observation instances the associated element of which has changed
   * it's content rectangle.
   *
   * @returns {void}
   */
  ResizeObserverSPI.prototype.gatherActive = function () {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function (observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  /**
   * Invokes initial callback function with a list of ResizeObserverEntry
   * instances collected from active resize observations.
   *
   * @returns {void}
   */
  ResizeObserverSPI.prototype.broadcastActive = function () {
    // Do nothing if observer doesn't have active observations.
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    // Create ResizeObserverEntry instance for every active observation.
    var entries = this.activeObservations_.map(function (observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  /**
   * Clears the collection of active observations.
   *
   * @returns {void}
   */
  ResizeObserverSPI.prototype.clearActive = function () {
    this.activeObservations_.splice(0);
  };
  /**
   * Tells whether observer has active observations.
   *
   * @returns {boolean}
   */
  ResizeObserverSPI.prototype.hasActive = function () {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI;
}();

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback that is invoked when
   *      dimensions of the observed elements change.
   */
  function ResizeObserver(callback) {
    if (!(this instanceof ResizeObserver)) {
      throw new TypeError('Cannot call a class as a function.');
    }
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver;
}();
// Expose public methods of ResizeObserver.
['observe', 'unobserve', 'disconnect'].forEach(function (method) {
  ResizeObserver.prototype[method] = function () {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function () {
  // Export existing implementation if available.
  if (typeof global$1.ResizeObserver !== 'undefined') {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
/* harmony default export */ __webpack_exports__["default"] = (index);

/***/ }),

/***/ 492:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable no-undefined */

var throttle = __webpack_require__(518);

/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param  {Number}   delay         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}  [atBegin]     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 * @param  {Function} callback      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                  to `callback` when the debounced-function is executed.
 *
 * @return {Function} A new, debounced function.
 */
module.exports = function (delay, atBegin, callback) {
  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
};

/***/ }),

/***/ 658:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var throttle = __webpack_require__(518);
var debounce = __webpack_require__(492);
module.exports = {
  throttle: throttle,
  debounce: debounce
};

/***/ }),

/***/ 518:
/***/ (function(module) {

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset)
 * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @return {Function}  A new, throttled, function.
 */
module.exports = function (delay, noTrailing, callback, debounceMode) {
  // After wrapper has stopped being called, this timeout ensures that
  // `callback` is executed at the proper times in `throttle` and `end`
  // debounce modes.
  var timeoutID;

  // Keep track of the last time `callback` was executed.
  var lastExec = 0;

  // `noTrailing` defaults to falsy.
  if (typeof noTrailing !== 'boolean') {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = undefined;
  }

  // The `wrapper` function encapsulates all of the throttling / debouncing
  // functionality and when executed will limit the rate at which `callback`
  // is executed.
  function wrapper() {
    var self = this;
    var elapsed = Number(new Date()) - lastExec;
    var args = arguments;

    // Execute `callback` and update the `lastExec` timestamp.
    function exec() {
      lastExec = Number(new Date());
      callback.apply(self, args);
    }

    // If `debounceMode` is true (at begin) this is used to clear the flag
    // to allow future `callback` executions.
    function clear() {
      timeoutID = undefined;
    }
    if (debounceMode && !timeoutID) {
      // Since `wrapper` is being called for the first time and
      // `debounceMode` is true (at begin), execute `callback`.
      exec();
    }

    // Clear any existing timeout.
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
    if (debounceMode === undefined && elapsed > delay) {
      // In throttle mode, if `delay` time has been exceeded, execute
      // `callback`.
      exec();
    } else if (noTrailing !== true) {
      // In trailing throttle mode, since `delay` time has not been
      // exceeded, schedule `callback` to execute `delay` ms after most
      // recent execution.
      //
      // If `debounceMode` is true (at begin), schedule `clear` to execute
      // after `delay` ms.
      //
      // If `debounceMode` is false (at end), schedule `callback` to
      // execute after `delay` ms.
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  }

  // Return the wrapper function.
  return wrapper;
};

/***/ }),

/***/ 203:
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__203__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ entry_lib; }
});

;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
/* eslint-disable no-var */
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/element-ui/lib/table-column.js
var table_column = __webpack_require__(14);
var table_column_default = /*#__PURE__*/__webpack_require__.n(table_column);
// EXTERNAL MODULE: ./node_modules/element-ui/lib/table.js
var table = __webpack_require__(562);
var table_default = /*#__PURE__*/__webpack_require__.n(table);
// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(203);
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/package/ElSTable/src/index.vue?vue&type=script&lang=js&







external_commonjs_vue_commonjs2_vue_root_Vue_default().use((table_default()));
external_commonjs_vue_commonjs2_vue_root_Vue_default().use((table_column_default()));
// 表格 单元格默认设置 可在 columns 对应列传入相应属性
const RESIZEABLE = true; // resizable: true 默认用户可调整单元格尺寸
const SHOWOVERFLOWTOOLTIP = true; // show-overflow-tooltip: true 默认单元格一行 不换行 超出显示...
/* harmony default export */ var srcvue_type_script_lang_js_ = ({
  name: "ElSTable",
  props: {
    tableKey: {
      type: Number | String
    },
    columns: {
      type: Array,
      default: () => []
    },
    "summary-ahead": {
      // show-summary 为true 显示合计时， 若传了此参数为true 则合计显示在第一行 为false 则在最后一行
      type: Boolean,
      default: true
    },
    data: {
      type: Array,
      default: () => []
    },
    height: {
      type: String | Number,
      default: undefined
    },
    "max-height": {
      type: String | Number,
      default: undefined
    },
    stripe: {
      type: Boolean,
      default: false
    },
    border: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: undefined
    },
    fit: {
      type: Boolean,
      default: true
    },
    "show-header": {
      type: Boolean,
      default: true
    },
    "highlight-current-row": {
      type: Boolean,
      default: false
    },
    "current-row-key": {
      type: String | Number,
      default: undefined
    },
    "row-class-name": {
      type: Function | String,
      default: undefined
    },
    "row-style": {
      type: Function | Object,
      default: undefined
    },
    "cell-class-name": {
      type: Function | String,
      default: undefined
    },
    "cell-style": {
      type: Function | Object,
      default: undefined
    },
    "header-row-class-name": {
      type: Function | String,
      default: undefined
    },
    "header-row-style": {
      type: Function | Object,
      default: undefined
    },
    "header-cell-class-name": {
      type: Function | String,
      default: undefined
    },
    "header-cell-style": {
      type: Function | Object,
      default: undefined
    },
    "row-key": {
      type: Function | String,
      default: undefined
    },
    "empty-text": {
      type: String,
      default: "暂无数据"
    },
    "default-expand-all": {
      type: Boolean,
      default: false
    },
    "expand-row-keys": {
      type: Array,
      default: undefined
    },
    "default-sort": {
      type: Object,
      default: () => {
        return {
          order: "ascending"
        };
      }
    },
    "tooltip-effect": {
      type: String,
      default: undefined
    },
    "show-summary": {
      type: Boolean,
      default: false
    },
    "sum-text": {
      type: String,
      default: "合计"
    },
    "summary-method": {
      type: Function,
      default: undefined
    },
    "span-method": {
      type: Function,
      default: undefined
    },
    "select-on-indeterminate": {
      type: Boolean,
      default: true
    },
    indent: {
      type: Number,
      default: 16
    },
    lazy: {
      type: Boolean,
      default: undefined
    },
    load: {
      type: Function,
      default: undefined
    },
    "tree-props": {
      type: Object,
      default: () => {
        return {
          hasChildren: "hasChildren",
          children: "children"
        };
      }
    }
    // "fix-window": { // 表格固定高度
    //   type: Boolean,
    //   default: false
    // }
  },

  data() {
    return {
      tableHeight: undefined,
      minHeight: 150,
      // 表格最小高度
      key: 1,
      observe: undefined,
      // 监听页面对象
      fixColumns: [] // 固定列处理后
    };
  },

  render(h) {
    var _this = this;
    const {
      columns,
      height,
      ...tableAttr
    } = this._props;
    const selection = this.visibleColumns.find(item => item.type === "selection");
    const tHeaders = this.visibleColumns.filter(item => item.type != "selection");
    const theHeight = this.fixWindow ? this.tableHeight : this.height;
    const innerDom = [];
    if (selection) {
      innerDom.push(h("el-table-column", {
        key: "selection",
        props: {
          resizable: RESIZEABLE,
          align: "center",
          ...selection
        }
      }));
    }
    this.renderTpl(h, tHeaders, innerDom);
    return h("el-table", {
      ref: "table",
      key: this.theTableKey,
      class: {
        summary_ahead: this.showSummary && this.summaryAhead
      },
      props: {
        ...tableAttr,
        maxHeight: theHeight
      },
      on: {
        select: function () {
          for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
            arg[_key] = arguments[_key];
          }
          return _this.handEvent("select", ...arg);
        },
        "select-all": function () {
          for (var _len2 = arguments.length, arg = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            arg[_key2] = arguments[_key2];
          }
          return _this.handEvent("select-all", ...arg);
        },
        "selection-change": function () {
          for (var _len3 = arguments.length, arg = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            arg[_key3] = arguments[_key3];
          }
          return _this.handEvent("selection-change", ...arg);
        },
        "cell-mouse-enter": function () {
          for (var _len4 = arguments.length, arg = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            arg[_key4] = arguments[_key4];
          }
          return _this.handEvent("cell-mouse-enter", ...arg);
        },
        "cell-mouse-leave": function () {
          for (var _len5 = arguments.length, arg = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            arg[_key5] = arguments[_key5];
          }
          return _this.handEvent("cell-mouse-leave", ...arg);
        },
        "cell-click": function () {
          for (var _len6 = arguments.length, arg = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            arg[_key6] = arguments[_key6];
          }
          return _this.handEvent("cell-click", ...arg);
        },
        "cell-dblclick": function () {
          for (var _len7 = arguments.length, arg = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            arg[_key7] = arguments[_key7];
          }
          return _this.handEvent("cell-dblclick", ...arg);
        },
        "row-click": function () {
          for (var _len8 = arguments.length, arg = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
            arg[_key8] = arguments[_key8];
          }
          return _this.handEvent("row-click", ...arg);
        },
        "row-contextmenu": function () {
          for (var _len9 = arguments.length, arg = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            arg[_key9] = arguments[_key9];
          }
          return _this.handEvent("row-contextmenu", ...arg);
        },
        "row-dblclick": function () {
          for (var _len10 = arguments.length, arg = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
            arg[_key10] = arguments[_key10];
          }
          return _this.handEvent("row-dblclick", ...arg);
        },
        "header-click": function () {
          for (var _len11 = arguments.length, arg = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
            arg[_key11] = arguments[_key11];
          }
          return _this.handEvent("header-click", ...arg);
        },
        "header-contextmenu": function () {
          for (var _len12 = arguments.length, arg = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
            arg[_key12] = arguments[_key12];
          }
          return _this.handEvent("header-contextmenu", ...arg);
        },
        "sort-change": function () {
          for (var _len13 = arguments.length, arg = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
            arg[_key13] = arguments[_key13];
          }
          return _this.handEvent("sort-change", ...arg);
        },
        "filter-change": function () {
          for (var _len14 = arguments.length, arg = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
            arg[_key14] = arguments[_key14];
          }
          return _this.handEvent("filter-change", ...arg);
        },
        "current-change": function () {
          for (var _len15 = arguments.length, arg = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
            arg[_key15] = arguments[_key15];
          }
          return _this.handEvent("current-change", ...arg);
        },
        "header-dragend": function () {
          for (var _len16 = arguments.length, arg = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
            arg[_key16] = arguments[_key16];
          }
          return _this.handEvent("header-dragend", ...arg);
        }
      }
    }, innerDom);
  },
  created() {
    this.fixColumns = this.columns.map((item, index) => {
      if (item.fixed) {
        item["class-name"] = "fix_column " + (item.fixed == "left" ? "fix_left" : "fix_right");
        item.fixed = false;
        if (item.fixed != "left" && this.columns[index - 1]) {
          const preRow = this.columns[index - 1];
          preRow["class-name"] = "no_border_r";
        }
      }
      return item;
    });
  },
  computed: {
    theTableKey: function () {
      const theHeight = this.fixWindow ? this.tableHeight : this.height;
      return this.tableKey + "" + this.visibleColumns.length + (theHeight || 0) + this.key;
    },
    visibleColumns: function () {
      return this.fixColumns.filter(item => item.visible || !item.hasOwnProperty("visible"));
    }
  },
  activated() {
    if (this.observe) {
      const innerDom = this.getDom(this.$el, "main");
      this.observe.observe(innerDom, {
        attributes: true,
        childList: false,
        subtree: true
      });
      this.key = this.key > 100 ? 1 : this.key + 1; // 路由页面缓存时出现表头显示错乱 改变key 刷新表格
    }
  },

  deactivated() {
    this.observe && this.observe.disconnect(); // 非活动标签页，关闭页面监听
  },

  mounted() {
    const innerDom = this.getDom(this.$el, "main");
    const scrollDom = this.$root.$el.childNodes[0];
    if (this.fixWindow && innerDom) {
      let timer,
        times = 1;
      this.observe = new MutationObserver((mu, ob) => {
        // 监听页面改变
        // console.log(scrollDom.scrollHeight , scrollDom.offsetHeight);
        if (scrollDom.scrollHeight - scrollDom.offsetHeight > 0 || scrollDom.clientHeight - innerDom.clientHeight - 118 > 0) {
          // console.log("DOM被更新了");
          if (timer) {
            times++;
            return;
          }
          timer = setTimeout(() => {
            clearTimeout(timer);
            timer = null;
            if (times != 1) {
              times = 1;
              const height = this.getHeight();
              if (this.tableHeight <= this.minHeight && height < this.tableHeight || height == this.tableHeight) return;
              this.tableHeight = height;
              // this.key = this.key > 100 ? 1 : this.key + 1
            }
          }, 400);
          if (times != 1) return;
          const height = this.getHeight();
          if (this.tableHeight <= this.minHeight && height < this.tableHeight || height == this.tableHeight) return;
          this.tableHeight = height;
          // this.key = this.key > 100 ? 1 : this.key + 1
        }
      });

      this.observe.observe(innerDom, {
        attributes: true,
        childList: false,
        subtree: true
      });
    }
  },
  methods: {
    renderTpl(h, arr, innerDom) {
      arr.map((item, index) => {
        let childDom = undefined;
        if (item.children) {
          // 如果是多级表头
          childDom = [];
          this.renderTpl(h, item.children, childDom);
        }
        const innerSet = {
          key: (item.prop || "") + index,
          props: {
            resizable: RESIZEABLE,
            "show-overflow-tooltip": SHOWOVERFLOWTOOLTIP,
            align: "center",
            ...item
          }
        };
        let childSet = undefined;
        if (this.$scopedSlots[item.prop]) {
          // slot 自定义单元格展示
          childSet = [];
          innerSet.scopedSlots = innerSet.scopedSlots || {};
          innerSet.scopedSlots.default = props => {
            const obj = {
              row: props.row,
              $index: props.$index
            };
            childSet[0] = this.$scopedSlots[item.prop](obj);
            return childSet;
          };
        }
        if (this.$scopedSlots["header-" + item.prop]) {
          // slot 自定义header
          childSet = [];
          innerSet.scopedSlots = innerSet.scopedSlots || {};
          innerSet.scopedSlots.header = props => {
            const obj = {
              row: {
                ...item,
                ...props.column
              }
            };
            childSet[0] = this.$scopedSlots["header-" + item.prop](obj);
            return childSet;
          };
        }
        innerDom.push(h("el-table-column", innerSet, childDom));
      });
    },
    getHeight() {
      const scrollDoms = this.$root.$el.childNodes[0];
      const innerDoms = this.getDom(this.$el, "main");
      if (this.fixWindow && scrollDoms && innerDoms) {
        let height;
        if (scrollDoms.scrollHeight - scrollDoms.offsetHeight > 0) {
          // main元素改动 出现滚动条
          height = this.$el.offsetHeight - this.$el.clientTop - (scrollDoms.scrollHeight - scrollDoms.offsetHeight + scrollDoms.clientTop);
          if (height <= 0) height = this.$el.offsetHeight - this.$el.clientTop;
        } else {
          // main元素改动 未出现滚动条
          height = scrollDoms.offsetHeight - scrollDoms.clientTop - (innerDoms.offsetHeight - innerDoms.clientTop - this.$el.offsetHeight + this.$el.clientTop) - 118;
        }
        height = Math.max(this.minHeight, height);
        if (Math.abs(this.tableHeight - height) <= 2) height = Math.min(this.tableHeight, height); // 纠正1px误差
        return height;
      }
    },
    getDom(el, id) {
      if (!el) {
        return false;
      }
      if (el.id == id) {
        return el;
      }
      return this.getDom(el.parentNode, id);
    },
    handEvent(handle) {
      for (var _len17 = arguments.length, arg = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {
        arg[_key17 - 1] = arguments[_key17];
      }
      // console.log(handle,arg)
      this.$emit(handle, ...arg);
    },
    clearSelection() {
      this.$refs.table.clearSelection();
    },
    toggleRowSelection(row, selected) {
      this.$refs.table.toggleRowSelection(row, selected);
    },
    toggleAllSelection() {
      this.$refs.table.toggleAllSelection();
    },
    toggleRowExpansion(row, expanded) {
      this.$refs.table.toggleRowExpansion(row, expanded);
    },
    setCurrentRow(row) {
      this.$refs.table.setCurrentRow(row);
    },
    clearSort() {
      this.$refs.table.clearSort();
    },
    clearFilter(columnKey) {
      this.$refs.table.clearFilter(columnKey);
    },
    doLayout() {
      this.$refs.table.doLayout();
    },
    sort(prop, order) {
      this.$refs.table.sort(prop, order);
    }
  }
});
;// CONCATENATED MODULE: ./src/package/ElSTable/src/index.vue?vue&type=script&lang=js&
 /* harmony default export */ var ElSTable_srcvue_type_script_lang_js_ = (srcvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-64.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-64.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-64.use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/package/ElSTable/src/index.vue?vue&type=style&index=0&id=a79ae052&prod&lang=scss&scoped=true&
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/package/ElSTable/src/index.vue?vue&type=style&index=0&id=a79ae052&prod&lang=scss&scoped=true&

;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent(
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */,
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options =
    typeof scriptExports === 'function' ? scriptExports.options : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) {
    // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
          injectStyles.call(
            this,
            (options.functional ? this.parent : this).$root.$options.shadowRoot
          )
        }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

;// CONCATENATED MODULE: ./src/package/ElSTable/src/index.vue
var render, staticRenderFns
;

;


/* normalize component */

var component = normalizeComponent(
  ElSTable_srcvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  "a79ae052",
  null
  
)

/* harmony default export */ var ElSTable_src = (component.exports);
;// CONCATENATED MODULE: ./src/package/ElSTable/index.js


// 给组件定义install方法
console.log(ElSTable_src, ElSTable_src.name);
ElSTable_src.install = Vue => {
  Vue.component(ElSTable_src.name, ElSTable_src);
};
/* harmony default export */ var ElSTable = (ElSTable_src);
;// CONCATENATED MODULE: ./src/package/index.js

const components = [ElSTable];
const install = Vue => {
  // 判断组件是否安装，如果已经安装了就不在安装。
  if (install.installed) return;
  install.installed = true;
  // 遍历的方式注册所有的组件
  components.map(component => Vue.use(component));
};

// 检查vue是否安装，满足才执行
if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}
/* harmony default export */ var src_package = ({
  // 所有的组件必须有一个install的方法，才能通过Vue.use()进行按需注册
  install,
  ...components
});
;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = (src_package);


}();
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=elstable.umd.js.map